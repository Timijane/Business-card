async function getUserDisplayName(userId) {
    if (!userId) return 'Unknown User';
    try {
      const cachedName = window.userNameCache?.[userId];
      if (cachedName) return cachedName;
      const userDoc = await getDoc(doc(db, "users", userId));
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const displayName = userData.name || userData.displayName || 'User';
        if (!window.userNameCache) window.userNameCache = {};
        window.userNameCache[userId] = displayName;
        return displayName;
      }
      return 'User';
    } catch (error) {
      console.error("Error fetching user name:", error);
      return 'User';
    }
  }

  function renderMessageHTML(msg, isMe, id) {
    const avatarSrc = isMe ? navUserImg.src : currentChatUserAvatar;
    let content = "";
    
    if (msg.replyTo) {
      content += `<div style="background:rgba(0,128,255,0.1); padding:8px 12px; border-left:3px solid var(--primary); border-radius:8px; font-size:12px; margin-bottom:8px;">
        <div style="font-weight:600; color:var(--primary);">${msg.replyTo.user}</div>
        <div style="color:var(--secondary-text);">${msg.replyTo.text.substring(0,50)}</div>
      </div>`;
    }

    if (msg.mediaType === 'image') {
      content += `<img src="${msg.mediaUrl}" class="message-img" loading="lazy">`;
    } else if (msg.mediaType === 'video') {
      content += `<video src="${msg.mediaUrl}" controls class="message-video"></video>`;
    }
    
    if (msg.text) {
      content += `<div>${msg.text.replace(/\n/g, '<br>')}</div>`;
    }

    const div = document.createElement('div');
    div.className = `message-wrapper ${isMe ? 'sent' : 'received'}`;
    div.id = id;

    const optionsHtml = `
      <button class="msg-options-btn" onclick="toggleMsgOptions('${id}')"><i class="fas fa-chevron-down"></i></button>
      <div class="msg-options-menu" id="options-${id}">
        <div class="msg-option-item" onclick="handleReply('${id}', '${(msg.text || 'Media').replace(/'/g, "\\'")}', '${isMe ? 'You' : currentChatUserName}')">
          <i class="fas fa-reply"></i> Reply
        </div>
        <div class="msg-option-item" onclick="handleCopy('${(msg.text || '').replace(/'/g, "\\'")}')">
          <i class="fas fa-copy"></i> Copy
        </div>
        ${isMe ? `<div class="msg-option-item delete" onclick="handleDelete('${id}')"><i class="fas fa-trash-alt"></i> Delete</div>` : ''}
      </div>
    `;

    let timeString = '';
    if (msg.timestamp) {
      const msgTime = new Date(msg.timestamp.seconds * 1000);
      timeString = msgTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    div.innerHTML = `
      ${isMe ? optionsHtml : ''}
      <img src="${avatarSrc}" class="message-avatar-small" alt="${isMe ? 'You' : currentChatUserName}">
      <div class="message-bubble">
        ${content}
        <div class="message-time">${timeString}</div>
      </div>
      ${!isMe ? optionsHtml : ''}
    `;
    
    return div;
  }

  window.toggleMsgOptions = (id) => {
    document.querySelectorAll('.msg-options-menu').forEach(m => {
      if (m.id !== `options-${id}`) m.classList.remove('active');
    });
    const menu = document.getElementById(`options-${id}`);
    if (menu) menu.classList.toggle('active');
  };

  window.handleCopy = async (text) => {
    try {
      if (text) {
        await navigator.clipboard.writeText(text);
        const btn = event.target.closest('.msg-option-item');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
        setTimeout(() => { btn.innerHTML = originalText; }, 2000);
      }
    } catch (error) {
      console.error('Copy failed:', error);
    }
    document.querySelectorAll('.msg-options-menu').forEach(m => m.classList.remove('active'));
  };

  window.handleDelete = async (id) => {
    document.querySelectorAll('.msg-options-menu').forEach(m => m.classList.remove('active'));
    if (!currentChatId) return;
    if (confirm('Delete this message?')) {
      try {
        await deleteDoc(doc(db, "conversations", currentChatId, "messages", id));
      } catch (error) {
        console.error("Delete error:", error);
      }
    }
  };

  window.handleReply = (id, text, user) => {
    replyToMsg = { id, text, user };
    document.getElementById('replyName').innerText = `Replying to ${user}`;
    document.getElementById('replyText').innerText = text.substring(0, 80);
    document.getElementById('replyPreview').style.display = 'flex';
    messageInput.focus();
  };

  window.cancelReply = () => {
    replyToMsg = null;
    editingMsgId = null;
    document.getElementById('replyPreview').style.display = 'none';
    messageInput.value = '';
    messageInput.style.height = '50px';
  };

  window.deleteConversation = async function() {
    if (!currentConversationContext) return;
    if (confirm('Delete this conversation?')) {
      try {
        await deleteDoc(doc(db, "conversations", currentConversationContext));
        const convItem = document.querySelector(`[data-chat-id="${currentConversationContext}"]`);
        if (convItem) convItem.remove();
        if (currentChatId === currentConversationContext) {
          document.getElementById('emptyChat').style.display = 'flex';
          document.getElementById('chatHeader').style.display = 'none';
          document.getElementById('messagesContainer').style.display = 'none';
          currentChatId = null;
        }
      } catch (error) {
        console.error("Delete error:", error);
      }
    }
  };

  const colors = [
    { bg: '#0080FF', tx: '#fff', name: 'Blue' },
    { bg: '#FF0055', tx: '#fff', name: 'Pink' },
    { bg: '#8000FF', tx: '#fff', name: 'Purple' },
    { bg: '#00BFA5', tx: '#fff', name: 'Teal' },
    { bg: '#FF9900', tx: '#fff', name: 'Orange' },
    { bg: '#4CAF50', tx: '#fff', name: 'Green' }
  ];
  
  function initializeColorSelector() {
    const colorGrid = document.getElementById('colorGrid');
    colorGrid.innerHTML = '';
    colors.forEach(color => {
      const div = document.createElement('div');
      div.className = 'color-option';
      div.style.backgroundColor = color.bg;
      div.title = color.name;
      div.onclick = () => {
        document.querySelectorAll('.color-option').forEach(el => el.classList.remove('selected'));
        div.classList.add('selected');
        setChatColor(color.bg, color.tx);
      };
      colorGrid.appendChild(div);
    });
  }

  window.setChatColor = (bg, text) => {
    document.documentElement.style.setProperty('--sent-bubble-bg', bg);
    document.documentElement.style.setProperty('--sent-text-color', text);
    localStorage.setItem('meet_color_bg', bg);
    localStorage.setItem('meet_color_text', text);
  };

  const emojis = {
    "Smileys": ["ðŸ˜€","ðŸ˜ƒ","ðŸ˜„","ðŸ˜","ðŸ˜†","ðŸ˜…","ðŸ˜‚","ðŸ¤£","ðŸ˜Š","ðŸ˜‡"],
    "Hands": ["ðŸ‘‹","ðŸ¤š","âœ‹","ðŸ‘Œ","âœŒï¸","ðŸ¤ž","ðŸ‘","ðŸ‘Ž","âœŠ","ðŸ‘"],
    "People": ["ðŸ‘¶","ðŸ‘§","ðŸ‘¦","ðŸ‘©","ðŸ‘¨","ðŸ‘´","ðŸ‘µ","ðŸ™","ðŸ™Ž","ðŸ™…"]
  };
    
  function initEmojiPicker() {
    const nav = document.getElementById('emojiNav');
    const content = document.getElementById('emojiContent');
    
    Object.keys(emojis).forEach((category, index) => {
      const btn = document.createElement('button');
      btn.innerText = emojis[category][0];
      btn.title = category;
      btn.onclick = () => {
        Array.from(nav.children).forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        
        content.innerHTML = '';
        emojis[category].forEach(emoji => {
          const emojiDiv = document.createElement('div');
          emojiDiv.className = 'emoji-item';
          emojiDiv.innerText = emoji;
          emojiDiv.onclick = () => {
            messageInput.value += emoji;
            messageInput.focus();
          };
          content.appendChild(emojiDiv);
        });
      };
      
      nav.appendChild(btn);
      if (index === 0) btn.click();
    });
  }

  window.toggleEmojiPicker = () => {
    emojiPicker.style.display = emojiPicker.style.display === 'flex' ? 'none' : 'flex';
  };

  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      document.getElementById('logoutBtn').addEventListener('click', () => {
        if (confirm('Logout?')) signOut(auth);
      });
      
      document.getElementById('nightToggleBtn').addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        localStorage.setItem('meet_dark_mode', document.body.classList.contains('dark-mode'));
      });
      
      try {
        const userDoc = await getDoc(doc(db, "users", user.uid));
        let photoURL = user.photoURL;
        let displayName = user.displayName;
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          if (userData.photoURL) photoURL = userData.photoURL;
          if (userData.name) displayName = userData.name;
        }
        
        navUserImg.src = photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName || 'User')}&background=0080FF&color=fff`;
        navUserName.textContent = displayName || 'User';
        
        if (!window.userNameCache) window.userNameCache = {};
        window.userNameCache[user.uid] = displayName || 'User';
        
      } catch (error) {
        console.error("Error loading user data:", error);
      }
      
      loadConversations();
      initEmojiPicker();
      
      const isDarkMode = localStorage.getItem('meet_dark_mode') === 'true';
      if (isDarkMode) document.body.classList.add('dark-mode');
      
      const savedBg = localStorage.getItem('meet_color_bg');
      const savedText = localStorage.getItem('meet_color_text');
      if (savedBg && savedText) {
        document.documentElement.style.setProperty('--sent-bubble-bg', savedBg);
        document.documentElement.style.setProperty('--sent-text-color', savedText);
      }
    }
  });

  function loadConversations() {
    const q = query(
      collection(db, "conversations"), 
      where("participants", "array-contains", currentUser.uid)
    );
    
    unsubscribeConversations = onSnapshot(q, async (snapshot) => {
      const list = document.getElementById('conversationsList');
      list.innerHTML = '';
      
      const convs = [];
      
      for (const doc of snapshot.docs) {
        const conv = { id: doc.id, ...doc.data() };
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        
        if (otherId) {
          const realName = await getUserDisplayName(otherId);
          conv.realName = realName;
          convs.push(conv);
        }
      }
      
      convs.sort((a, b) => (b.updatedAt?.seconds || 0) - (a.updatedAt?.seconds || 0));
      
      convs.forEach(conv => {
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        const name = conv.realName || 'User';
        const avatar = conv.participantAvatars?.[otherId] || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=0080FF&color=fff`;
        
        const div = document.createElement('div');
        div.className = `conversation-item ${currentChatId === conv.id ? 'active' : ''}`;
        div.setAttribute('data-chat-id', conv.id);
        div.innerHTML = `
          <img src="${avatar}" class="conversation-avatar" alt="${name}">
          <div class="conversation-info">
            <div class="conversation-name">${name}</div>
            <div class="conversation-preview">${conv.lastMessage || 'No messages yet'}</div>
          </div>
        `;
        
        div.onclick = () => openChat(conv.id, otherId, name, avatar);
        list.appendChild(div);
      });
      
    }, (error) => {
      console.error("Error loading conversations:", error);
    });
  }

  async function openChat(chatId, otherUserId, name, avatar) {
    try {
      if (unsubscribeMessages) unsubscribeMessages();
      
      currentChatId = chatId;
      currentChatUser = otherUserId;
      currentChatUserName = name;
      currentChatUserAvatar = avatar;
      
      document.getElementById('emptyChat').style.display = 'none';
      document.getElementById('chatHeader').style.display = 'flex';
      document.getElementById('messagesContainer').style.display = 'flex';
      document.getElementById('messageInputContainer').style.display = 'block';
      document.getElementById('chatUserName').innerText = name;
      document.getElementById('currentChatAvatar').src = avatar;
      
      document.querySelectorAll('.conversation-item').forEach(el => el.classList.remove('active'));
      document.querySelector(`[data-chat-id="${chatId}"]`).classList.add('active');

      if (window.innerWidth <= 768) {
        document.getElementById('chatArea').classList.add('active');
      }
      
      await loadMessages(chatId);
      
    } catch (error) {
      console.error("Error opening chat:", error);
    }
  }

  function loadMessages(chatId) {
    if (unsubscribeMessages) unsubscribeMessages();
    messagesContainer.innerHTML = '';
    
    const q = query(
      collection(db, "conversations", chatId, "messages"),
      orderBy("timestamp", "asc")
    );
    
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const msg = change.doc.data();
        const isMe = msg.senderId === currentUser.uid;

        if (change.type === "added") {
          const div = renderMessageHTML(msg, isMe, change.doc.id);
          messagesContainer.appendChild(div);
        }
      });
      
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 100);
      
    }, (error) => {
      console.error("Error loading messages:", error);
    });
  }

  document.getElementById('sendButton').addEventListener('click', sendMessage);

  async function sendMessage() {
    const text = messageInput.value.trim();
    if (!text || !currentChatId) return;
    
    const originalText = text;
    messageInput.value = '';
    messageInput.style.height = '50px';

    const msgPayload = {
      text: originalText,
      senderId: currentUser.uid,
      timestamp: serverTimestamp(),
      replyTo: replyToMsg ? {
        id: replyToMsg.id,
        user: replyToMsg.user,
        text: replyToMsg.text
      } : null
    };

    cancelReply();
    
    try {
      await addDoc(collection(db, "conversations", currentChatId, "messages"), msgPayload);
      
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: originalText.length > 50 ? originalText.substring(0, 50) + '...' : originalText,
        updatedAt: serverTimestamp()
      });
      
    } catch (error) {
      console.error("Send error:", error);
      messageInput.value = originalText;
    }
  }

  messageInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  messageInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
  });

  document.getElementById('backButton').addEventListener('click', () => {
    document.getElementById('chatArea').classList.remove('active');
  });

  document.getElementById('userSearchInput').addEventListener('input', async (e) => {
    const term = e.target.value.toLowerCase().trim();
    const resDiv = document.getElementById('userSearchResults');
    resDiv.innerHTML = '';
    
    if (term.length < 2) {
      resDiv.innerHTML = '<div style="padding:30px; text-align:center; color:var(--secondary-text);">Type at least 2 characters</div>';
      return;
    }
    
    try {
      const usersQuery = query(
        collection(db, "users"),
        limit(15)
      );
      
      const snap = await getDocs(usersQuery);
      
      snap.forEach(doc => {
        if (doc.id === currentUser.uid) return;
        
        const userData = doc.data();
        const userName = userData.name || userData.displayName || 'User';
        const userEmail = userData.email || '';
        
        if (userName.toLowerCase().includes(term) || userEmail.toLowerCase().includes(term)) {
          const div = document.createElement('div');
          div.className = 'search-result-item';
          div.innerHTML = `
            <img src="${userData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(userName)}&background=0080FF&color=fff`}" 
                 class="conversation-avatar" alt="${userName}">
            <div class="search-result-info">
              <div class="search-result-name">${userName}</div>
              <div class="search-result-email">${userEmail}</div>
            </div>
          `;
          div.onclick = () => startNewChat(doc.id, userData);
          resDiv.appendChild(div);
        }
      });
      
    } catch (error) {
      console.error("Search error:", error);
    }
  });

  async function startNewChat(otherId, otherData) {
    const participants = [currentUser.uid, otherId].sort();
    const chatId = participants.join('_');
    
    try {
      const existingConv = await getDoc(doc(db, "conversations", chatId));
      
      if (existingConv.exists()) {
        const convData = existingConv.data();
        const otherUserId = convData.participants.find(p => p !== currentUser.uid);
        const realName = await getUserDisplayName(otherUserId);
        const avatar = convData.participantAvatars?.[otherUserId] || otherData.photoURL;
        
        openChat(chatId, otherId, realName, avatar);
      } else {
        const currentUserName = await getUserDisplayName(currentUser.uid);
        const otherUserName = await getUserDisplayName(otherId);
        
        await setDoc(doc(db, "conversations", chatId), {
          participants,
          participantNames: {
            [currentUser.uid]: currentUserName,
            [otherId]: otherUserName
          },
          participantAvatars: {
            [currentUser.uid]: navUserImg.src,
            [otherId]: otherData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUserName)}&background=0080FF&color=fff`
          },
          updatedAt: serverTimestamp(),
          lastMessage: '',
          createdAt: serverTimestamp()
        });
        
        openChat(chatId, otherId, otherUserName, otherData.photoURL);
      }
      
      closeUserSearchOverlay();
      
    } catch (error) {
      console.error("Error starting new chat:", error);
    }
  }

  window.uploadToCloudinary = async (file, type) => {
    if (!file || !currentChatId) return;
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', 'Meet_video');
    formData.append('resource_type', type === 'video' ? 'video' : 'image');

    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      const data = await response.json();
      
      if (data.secure_url) {
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: type,
          text: "",
          senderId: currentUser.uid,
          timestamp: serverTimestamp()
        });
        
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: type === 'image' ? 'Photo' : 'Video',
          updatedAt: serverTimestamp()
        });
      }
    } catch (error) {
      console.error('Upload error:', error);
    }
  };

  window.startVoiceCall = () => {
    alert("Voice call feature coming soon!");
  };

  window.startVideoCall = () => {
    alert("Video call feature coming soon!");
  };

  document.addEventListener('click', (e) => {
    if (!emojiPicker.contains(e.target) && !e.target.closest('.input-action')) {
      emojiPicker.style.display = 'none';
    }
  });

  document.addEventListener('click', (e) => {
    if (!e.target.closest('.conversation-item') && !e.target.closest('#conversationOptionsMenu')) {
      document.getElementById('conversationOptionsMenu').style.display = 'none';
    }
  });

</script>
</body>
</html>padding:30px; text-align:center; color:var(--secondary-text);">Type at least 2 characters</div>';
      return;
    }
    
    try {
      const usersQuery = query(
        collection(db, "users"),
        limit(15)
      );
      
      const snap = await getDocs(usersQuery);
      
      snap.forEach(doc => {
        if (doc.id === currentUser.uid) return;
        
        const userData = doc.data();
        const userName = userData.name || userData.displayName || 'User';
        const userEmail = userData.email || '';
        
        if (userName.toLowerCase().includes(term) || userEmail.toLowerCase().includes(term)) {
          const div = document.createElement('div');
          div.className = 'search-result-item';
          div.innerHTML = `
            <img src="${userData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(userName)}&background=0080FF&color=fff`}" 
                 class="conversation-avatar" alt="${userName}">
            <div class="search-result-info">
              <div class="search-result-name">${userName}</div>
              <div class="search-result-email">${userEmail}</div>
            </div>
          `;
          div.onclick = () => startNewChat(doc.id, userData);
          resDiv.appendChild(div);
        }
      });
      
    } catch (error) {
      console.error("Search error:", error);
    }
  });

  async function startNewChat(otherId, otherData) {
    const participants = [currentUser.uid, otherId].sort();
    const chatId = participants.join('_');
    
    try {
      const existingConv = await getDoc(doc(db, "conversations", chatId));
      
      if (existingConv.exists()) {
        const convData = existingConv.data();
        const otherUserId = convData.participants.find(p => p !== currentUser.uid);
        const realName = await getUserDisplayName(otherUserId);
        const avatar = convData.participantAvatars?.[otherUserId] || otherData.photoURL;
        
        openChat(chatId, otherId, realName, avatar);
      } else {
        const currentUserName = await getUserDisplayName(currentUser.uid);
        const otherUserName = await getUserDisplayName(otherId);
        
        await setDoc(doc(db, "conversations", chatId), {
          participants,
          participantNames: {
            [currentUser.uid]: currentUserName,
            [otherId]: otherUserName
          },
          participantAvatars: {
            [currentUser.uid]: navUserImg.src,
            [otherId]: otherData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUserName)}&background=0080FF&color=fff`
          },
          updatedAt: serverTimestamp(),
          lastMessage: '',
          createdAt: serverTimestamp()
        });
        
        openChat(chatId, otherId, otherUserName, otherData.photoURL);
      }
      
      closeUserSearchOverlay();
      
    } catch (error) {
      console.error("Error starting new chat:", error);
    }
  }

  window.uploadToCloudinary = async (file, type) => {
    if (!file || !currentChatId) return;
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', 'Meet_video');
    formData.append('resource_type', type === 'video' ? 'video' : 'image');

    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      const data = await response.json();
      
      if (data.secure_url) {
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: type,
          text: "",
          senderId: currentUser.uid,
          timestamp: serverTimestamp()
        });
        
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: type === 'image' ? 'Photo' : 'Video',
          updatedAt: serverTimestamp()
        });
      }
    } catch (error) {
      console.error('Upload error:', error);
    }
  };

  window.startVoiceCall = () => {
    alert("Voice call feature coming soon!");
  };

  window.startVideoCall = () => {
    alert("Video call feature coming soon!");
  };

  document.addEventListener('click', (e) => {
    if (!emojiPicker.contains(e.target) && !e.target.closest('.input-action')) {
      emojiPicker.style.display = 'none';
    }
  });

</script>
</body>
</html>
