<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Professional Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  /* All existing CSS remains the same, adding new styles for WebRTC */
  :root {
    /* Existing variables... */
    --call-bg: #0f172a;
    --ring-color: #3b82f6;
    --ring-animation: ring 2s infinite;
  }

  /* Call Container Styles */
  .call-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--call-bg);
    z-index: 9999;
    display: none;
    flex-direction: column;
  }

  .call-container.active {
    display: flex;
    animation: fadeIn 0.3s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  /* Call Header */
  .call-header {
    padding: 20px;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: white;
    backdrop-filter: blur(10px);
  }

  .call-info {
    text-align: center;
    flex: 1;
  }

  .call-user-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 5px;
  }

  .call-status {
    font-size: 14px;
    opacity: 0.8;
  }

  /* Video Grid */
  .video-grid {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    padding: 20px;
    position: relative;
  }

  @media (min-width: 768px) {
    .video-grid {
      grid-template-columns: 1fr 1fr;
    }
  }

  .video-container {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    background: #1e293b;
  }

  .video-container.local-video {
    border: 3px solid var(--primary);
    order: 2;
  }

  @media (min-width: 768px) {
    .video-container.local-video {
      order: 1;
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 25%;
      height: auto;
      max-width: 300px;
    }
  }

  .video-container.remote-video {
    order: 1;
  }

  video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #000;
  }

  .video-overlay {
    position: absolute;
    bottom: 10px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px;
  }

  .video-label {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 5px;
  }

  /* Call Controls */
  .call-controls {
    padding: 30px 20px;
    display: flex;
    justify-content: center;
    gap: 20px;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(10px);
  }

  .control-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 20px;
  }

  @media (max-width: 480px) {
    .control-btn {
      width: 50px;
      height: 50px;
    }
  }

  .control-btn.call-end {
    background: #ef4444;
    color: white;
    transform: scale(1.1);
  }

  .control-btn.call-end:hover {
    background: #dc2626;
    transform: scale(1.15);
  }

  .control-btn.mute-audio {
    background: rgba(255, 255, 255, 0.1);
    color: white;
  }

  .control-btn.mute-audio.active {
    background: #ef4444;
  }

  .control-btn.mute-audio:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .control-btn.mute-video {
    background: rgba(255, 255, 255, 0.1);
    color: white;
  }

  .control-btn.mute-video.active {
    background: #ef4444;
  }

  .control-btn.mute-video:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .control-btn.speaker {
    background: rgba(255, 255, 255, 0.1);
    color: white;
  }

  .control-btn.speaker.active {
    background: var(--primary);
  }

  .control-btn.speaker:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Call Chat */
  .call-chat-container {
    position: absolute;
    top: 80px;
    right: 20px;
    width: 300px;
    height: 400px;
    background: rgba(30, 41, 59, 0.95);
    border-radius: 16px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    display: none;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
  }

  .call-chat-container.active {
    display: flex;
  }

  .call-chat-header {
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: white;
  }

  .call-chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .call-message {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px 15px;
    border-radius: 18px;
    color: white;
    max-width: 80%;
    font-size: 14px;
  }

  .call-message.sent {
    background: var(--primary);
    align-self: flex-end;
    border-bottom-right-radius: 5px;
  }

  .call-message.received {
    background: rgba(255, 255, 255, 0.15);
    align-self: flex-start;
    border-bottom-left-radius: 5px;
  }

  .call-chat-input {
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    display: flex;
    gap: 10px;
  }

  .call-chat-input input {
    flex: 1;
    padding: 10px 15px;
    border-radius: 25px;
    border: none;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    outline: none;
  }

  .call-chat-input button {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: var(--primary);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Incoming Call Modal */
  .incoming-call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
  }

  .incoming-call-modal.active {
    display: flex;
    animation: fadeIn 0.3s ease;
  }

  .incoming-call-card {
    background: var(--card-bg);
    border-radius: 24px;
    padding: 40px;
    text-align: center;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  }

  .incoming-call-avatar {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    border: 4px solid var(--primary);
    margin-bottom: 20px;
  }

  .incoming-call-info h3 {
    font-size: 28px;
    margin-bottom: 5px;
    color: var(--text-color);
  }

  .incoming-call-info p {
    color: var(--secondary-text);
    font-size: 16px;
    margin-bottom: 30px;
  }

  .incoming-call-buttons {
    display: flex;
    gap: 20px;
    justify-content: center;
  }

  .incoming-call-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 24px;
    transition: all 0.3s ease;
  }

  .incoming-call-btn.accept {
    background: #10b981;
    color: white;
    animation: var(--ring-animation);
  }

  .incoming-call-btn.reject {
    background: #ef4444;
    color: white;
  }

  @keyframes ring {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  /* Voice Message Recording */
  .voice-message-container {
    position: relative;
  }

  .record-btn {
    background: none;
    border: none;
    color: var(--secondary-text);
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 10px;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .record-btn:hover {
    color: var(--primary);
    background: rgba(0,128,255,0.1);
    transform: scale(1.1);
  }

  .record-btn.recording {
    color: #ef4444;
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  .recording-indicator {
    display: none;
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(239, 68, 68, 0.9);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 12px;
    white-space: nowrap;
    margin-bottom: 10px;
  }

  .recording-indicator.active {
    display: block;
    animation: slideUp 0.3s ease;
  }

  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translate(-50%, 10px);
    }
    to {
      opacity: 1;
      transform: translate(-50%, 0);
    }
  }

  .voice-message-bubble {
    position: relative;
    padding: 15px;
    background: var(--primary);
    color: white;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    max-width: 250px;
  }

  .voice-message-bubble:hover {
    opacity: 0.9;
  }

  .voice-play-btn {
    background: rgba(255, 255, 255, 0.2);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }

  .voice-duration {
    font-size: 12px;
    opacity: 0.8;
  }

  .voice-waveform {
    flex: 1;
    height: 30px;
    display: flex;
    align-items: center;
    gap: 2px;
  }

  .voice-wave {
    width: 3px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 2px;
    animation: wavePulse 1s ease-in-out infinite;
  }

  @keyframes wavePulse {
    0%, 100% { height: 10px; }
    50% { height: 20px; }
  }

  /* Loading Animation for Call */
  .call-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;
  }

  .call-loading-spinner {
    width: 60px;
    height: 60px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
  }

  /* Responsive Adjustments */
  @media (max-width: 768px) {
    .call-chat-container {
      position: fixed;
      top: auto;
      bottom: 100px;
      right: 10px;
      left: 10px;
      width: auto;
      height: 300px;
    }

    .incoming-call-card {
      padding: 30px 20px;
    }

    .incoming-call-avatar {
      width: 80px;
      height: 80px;
    }

    .incoming-call-info h3 {
      font-size: 22px;
    }

    .video-container.local-video {
      position: fixed;
      bottom: 120px;
      right: 10px;
      width: 120px;
      height: 160px;
      z-index: 10;
    }
  }
</style>
</head>
<body>
<!-- Existing HTML structure remains the same until the end -->
<!-- Add these new components after the existing HTML but before the script -->

<!-- Call Container -->
<div class="call-container" id="callContainer">
  <div class="call-header">
    <button class="btn" onclick="toggleCallChat()" style="background:rgba(255,255,255,0.1);color:white;">
      <i class="fas fa-comment"></i>
    </button>
    <div class="call-info">
      <div class="call-user-name" id="callUserName">User</div>
      <div class="call-status" id="callStatus">Connecting...</div>
    </div>
    <button class="btn" onclick="toggleFullscreen()" style="background:rgba(255,255,255,0.1);color:white;">
      <i class="fas fa-expand"></i>
    </button>
  </div>

  <div class="video-grid">
    <div class="video-container remote-video" id="remoteVideoContainer">
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="video-label">
        <i class="fas fa-user"></i>
        <span id="remoteUserName">Remote User</span>
      </div>
      <div class="video-overlay">
        <!-- Remote user controls will appear here -->
      </div>
    </div>

    <div class="video-container local-video" id="localVideoContainer">
      <video id="localVideo" autoplay muted playsinline></video>
      <div class="video-label">
        <i class="fas fa-user"></i>
        <span>You</span>
      </div>
      <div class="video-overlay">
        <div class="mic-status" id="localMicStatus">
          <i class="fas fa-microphone"></i>
        </div>
        <div class="cam-status" id="localCamStatus">
          <i class="fas fa-video"></i>
        </div>
      </div>
    </div>

    <div class="call-loading" id="callLoading" style="display: none;">
      <div class="call-loading-spinner"></div>
      <div>Connecting to call...</div>
    </div>
  </div>

  <!-- Call Chat Sidebar -->
  <div class="call-chat-container" id="callChatContainer">
    <div class="call-chat-header">
      <span>Call Chat</span>
      <button onclick="toggleCallChat()" style="background:none;border:none;color:white;font-size:20px;cursor:pointer;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="call-chat-messages" id="callChatMessages">
      <!-- Call chat messages will appear here -->
    </div>
    <div class="call-chat-input">
      <input type="text" id="callChatInput" placeholder="Type a message...">
      <button onclick="sendCallMessage()">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>

  <div class="call-controls">
    <button class="control-btn mute-audio" id="muteAudioBtn" onclick="toggleAudio()">
      <i class="fas fa-microphone"></i>
    </button>
    <button class="control-btn mute-video" id="muteVideoBtn" onclick="toggleVideo()">
      <i class="fas fa-video"></i>
    </button>
    <button class="control-btn call-end" onclick="endCall()">
      <i class="fas fa-phone-slash"></i>
    </button>
    <button class="control-btn speaker" id="speakerBtn" onclick="toggleSpeaker()">
      <i class="fas fa-volume-up"></i>
    </button>
  </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incomingCallModal">
  <div class="incoming-call-card">
    <img src="" class="incoming-call-avatar" id="incomingCallAvatar" alt="Caller">
    <div class="incoming-call-info">
      <h3 id="incomingCallName">User</h3>
      <p id="incomingCallType">Incoming Video Call</p>
      <div class="incoming-call-buttons">
        <button class="incoming-call-btn accept" onclick="acceptIncomingCall()">
          <i class="fas fa-phone"></i>
        </button>
        <button class="incoming-call-btn reject" onclick="rejectIncomingCall()">
          <i class="fas fa-phone-slash"></i>
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Voice Message Recording Indicator -->
<div class="recording-indicator" id="recordingIndicator">
  <i class="fas fa-circle" style="color:#ef4444; margin-right:5px;"></i>
  Recording... Release to send
</div>

<!-- Rest of your existing HTML continues... -->
<!-- (Keep all your existing HTML structure here) -->

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { 
    getFirestore, 
    collection, 
    addDoc, 
    updateDoc, 
    doc, 
    getDoc, 
    getDocs, 
    onSnapshot, 
    serverTimestamp, 
    query, 
    orderBy, 
    where, 
    setDoc, 
    limit, 
    deleteDoc 
  } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
  import { 
    getAuth, 
    onAuthStateChanged, 
    signOut 
  } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDtqM_pMGIYkUgy0OWGsQbfS9MtYQhrgZM",
    authDomain: "meet-6e159.firebaseapp.com",
    projectId: "meet-6e159",
    storageBucket: "meet-6e159.firebasestorage.app",
    messagingSenderId: "252353608421",
    appId: "1:252353608421:web:6706056048e9a8f12db20c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // WebRTC Configuration
  const rtcConfig = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' }
    ]
  };

  // Global state variables
  let currentUser = null;
  let currentChatId = null;
  let currentChatUser = null;
  let currentChatUserName = '';
  let currentChatUserAvatar = '';
  let unsubscribeMessages = null;
  let unsubscribeConversations = null;
  
  // WebRTC state
  let peerConnection = null;
  let localStream = null;
  let remoteStream = null;
  let dataChannel = null;
  let callType = null;
  let isCaller = false;
  let callRoomId = null;
  let isMuted = false;
  let isVideoOff = false;
  let isSpeakerOn = true;
  
  // Voice message state
  let mediaRecorder = null;
  let audioChunks = [];
  let isRecording = false;
  
  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer');
  const messageInput = document.getElementById('messageInput');
  const emojiPicker = document.getElementById('emojiPicker');
  const sidebar = document.getElementById('mainSidebar');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const navUserImg = document.getElementById('navUserImg');
  const navUserName = document.getElementById('navUserName');

  // Call DOM elements
  const callContainer = document.getElementById('callContainer');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const callUserName = document.getElementById('callUserName');
  const callStatus = document.getElementById('callStatus');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const incomingCallName = document.getElementById('incomingCallName');
  const incomingCallAvatar = document.getElementById('incomingCallAvatar');
  const incomingCallType = document.getElementById('incomingCallType');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const muteAudioBtn = document.getElementById('muteAudioBtn');
  const muteVideoBtn = document.getElementById('muteVideoBtn');
  const speakerBtn = document.getElementById('speakerBtn');
  const callChatContainer = document.getElementById('callChatContainer');
  const callChatMessages = document.getElementById('callChatMessages');
  const callChatInput = document.getElementById('callChatInput');

  // ====================
  // WEBRTC FUNCTIONS
  // ====================

  // Initialize WebRTC call
  async function initWebRTC(type) {
    if (!currentChatId) {
      alert('Please select a chat first');
      return;
    }

    callType = type;
    isCaller = true;
    callRoomId = `${currentChatId}_${Date.now()}`;
    
    // Update UI
    callUserName.textContent = currentChatUserName;
    callStatus.textContent = 'Calling...';
    document.getElementById('remoteUserName').textContent = currentChatUserName;
    callContainer.classList.add('active');
    document.getElementById('callLoading').style.display = 'block';

    try {
      // Get local media stream
      localStream = await navigator.mediaDevices.getUserMedia({
        video: type === 'video',
        audio: true
      });

      // Display local video
      if (type === 'video') {
        localVideo.srcObject = localStream;
      } else {
        // For voice calls, hide video elements
        document.getElementById('localVideoContainer').style.display = 'none';
        document.getElementById('remoteVideoContainer').style.display = 'none';
        // Show voice call UI
        document.getElementById('callLoading').innerHTML = `
          <div style="text-align:center;color:white;">
            <i class="fas fa-phone-alt" style="font-size:60px;margin-bottom:20px;color:var(--primary);"></i>
            <div style="font-size:24px;margin-bottom:10px;">Voice Call</div>
            <div>Calling ${currentChatUserName}...</div>
          </div>
        `;
      }

      // Create peer connection
      peerConnection = new RTCPeerConnection(rtcConfig);

      // Add local tracks to peer connection
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Handle remote stream
      peerConnection.ontrack = (event) => {
        remoteStream = event.streams[0];
        remoteVideo.srcObject = remoteStream;
        document.getElementById('callLoading').style.display = 'none';
        callStatus.textContent = 'Connected';
        
        // Enable speaker by default
        if (isSpeakerOn) {
          remoteVideo.volume = 1.0;
        }
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          // Send ICE candidate to remote peer via Firestore
          sendSignal({
            type: 'ice-candidate',
            candidate: event.candidate,
            roomId: callRoomId,
            senderId: currentUser.uid,
            receiverId: currentChatUser
          });
        }
      };

      // Handle connection state
      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          callStatus.textContent = 'Connected';
          document.getElementById('callLoading').style.display = 'none';
        } else if (peerConnection.connectionState === 'disconnected' || 
                   peerConnection.connectionState === 'failed' || 
                   peerConnection.connectionState === 'closed') {
          endCall();
        }
      };

      // Create data channel for chat during call
      dataChannel = peerConnection.createDataChannel('chat');
      setupDataChannel(dataChannel);

      // Create offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      // Send offer to remote peer via Firestore
      await sendSignal({
        type: 'offer',
        offer: offer,
        roomId: callRoomId,
        senderId: currentUser.uid,
        receiverId: currentChatUser,
        callType: type
      });

      // Listen for answers and ICE candidates
      listenForSignals();

    } catch (error) {
      console.error('Error initializing WebRTC:', error);
      alert('Failed to start call. Please check your camera and microphone permissions.');
      endCall();
    }
  }

  // Listen for incoming signals
  function listenForSignals() {
    const signalsQuery = query(
      collection(db, "signals"),
      where("receiverId", "==", currentUser.uid),
      orderBy("timestamp", "desc"),
      limit(1)
    );

    onSnapshot(signalsQuery, async (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added") {
          const signal = change.doc.data();
          
          if (signal.roomId !== callRoomId && !isCaller) {
            // This is for incoming calls
            handleIncomingCall(signal);
            return;
          }

          if (signal.type === 'answer' && isCaller) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.answer));
          } else if (signal.type === 'offer' && !isCaller) {
            await handleIncomingOffer(signal);
          } else if (signal.type === 'ice-candidate') {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
            } catch (error) {
              console.error('Error adding ICE candidate:', error);
            }
          }
        }
      });
    });
  }

  // Handle incoming call offer
  async function handleIncomingOffer(signal) {
    if (!peerConnection) {
      // Create peer connection for incoming call
      peerConnection = new RTCPeerConnection(rtcConfig);
      
      // Set up data channel listener
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel(dataChannel);
      };

      // Handle remote stream
      peerConnection.ontrack = (event) => {
        remoteStream = event.streams[0];
        remoteVideo.srcObject = remoteStream;
        document.getElementById('callLoading').style.display = 'none';
        callStatus.textContent = 'Connected';
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          sendSignal({
            type: 'ice-candidate',
            candidate: event.candidate,
            roomId: signal.roomId,
            senderId: currentUser.uid,
            receiverId: signal.senderId
          });
        }
      };
    }

    // Set remote description
    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.offer));

    // Get local media stream
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: signal.callType === 'video',
        audio: true
      });

      // Add local tracks
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Display local video if video call
      if (signal.callType === 'video') {
        localVideo.srcObject = localStream;
      } else {
        document.getElementById('localVideoContainer').style.display = 'none';
        document.getElementById('remoteVideoContainer').style.display = 'none';
      }

      // Create answer
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      // Send answer back
      await sendSignal({
        type: 'answer',
        answer: answer,
        roomId: signal.roomId,
        senderId: currentUser.uid,
        receiverId: signal.senderId
      });

      // Update UI
      callRoomId = signal.roomId;
      callType = signal.callType;
      callUserName.textContent = currentChatUserName || 'Incoming Call';
      callStatus.textContent = 'Connected';
      callContainer.classList.add('active');
      incomingCallModal.classList.remove('active');

    } catch (error) {
      console.error('Error handling incoming offer:', error);
      endCall();
    }
  }

  // Handle incoming call notification
  function handleIncomingCall(signal) {
    // Show incoming call modal
    incomingCallModal.classList.add('active');
    incomingCallName.textContent = currentChatUserName || 'User';
    incomingCallType.textContent = signal.callType === 'video' ? 'Incoming Video Call' : 'Incoming Voice Call';
    
    // Store signal data for later use
    window.incomingCallSignal = signal;
  }

  // Accept incoming call
  async function acceptIncomingCall() {
    if (!window.incomingCallSignal) return;
    
    const signal = window.incomingCallSignal;
    callRoomId = signal.roomId;
    callType = signal.callType;
    isCaller = false;
    
    // Update UI
    callUserName.textContent = currentChatUserName || 'Incoming Call';
    callStatus.textContent = 'Connecting...';
    document.getElementById('remoteUserName').textContent = currentChatUserName || 'User';
    incomingCallModal.classList.remove('active');
    callContainer.classList.add('active');
    document.getElementById('callLoading').style.display = 'block';
    
    // Handle the offer
    await handleIncomingOffer(signal);
  }

  // Reject incoming call
  async function rejectIncomingCall() {
    if (!window.incomingCallSignal) return;
    
    // Send rejection signal
    await sendSignal({
      type: 'reject',
      roomId: window.incomingCallSignal.roomId,
      senderId: currentUser.uid,
      receiverId: window.incomingCallSignal.senderId
    });
    
    // Clean up
    incomingCallModal.classList.remove('active');
    delete window.incomingCallSignal;
    
    // Show notification
    showNotification('Call rejected', 'info');
  }

  // Send signal via Firestore
  async function sendSignal(signalData) {
    try {
      await addDoc(collection(db, "signals"), {
        ...signalData,
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Error sending signal:', error);
    }
  }

  // Set up data channel for chat during call
  function setupDataChannel(channel) {
    channel.onopen = () => {
      console.log('Data channel opened');
    };
    
    channel.onmessage = (event) => {
      const message = JSON.parse(event.data);
      displayCallChatMessage(message, false);
    };
    
    channel.onclose = () => {
      console.log('Data channel closed');
    };
  }

  // Send chat message during call
  function sendCallMessage() {
    const text = callChatInput.value.trim();
    if (!text || !dataChannel || dataChannel.readyState !== 'open') return;
    
    const message = {
      type: 'chat',
      text: text,
      senderId: currentUser.uid,
      senderName: navUserName.textContent,
      timestamp: new Date().toISOString()
    };
    
    dataChannel.send(JSON.stringify(message));
    displayCallChatMessage(message, true);
    callChatInput.value = '';
  }

  // Display chat message in call chat
  function displayCallChatMessage(message, isSent) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `call-message ${isSent ? 'sent' : 'received'}`;
    messageDiv.textContent = message.text;
    callChatMessages.appendChild(messageDiv);
    callChatMessages.scrollTop = callChatMessages.scrollHeight;
  }

  // Toggle call chat visibility
  function toggleCallChat() {
    callChatContainer.classList.toggle('active');
  }

  // Toggle audio mute
  function toggleAudio() {
    if (!localStream) return;
    
    isMuted = !isMuted;
    localStream.getAudioTracks().forEach(track => {
      track.enabled = !isMuted;
    });
    
    muteAudioBtn.classList.toggle('active', isMuted);
    muteAudioBtn.innerHTML = isMuted ? 
      '<i class="fas fa-microphone-slash"></i>' : 
      '<i class="fas fa-microphone"></i>';
  }

  // Toggle video
  function toggleVideo() {
    if (!localStream || callType !== 'video') return;
    
    isVideoOff = !isVideoOff;
    localStream.getVideoTracks().forEach(track => {
      track.enabled = !isVideoOff;
    });
    
    muteVideoBtn.classList.toggle('active', isVideoOff);
    muteVideoBtn.innerHTML = isVideoOff ? 
      '<i class="fas fa-video-slash"></i>' : 
      '<i class="fas fa-video"></i>';
  }

  // Toggle speaker
  function toggleSpeaker() {
    isSpeakerOn = !isSpeakerOn;
    if (remoteVideo) {
      remoteVideo.volume = isSpeakerOn ? 1.0 : 0.0;
    }
    
    speakerBtn.classList.toggle('active', isSpeakerOn);
    speakerBtn.innerHTML = isSpeakerOn ? 
      '<i class="fas fa-volume-up"></i>' : 
      '<i class="fas fa-volume-mute"></i>';
  }

  // End call
  async function endCall() {
    // Stop all media tracks
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    // Close peer connection
    if (peerConnection) {
      peerConnection.close();
    }
    
    // Close data channel
    if (dataChannel) {
      dataChannel.close();
    }
    
    // Reset states
    peerConnection = null;
    localStream = null;
    remoteStream = null;
    dataChannel = null;
    callType = null;
    isCaller = false;
    callRoomId = null;
    
    // Update UI
    callContainer.classList.remove('active');
    callChatContainer.classList.remove('active');
    
    // Reset video elements
    localVideo.srcObject = null;
    remoteVideo.srcObject = null;
    
    // Show call ended notification
    showNotification('Call ended', 'info');
  }

  // Toggle fullscreen
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      callContainer.requestFullscreen().catch(err => {
        console.error(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  }

  // ====================
  // VOICE MESSAGE FUNCTIONS
  // ====================

  // Start voice message recording
  async function startVoiceRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        audioChunks.push(event.data);
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await uploadVoiceMessage(audioBlob);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      isRecording = true;
      
      // Update UI
      recordingIndicator.classList.add('active');
      document.getElementById('recordButton').classList.add('recording');
      
    } catch (error) {
      console.error('Error starting recording:', error);
      alert('Failed to access microphone. Please check permissions.');
    }
  }

  // Stop voice message recording
  function stopVoiceRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      
      // Update UI
      recordingIndicator.classList.remove('active');
      document.getElementById('recordButton').classList.remove('recording');
    }
  }

  // Upload voice message to Cloudinary
  async function uploadVoiceMessage(audioBlob) {
    if (!currentChatId) return;
    
    const formData = new FormData();
    formData.append('file', audioBlob);
    formData.append('upload_preset', 'Meet_video');
    formData.append('resource_type', 'video');
    
    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) throw new Error('Upload failed');
      
      const data = await response.json();
      
      if (data.secure_url) {
        // Calculate duration (basic approximation)
        const duration = Math.round(audioBlob.size / 16000); // Rough estimation
        
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: 'audio',
          text: "Voice message",
          senderId: currentUser.uid,
          timestamp: serverTimestamp(),
          duration: duration
        });
        
        // Update conversation last message
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: 'Voice message',
          updatedAt: serverTimestamp()
        });
      }
    } catch (error) {
      console.error('Voice message upload error:', error);
      showError("Failed to send voice message. Please try again.");
    }
  }

  // Play voice message
  function playVoiceMessage(url) {
    const audio = new Audio(url);
    audio.play().catch(error => {
      console.error('Error playing voice message:', error);
      showError("Failed to play voice message");
    });
  }

  // ====================
  // UI ENHANCEMENTS
  // ====================

  // Add record button to message input
  function addVoiceMessageButton() {
    const messageInputActions = document.querySelector('.message-input-actions');
    if (!messageInputActions.querySelector('#recordButton')) {
      const recordButton = document.createElement('button');
      recordButton.id = 'recordButton';
      recordButton.className = 'input-action';
      recordButton.title = 'Voice Message';
      recordButton.innerHTML = '<i class="fas fa-microphone"></i>';
      
      // Add event listeners for recording
      let recordTimeout;
      
      recordButton.addEventListener('mousedown', () => {
        recordTimeout = setTimeout(() => {
          startVoiceRecording();
        }, 300); // Long press to start recording
      });
      
      recordButton.addEventListener('mouseup', () => {
        clearTimeout(recordTimeout);
        if (isRecording) {
          stopVoiceRecording();
        }
      });
      
      recordButton.addEventListener('mouseleave', () => {
        clearTimeout(recordTimeout);
      });
      
      // Touch events for mobile
      recordButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        recordTimeout = setTimeout(() => {
          startVoiceRecording();
        }, 300);
      });
      
      recordButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        clearTimeout(recordTimeout);
        if (isRecording) {
          stopVoiceRecording();
        }
      });
      
      // Add button to UI (before emoji button)
      const emojiButton = messageInputActions.querySelector('.input-action[onclick="toggleEmojiPicker()"]');
      if (emojiButton) {
        messageInputActions.insertBefore(recordButton, emojiButton);
      } else {
        messageInputActions.appendChild(recordButton);
      }
    }
  }

  // Render voice message bubble
  function renderVoiceMessageHTML(msg, isMe) {
    const duration = msg.duration || 0;
    const durationText = duration > 0 ? `${duration}s` : '';
    
    return `
      <div class="voice-message-bubble" onclick="playVoiceMessage('${msg.mediaUrl}')">
        <div class="voice-play-btn">
          <i class="fas fa-play"></i>
        </div>
        <div class="voice-waveform">
          ${Array.from({length: 20}).map((_, i) => 
            `<div class="voice-wave" style="animation-delay: ${i * 0.05}s"></div>`
          ).join('')}
        </div>
        <div class="voice-duration">${durationText}</div>
      </div>
    `;
  }

  // Show notification
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : '#3b82f6'};
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 99999;
      animation: slideIn 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  // Add slideOut animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  `;
  document.head.appendChild(style);

  // ====================
  // INTEGRATION WITH EXISTING CODE
  // ====================

  // Update message rendering to include voice messages
  function renderMessageHTML(msg, isMe, id) {
    // Existing code remains the same until media handling...
    
    // Add voice message handling
    if (msg.mediaType === 'audio') {
      content += renderVoiceMessageHTML(msg, isMe);
    }
    
    // Rest of existing renderMessageHTML function...
    // (Keep all your existing message rendering logic)
  }

  // Update the send button event listener to handle Enter key for call chat
  callChatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendCallMessage();
    }
  });

  // Clean up WebRTC on page unload
  window.addEventListener('beforeunload', () => {
    if (peerConnection) {
      endCall();
    }
    
    if (mediaRecorder && isRecording) {
      stopVoiceRecording();
    }
  });

  // Listen for escape key to end call
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && callContainer.classList.contains('active')) {
      endCall();
    }
  });

  // ====================
  // EXPORT FUNCTIONS TO WINDOW
  // ====================

  window.startVoiceCall = () => initWebRTC('voice');
  window.startVideoCall = () => initWebRTC('video');
  window.endCall = endCall;
  window.toggleAudio = toggleAudio;
  window.toggleVideo = toggleVideo;
  window.toggleSpeaker = toggleSpeaker;
  window.toggleCallChat = toggleCallChat;
  window.sendCallMessage = sendCallMessage;
  window.acceptIncomingCall = acceptIncomingCall;
  window.rejectIncomingCall = rejectIncomingCall;
  window.playVoiceMessage = playVoiceMessage;

  // ====================
  // INITIALIZATION
  // ====================

  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      // Existing auth setup code...
      
      // Add voice message button after UI is loaded
      setTimeout(() => {
        addVoiceMessageButton();
      }, 1000);
      
      // Start listening for incoming calls
      listenForSignals();
    }
  });

  // Your existing code continues here...
  // (Keep all your existing Firebase and chat functionality)

</script>
</body>
</html>
