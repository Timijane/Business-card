<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Professional Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --primary: #0080FF;
    --primary-dark: #0066CC;
    --bg-color: #f0f2f5;
    --card-bg: #fff;
    --text-color: #111;
    --secondary-text: #65676b;
    --border-color: #dddfe2;
    --error: #EF4444;
    --success: #10B981;
    --warning: #F59E0B;
    --app-height: 100dvh;
    --chat-font: 'Poppins', sans-serif;
    --sent-bubble-bg: #0080FF;
    --sent-text-color: #fff;
    --received-bubble-bg: #fff;
    --received-text-color: #111;
    --shadow-light: 0 2px 10px rgba(0,0,0,0.05);
    --shadow-medium: 0 4px 15px rgba(0,128,255,0.2);
    --shadow-heavy: 0 10px 40px rgba(0,0,0,0.2);
    --chat-container-width: 100%;
    --bubble-max-width: 80%; /* WhatsApp-like width */
    --typing-pulse: #0080FF;
  }

  @media (min-width: 768px) {
    :root {
      --chat-container-width: 95%;
      --bubble-max-width: 75%;
    }
  }

  @media (min-width: 1200px) {
    :root {
      --chat-container-width: 85%;
      --bubble-max-width: 65%;
    }
  }

  body.dark-mode {
    --bg-color: #0f0f10;
    --card-bg: #1e1e1e;
    --text-color: #e4e6eb;
    --secondary-text: #b0b3b8;
    --border-color: #2f3031;
    --received-bubble-bg: #2a2b2c;
    --received-text-color: #e4e6eb;
    --typing-pulse: #4FC3F7;
  }

  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
    -webkit-tap-highlight-color: transparent; 
  }

  html, body { 
    height: 100%; 
    overflow: hidden; 
    font-size: 14px; 
    font-family: var(--chat-font); 
    background: var(--bg-color); 
    color: var(--text-color); 
    transition: all 0.3s ease;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .app-container { 
    display: flex; 
    height: var(--app-height); 
    position: relative; 
    overflow: hidden; 
  }

  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 0;
    align-items: center;
    background: var(--bg-color);
  }

  /* Responsive navbar */
  .navbar {
    background: linear-gradient(135deg, #0080FF 0%, #00C6FF 100%);
    padding: 12px 16px;
    display: flex; 
    justify-content: space-between; 
    align-items: center;
    color: white; 
    flex-shrink: 0; 
    box-shadow: var(--shadow-medium);
    position: relative;
    overflow: hidden;
    width: 100%;
    min-height: 60px;
  }
  
  @media (min-width: 768px) {
    .navbar {
      padding: 12px 20px;
      border-radius: 16px;
      margin: 12px auto;
      width: var(--chat-container-width);
      max-width: 1200px;
    }
  }
  
  .navbar-left { display: flex; align-items: center; gap: 12px; }
  .navbar-right { display: flex; align-items: center; gap: 8px; }
  
  .hamburger-btn { 
    background: none; 
    border: none; 
    color: white; 
    font-size: 22px; 
    cursor: pointer; 
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
  }
  
  .nav-user-img { 
    width: 36px;
    height: 36px;
    border-radius: 50%; 
    border: 2px solid rgba(255,255,255,0.9);
    object-fit: cover;
  }
  
  .nav-user-name {
    font-weight: 600;
    font-size: 14px;
    margin-left: 8px;
    display: none;
  }
  
  @media (min-width: 768px) {
    .nav-user-name {
      display: block;
    }
  }
  
  .btn { 
    background: rgba(255, 255, 255, 0.2); 
    color: white; 
    border: none; 
    padding: 8px 12px;
    border-radius: 10px; 
    cursor: pointer; 
    font-size: 13px;
    font-weight: 500;
    display: flex; 
    align-items: center; 
    gap: 6px;
    transition: all 0.2s ease; 
  }

  /* Chat container responsive */
  .chat-container { 
    flex: 1; 
    background: var(--card-bg); 
    display: flex; 
    min-height: 0; 
    position: relative; 
    width: 100%;
    height: calc(100% - 60px);
  }
  
  @media (min-width: 768px) {
    .chat-container {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: var(--shadow-light);
      border: 1px solid var(--border-color);
      width: var(--chat-container-width);
      max-width: 1200px;
      margin: 0 auto 12px;
      height: calc(100% - 84px);
    }
  }
  
  .conversations-sidebar { 
    width: 100%; 
    border-right: 1px solid var(--border-color); 
    display: flex; 
    flex-direction: column; 
    height: 100%; 
    background: var(--card-bg); 
  }
  
  @media (min-width: 768px) {
    .conversations-sidebar {
      width: 340px;
      min-width: 340px;
    }
  }

  .chat-area { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    height: 100%; 
    background: var(--bg-color); 
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: translateX(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10;
  }
  
  .chat-area.active { 
    transform: translateX(0); 
  }
  
  @media (min-width: 768px) {
    .chat-area {
      position: relative;
      transform: none;
      width: auto;
    }
  }

  /* WhatsApp-style message bubbles */
  .messages-container { 
    flex: 1; 
    padding: 15px 8px;
    overflow-y: auto; 
    display: flex; 
    flex-direction: column; 
    gap: 6px;
    background-size: cover; 
    background-position: center; 
    transition: background 0.3s; 
    scroll-behavior: smooth;
    font-family: var(--chat-font);
    position: relative;
    -webkit-overflow-scrolling: touch;
  }
  
  @media (min-width: 768px) {
    .messages-container {
      padding: 15px;
    }
  }

  .message-wrapper { 
    display: flex; 
    gap: 8px;
    max-width: var(--bubble-max-width); 
    align-items: flex-start; 
    position: relative; 
    margin-bottom: 2px;
    animation: messageSlideIn 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
  }
  
  @keyframes messageSlideIn { 
    from { 
      opacity: 0; 
      transform: translateY(8px);
    } 
    to { 
      opacity: 1; 
      transform: translateY(0); 
    } 
  }
  
  .message-wrapper.sent { 
    align-self: flex-end; 
    flex-direction: row-reverse; 
    max-width: var(--bubble-max-width);
  }
  
  .message-wrapper.received {
    align-self: flex-start;
    max-width: var(--bubble-max-width);
  }
  
  .message-avatar-small { 
    width: 24px;
    height: 24px;
    border-radius: 50%; 
    object-fit: cover; 
    flex-shrink: 0; 
    align-self: flex-end;
    margin-bottom: 4px;
    display: none;
  }
  
  @media (min-width: 768px) {
    .message-avatar-small {
      display: block;
      width: 28px;
      height: 28px;
    }
  }

  /* WhatsApp-style bubble - compact and responsive */
  .message-bubble { 
    padding: 8px 12px;
    border-radius: 18px; 
    position: relative; 
    word-break: break-word;
    overflow-wrap: break-word;
    font-size: 14.2px;
    line-height: 1.4; 
    max-width: 100%; 
    box-shadow: 0 1px 0.5px rgba(0,0,0,0.13); 
    font-family: var(--chat-font);
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    min-width: auto;
    width: fit-content;
    max-width: 100%;
  }
  
  .received .message-bubble { 
    background: var(--received-bubble-bg); 
    border-top-left-radius: 4px;
    border-top-right-radius: 18px;
    border-bottom-right-radius: 18px;
    border-bottom-left-radius: 18px;
    color: var(--received-text-color);
    border: 1px solid var(--border-color);
    margin-left: 0;
  }
  
  .sent .message-bubble { 
    background: var(--sent-bubble-bg); 
    color: var(--sent-text-color); 
    border-top-left-radius: 18px;
    border-top-right-radius: 4px;
    border-bottom-left-radius: 18px;
    border-bottom-right-radius: 18px;
    box-shadow: 0 1px 0.5px rgba(0,128,255,0.15);
    margin-right: 0;
  }

  /* WhatsApp-style voice note player */
  .voice-note-player {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 12px;
    background: var(--received-bubble-bg);
    border-radius: 16px;
    min-width: 140px;
    max-width: 260px;
    border: 1px solid var(--border-color);
    position: relative;
    overflow: hidden;
    cursor: pointer;
    user-select: none;
  }

  .voice-note-player.sent {
    background: var(--sent-bubble-bg);
    border: none;
  }

  .voice-note-player.received {
    background: var(--received-bubble-bg);
  }

  .voice-note-play-btn {
    background: var(--primary);
    color: white;
    border: none;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
    position: relative;
    z-index: 2;
  }

  .voice-note-play-btn.playing {
    background: var(--primary-dark);
  }

  .voice-note-waveform {
    flex: 1;
    height: 30px;
    position: relative;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    overflow: hidden;
    display: flex;
    align-items: center;
    gap: 2px;
    padding: 0 10px;
  }

  .voice-note-bar {
    width: 3px;
    height: 60%;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 2px;
    animation: barWave 1.5s infinite ease-in-out;
  }

  @keyframes barWave {
    0%, 100% { height: 30%; }
    50% { height: 80%; }
  }

  .voice-note-progress {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: rgba(255, 255, 255, 0.2);
    width: 0%;
    transition: width 0.1s linear;
    pointer-events: none;
  }

  .voice-note-duration {
    font-size: 12px;
    font-weight: 600;
    color: var(--sent-text-color);
    min-width: 40px;
    text-align: right;
    flex-shrink: 0;
    font-family: monospace;
  }

  .voice-note-player.received .voice-note-duration {
    color: var(--received-text-color);
  }

  /* Enhanced voice recording UI */
  .voice-record-container {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(0,128,255,0.1);
    border-radius: 20px;
    margin-right: 10px;
    animation: recordingPulse 1.5s infinite;
    flex: 1;
  }

  @keyframes recordingPulse {
    0%, 100% { 
      box-shadow: 0 0 0 0 rgba(0,128,255,0.4); 
      background: rgba(0,128,255,0.1);
    }
    50% { 
      box-shadow: 0 0 0 8px rgba(0,128,255,0); 
      background: rgba(0,128,255,0.15);
    }
  }

  .voice-record-timer {
    font-size: 12px;
    font-weight: 600;
    color: var(--primary);
    min-width: 40px;
    text-align: center;
    font-family: monospace;
  }

  .voice-record-visualizer {
    flex: 1;
    height: 4px;
    background: rgba(0,128,255,0.2);
    border-radius: 2px;
    overflow: hidden;
    position: relative;
  }

  .voice-record-wave {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, 
      transparent 0%, 
      var(--primary) 20%, 
      var(--primary) 80%, 
      transparent 100%
    );
    animation: waveMove 0.8s infinite linear;
    background-size: 200% 100%;
  }

  @keyframes waveMove {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  /* Scroll management */
  .scroll-to-bottom-btn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    box-shadow: var(--shadow-medium);
    z-index: 100;
    transition: all 0.3s ease;
  }
  
  .scroll-to-bottom-btn.visible {
    display: flex;
  }

  /* Message input responsive */
  .message-input-container { 
    padding: 10px 12px;
    border-top: 1px solid var(--border-color); 
    background: var(--card-bg); 
    position: relative;
    flex-shrink: 0;
    z-index: 50;
    min-height: 64px;
  }
  
  @media (min-width: 768px) {
    .message-input-container {
      padding: 10px 15px;
    }
  }

  .message-input-wrapper { 
    display: flex; 
    align-items: center; 
    gap: 8px;
    width: 100%;
  }
  
  .message-input { 
    flex: 1; 
    padding: 10px 14px;
    border-radius: 25px; 
    border: 2px solid var(--border-color); 
    background: var(--bg-color); 
    color: var(--text-color); 
    resize: none; 
    font-family: var(--chat-font);
    font-size: 14px;
    max-height: 120px; 
    min-height: 40px;
    height: 40px; 
    outline: none; 
    overflow-y: auto; 
    line-height: 1.5; 
    transition: all 0.3s ease;
    box-sizing: border-box;
    -webkit-appearance: none;
  }

  /* Call interface responsive */
  .call-interface {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    z-index: 3000;
    display: none;
    flex-direction: column;
  }

  .call-video-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #000;
  }

  .remote-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #000;
  }

  .local-video {
    position: absolute;
    bottom: 100px;
    right: 20px;
    width: 120px;
    height: 160px;
    border-radius: 12px;
    border: 2px solid white;
    object-fit: cover;
    z-index: 20;
    background: #000;
  }

  .call-controls {
    padding: 20px;
    display: flex;
    justify-content: center;
    gap: 20px;
    background: rgba(0,0,0,0.8);
    flex-wrap: wrap;
  }

  .call-control-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
  }

  @media (min-width: 768px) {
    .call-control-btn {
      width: 70px;
      height: 70px;
      font-size: 24px;
    }
  }

  /* Incoming call modal responsive */
  .incoming-call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 3000;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .incoming-call-content {
    background: var(--card-bg);
    border-radius: 24px;
    padding: 30px;
    text-align: center;
    width: 100%;
    max-width: 400px;
    animation: modalSlideIn 0.4s ease;
  }

  .incoming-call-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto 20px;
    object-fit: cover;
  }

  @media (min-width: 768px) {
    .incoming-call-avatar {
      width: 100px;
      height: 100px;
    }
  }

  .incoming-call-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 10px;
  }

  .incoming-call-type {
    font-size: 14px;
    color: var(--secondary-text);
    margin-bottom: 30px;
  }

  .incoming-call-buttons {
    display: flex;
    gap: 20px;
    justify-content: center;
  }

  .call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  @media (min-width: 768px) {
    .call-action-btn {
      width: 70px;
      height: 70px;
      font-size: 24px;
    }
  }

  /* Audio call interface */
  .audio-call-interface .call-video-container {
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  }

  .audio-call-avatar {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 4px solid var(--primary);
    object-fit: cover;
  }

  @media (min-width: 768px) {
    .audio-call-avatar {
      width: 150px;
      height: 150px;
    }
  }

  /* Sidebar responsive */
  .sidebar {
    position: fixed; 
    top: 0; 
    left: 0; 
    height: 100%; 
    width: 280px;
    background: linear-gradient(180deg, #0080FF 0%, #00C6FF 100%);
    z-index: 200; 
    padding: 25px; 
    color: white;
    transform: translateX(-100%); 
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 4px 0 20px rgba(0,0,0,0.15);
  }
  
  .sidebar.open { transform: translateX(0); }

  /* Loading states */
  .loading-spinner {
    width: 20px;
    height: 20px;
    border: 2px solid var(--border-color);
    border-top: 2px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Error message */
  .error-message {
    background: rgba(239, 68, 68, 0.1);
    color: var(--error);
    padding: 10px 14px;
    border-radius: 8px;
    border-left: 4px solid var(--error);
    margin: 8px;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  /* Empty chat state */
  .empty-chat {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--secondary-text);
    text-align: center;
    padding: 40px;
  }

  /* Conversation list responsive */
  .conversation-item { 
    display: flex; 
    align-items: center; 
    gap: 12px;
    padding: 12px;
    cursor: pointer; 
    border-bottom: 1px solid var(--border-color); 
    transition: all 0.3s ease; 
    position: relative;
  }

  .conversation-avatar { 
    width: 45px;
    height: 45px;
    border-radius: 50%; 
    object-fit: cover; 
  }

  /* Typing indicator */
  .typing-indicator { 
    display: none; 
    padding: 10px 15px;
    background: var(--card-bg); 
    border-radius: 20px; 
    margin: 12px;
    width: fit-content; 
    align-self: flex-start; 
    font-size: 12px;
    color: var(--secondary-text); 
    font-style: italic; 
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 1px solid var(--border-color);
  }

  /* Dark mode adjustments */
  body.dark-mode .sidebar {
    background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
  }
  
  body.dark-mode .navbar {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  }
  
  body.dark-mode .message-bubble {
    box-shadow: 0 1px 0.5px rgba(0,0,0,0.3);
  }
  
  body.dark-mode .sent .message-bubble {
    box-shadow: 0 1px 0.5px rgba(0,128,255,0.4);
  }

  /* Hide sidebar on mobile when chat is open */
  @media (max-width: 767px) {
    .chat-area.active ~ .conversations-sidebar {
      display: none;
    }
    
    .chat-area:not(.active) {
      display: none;
    }
    
    .chat-area.active {
      display: flex;
    }
    
    .local-video {
      width: 80px;
      height: 120px;
      bottom: 80px;
      right: 15px;
    }
  }

  /* Extra small devices */
  @media (max-width: 480px) {
    .navbar {
      padding: 10px;
    }
    
    .hamburger-btn {
      font-size: 20px;
      padding: 6px;
    }
    
    .nav-user-img {
      width: 32px;
      height: 32px;
    }
    
    .btn {
      padding: 6px 8px;
      font-size: 12px;
    }
    
    .messages-container {
      padding: 12px 6px;
    }
    
    .message-bubble {
      padding: 6px 10px;
      font-size: 13.5px;
    }
    
    .voice-note-player {
      min-width: 120px;
      max-width: 200px;
      padding: 6px 10px;
    }
    
    .voice-note-play-btn {
      width: 28px;
      height: 28px;
    }
    
    .voice-note-waveform {
      height: 24px;
    }
    
    .call-controls {
      padding: 15px;
      gap: 15px;
    }
    
    .call-control-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
    
    .incoming-call-content {
      padding: 20px;
    }
    
    .incoming-call-avatar {
      width: 70px;
      height: 70px;
    }
    
    .incoming-call-name {
      font-size: 18px;
    }
    
    .call-action-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
  }

  /* Landscape orientation */
  @media (max-height: 600px) and (orientation: landscape) {
    .navbar {
      min-height: 50px;
      padding: 8px 12px;
    }
    
    .chat-container {
      height: calc(100% - 50px);
    }
    
    .messages-container {
      padding: 8px;
    }
    
    .message-input-container {
      min-height: 56px;
      padding: 8px;
    }
    
    .message-input {
      min-height: 36px;
      height: 36px;
      padding: 8px 12px;
    }
    
    .local-video {
      width: 70px;
      height: 100px;
      bottom: 70px;
      right: 10px;
    }
    
    .call-controls {
      padding: 15px;
    }
    
    .call-control-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
  }

  /* Tablet landscape */
  @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
    :root {
      --chat-container-width: 95%;
    }
    
    .conversations-sidebar {
      width: 300px;
      min-width: 300px;
    }
    
    .message-wrapper {
      max-width: 70%;
    }
  }

  /* High DPI screens */
  @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    .message-bubble {
      box-shadow: 0 0.5px 0.25px rgba(0,0,0,0.13);
    }
    
    .sent .message-bubble {
      box-shadow: 0 0.5px 0.25px rgba(0,128,255,0.15);
    }
  }

  /* Print styles */
  @media print {
    .navbar,
    .message-input-container,
    .sidebar,
    .call-interface,
    .incoming-call-modal {
      display: none !important;
    }
    
    .chat-container {
      box-shadow: none;
      border: none;
    }
    
    .messages-container {
      overflow: visible;
      height: auto;
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
    
    .message-wrapper {
      animation: none;
    }
  }

  /* Touch device optimizations */
  @media (hover: none) and (pointer: coarse) {
    .msg-options-btn {
      opacity: 0.7;
    }
    
    .message-wrapper:hover .msg-options-btn {
      opacity: 0.7;
    }
    
    .message-wrapper:active .msg-options-btn {
      opacity: 1;
    }
    
    button, .btn, .chat-action-btn {
      min-height: 44px;
      min-width: 44px;
    }
    
    .message-input {
      font-size: 16px; /* Prevents iOS zoom on focus */
    }
  }

  /* Windows high contrast mode */
  @media (forced-colors: active) {
    .message-bubble {
      border: 1px solid currentColor;
    }
    
    .sent .message-bubble {
      border: 1px solid currentColor;
    }
    
    .voice-note-player {
      border: 1px solid currentColor;
    }
  }

</style>
</head>
<body>
<div class="app-container">
  <div class="main-content">
    <div class="navbar">
      <div class="navbar-left">
        <button class="hamburger-btn" onclick="toggleSidebar()"><i class="fas fa-bars"></i></button>
        <h2 style="font-weight:600; font-size:18px;">Chat</h2>
      </div>
      <div class="navbar-right">
        <img src="https://via.placeholder.com/40" id="navUserImg" class="nav-user-img" alt="Me">
        <span id="navUserName" class="nav-user-name"></span>
        <button class="btn" id="nightToggleBtn"><i class="fas fa-moon"></i></button>
        <button class="btn" id="clearAllChatsBtn" title="Clear All Chats"><i class="fas fa-trash-alt"></i></button>
        <button class="btn" id="logoutBtn"><i class="fas fa-sign-out-alt"></i></button>
      </div>
    </div>

    <div class="chat-container">
      <div class="conversations-sidebar" id="conversationsSidebar">
        <div class="chat-header">
          <h3>Messages</h3>
          <button class="new-chat-btn" onclick="openUserSearchOverlay()"><i class="fas fa-plus"></i></button>
        </div>
        <div class="chat-search">
          <input type="text" placeholder="Search chats..." id="chatSearch">
        </div>
        <div class="conversations-list" id="conversationsList">
          <!-- Conversations will be loaded here -->
        </div>
      </div>

      <div class="chat-area" id="chatArea">
        <div id="emptyChat" class="empty-chat">
          <i class="far fa-comments"></i>
          <h3>Select a conversation</h3>
          <p>Choose a contact to start chatting</p>
        </div>

        <div class="chat-area-header" id="chatHeader" style="display: none;">
          <button class="chat-action-btn" id="backButton"><i class="fas fa-arrow-left"></i></button>
          <img src="" id="currentChatAvatar" class="conversation-avatar">
          <div class="chat-user-info">
            <div class="chat-user-name" id="chatUserName">User</div>
            <div class="chat-user-status">Last seen recently</div>
          </div>
          <div class="chat-actions">
            <button class="chat-action-btn" onclick="clearAllMessages()" title="Clear Chat"><i class="fas fa-trash-alt"></i></button>
            <button class="chat-action-btn" onclick="openSettingsModal()" title="Chat Settings"><i class="fas fa-sliders-h"></i></button>
            <button class="chat-action-btn" id="audioCallBtn" title="Voice Call"><i class="fas fa-phone-alt"></i></button>
            <button class="chat-action-btn" id="videoCallBtn" title="Video Call"><i class="fas fa-video"></i></button>
          </div>
        </div>

        <div class="messages-container" id="messagesContainer" style="display: none;">
          <div class="messages-scroll-anchor" id="scrollAnchor"></div>
        </div>

        <div class="typing-indicator" id="typingIndicator">
          <span id="typingUserName">User</span> is typing <span>.</span><span>.</span><span>.</span>
        </div>

        <div class="message-input-container" id="messageInputContainer" style="display: none;">
          <div class="message-input-wrapper">
            <div class="message-input-actions">
              <button class="input-action" onclick="toggleEmojiPicker()"><i class="far fa-smile"></i></button>
              <button class="input-action" id="voiceRecordBtn"><i class="fas fa-microphone"></i></button>
              <input type="file" id="fileInputHidden" accept="image/*,video/*,audio/*" style="display:none" onchange="handleFileUpload(this.files)">
              <button class="input-action" onclick="document.getElementById('fileInputHidden').click()"><i class="fas fa-paperclip"></i></button>
            </div>
            
            <div id="voiceRecordingUI" style="display: none;" class="voice-record-container">
              <div class="voice-record-timer" id="voiceRecordTimer">0:00</div>
              <div class="voice-record-visualizer">
                <div class="voice-record-wave"></div>
              </div>
              <button class="voice-record-cancel" id="voiceRecordCancelBtn"><i class="fas fa-times"></i></button>
            </div>
            
            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
            <button class="send-button" id="sendButton"><i class="fas fa-paper-plane"></i></button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Audio elements -->
<audio id="ringtone" loop style="display: none;">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-classic-alarm-995.mp3" type="audio/mpeg">
</audio>

<!-- Call Interface -->
<div class="call-interface" id="callInterface">
  <div class="call-header">
    <div class="call-user-info">
      <div class="call-user-name" id="callUserName">John Doe</div>
      <div class="call-status" id="callStatus">Connecting...</div>
    </div>
    <button class="chat-action-btn" onclick="endCall()"><i class="fas fa-times"></i></button>
  </div>
  <div class="call-video-container" id="callVideoContainer">
    <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
    <video id="localVideo" class="local-video" autoplay playsinline muted></video>
  </div>
  <div class="call-controls">
    <button class="call-control-btn mute" id="muteBtn" onclick="toggleMute()">
      <i class="fas fa-microphone"></i>
    </button>
    <button class="call-control-btn video-toggle" id="videoToggleBtn" onclick="toggleVideo()">
      <i class="fas fa-video"></i>
    </button>
    <button class="call-control-btn speaker" id="speakerBtn" onclick="toggleSpeaker()">
      <i class="fas fa-volume-up"></i>
    </button>
    <button class="call-control-btn end-call" onclick="endCall()">
      <i class="fas fa-phone"></i>
    </button>
  </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incomingCallModal">
  <div class="incoming-call-content">
    <img src="" id="incomingCallAvatar" class="incoming-call-avatar">
    <div class="incoming-call-name" id="incomingCallName">John Doe</div>
    <div class="incoming-call-type" id="incomingCallType">Incoming Voice Call</div>
    <div class="incoming-call-buttons">
      <button class="call-action-btn accept-call" onclick="acceptCall()">
        <i class="fas fa-phone"></i>
      </button>
      <button class="call-action-btn reject-call" onclick="rejectCall()">
        <i class="fas fa-phone-slash"></i>
      </button>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getFirestore, collection, addDoc, updateDoc, doc, getDoc, getDocs, onSnapshot, serverTimestamp, query, orderBy, where, setDoc, limit, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDtqM_pMGIYkUgy0OWGsQbfS9MtYQhrgZM",
    authDomain: "meet-6e159.firebaseapp.com",
    projectId: "meet-6e159",
    storageBucket: "meet-6e159.firebasestorage.app",
    messagingSenderId: "252353608421",
    appId: "1:252353608421:web:6706056048e9a8f12db20c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Global state
  let currentUser = null;
  let currentChatId = null;
  let currentChatUser = null;
  let currentChatUserName = '';
  let currentChatUserAvatar = '';
  let unsubscribeMessages = null;
  let unsubscribeConversations = null;
  
  // Voice recording
  let mediaRecorder = null;
  let audioChunks = [];
  let recordingTimer = null;
  let recordingStartTime = null;
  let isRecording = false;
  
  // Audio playback
  let currentlyPlayingAudio = null;
  let audioPlayingInterval = null;
  let audioPlaybackSpeed = 1.0;
  
  // Scroll management
  let isInitialLoad = true;
  let autoScrollEnabled = true;
  let userScrolled = false;
  
  // Call state
  let currentCallId = null;
  let localStream = null;
  let remoteStream = null;
  let peerConnection = null;
  let isMuted = false;
  let isVideoOn = true;
  let isSpeakerOn = true;
  let callType = 'audio';
  
  // WebRTC config
  const rtcConfig = {
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" }
    ]
  };

  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer');
  const messageInput = document.getElementById('messageInput');
  const scrollAnchor = document.getElementById('scrollAnchor');
  const voiceRecordBtn = document.getElementById('voiceRecordBtn');
  const voiceRecordingUI = document.getElementById('voiceRecordingUI');
  const voiceRecordTimer = document.getElementById('voiceRecordTimer');
  const voiceRecordCancelBtn = document.getElementById('voiceRecordCancelBtn');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const callInterface = document.getElementById('callInterface');
  const remoteVideo = document.getElementById('remoteVideo');
  const localVideo = document.getElementById('localVideo');
  const ringtone = document.getElementById('ringtone');
  const clearAllChatsBtn = document.getElementById('clearAllChatsBtn');

  // === UTILITY FUNCTIONS ===

  function showError(message, duration = 5000) {
    console.error(message);
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i><span>${message}</span>`;
    
    if (messagesContainer.style.display !== 'none') {
      messagesContainer.appendChild(errorDiv);
      setTimeout(() => errorDiv.remove(), duration);
    } else {
      alert(message);
    }
  }

  function getUserDisplayName(userId) {
    if (!userId) return 'Unknown User';
    return window.userNameCache?.[userId] || 'User';
  }

  function getUserProfilePicture(userId) {
    if (!userId) return `https://ui-avatars.com/api/?name=User&background=0080FF&color=fff`;
    return window.userAvatarCache?.[userId] || `https://ui-avatars.com/api/?name=User&background=0080FF&color=fff`;
  }

  // === SCROLL MANAGEMENT ===

  function setupScrollManagement() {
    const scrollToBottomBtn = document.createElement('button');
    scrollToBottomBtn.className = 'scroll-to-bottom-btn';
    scrollToBottomBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
    scrollToBottomBtn.onclick = () => {
      scrollToBottom(true);
      scrollToBottomBtn.classList.remove('visible');
    };
    messagesContainer.appendChild(scrollToBottomBtn);

    messagesContainer.addEventListener('scroll', () => {
      const scrollBottom = messagesContainer.scrollHeight - messagesContainer.clientHeight;
      const currentScroll = messagesContainer.scrollTop;
      const isNearBottom = scrollBottom - currentScroll < 100;
      
      scrollToBottomBtn.classList.toggle('visible', !isNearBottom);
      
      if (!isNearBottom) {
        userScrolled = true;
      }
      
      autoScrollEnabled = isNearBottom;
    });
  }

  function scrollToBottom(force = false) {
    if (!messagesContainer || !scrollAnchor) return;
    
    setTimeout(() => {
      if (force || autoScrollEnabled) {
        scrollAnchor.scrollIntoView({ behavior: force ? 'smooth' : 'auto' });
        userScrolled = false;
      }
    }, 50);
  }

  // === MESSAGE RENDERING ===

  function createVoiceNoteBars(count = 20) {
    let bars = '';
    for (let i = 0; i < count; i++) {
      const delay = Math.random() * 1.5;
      bars += `<div class="voice-note-bar" style="animation-delay: ${delay}s"></div>`;
    }
    return bars;
  }

  function renderMessageHTML(msg, isMe, id) {
    const avatarSrc = isMe ? document.getElementById('navUserImg').src : currentChatUserAvatar;
    
    let content = '';
    let mediaContent = '';
    
    if (msg.mediaType === 'image') {
      mediaContent = `
        <img src="${msg.mediaUrl}" class="message-img" loading="lazy" 
             style="max-width:100%; border-radius:8px; margin-top:6px;">
      `;
    } else if (msg.mediaType === 'audio') {
      mediaContent = `
        <div class="voice-note-player ${isMe ? 'sent' : 'received'}" 
             onclick="toggleAudioPlayback('${id}', '${msg.mediaUrl}')">
          <button class="voice-note-play-btn ${currentlyPlayingAudio?.id === id ? 'playing' : ''}" 
                  id="play-btn-${id}">
            <i class="fas ${currentlyPlayingAudio?.id === id ? 'fa-pause' : 'fa-play'}" 
               id="play-icon-${id}"></i>
          </button>
          <div class="voice-note-waveform">
            ${createVoiceNoteBars()}
            <div class="voice-note-progress" id="progress-${id}"></div>
          </div>
          <div class="voice-note-duration" id="duration-${id}">0:00</div>
        </div>
      `;
    }
    
    const textContent = msg.text ? 
      `<div style="word-break: break-word; overflow-wrap: break-word;">${msg.text.replace(/\n/g, '<br>')}</div>` : '';
    
    const timeString = msg.timestamp ? 
      new Date(msg.timestamp.seconds * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 
      'Sending...';
    
    const div = document.createElement('div');
    div.className = `message-wrapper ${isMe ? 'sent' : 'received'}`;
    div.id = id;
    
    div.innerHTML = `
      ${!isMe ? `<img src="${avatarSrc}" class="message-avatar-small" alt="${currentChatUserName}">` : ''}
      <div class="message-bubble">
        ${content}
        ${mediaContent}
        ${textContent}
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:2px;">
          <span style="font-size:10px; opacity:0.7;">${timeString}</span>
          ${isMe ? `<span style="font-size:10px; margin-left:4px;"><i class="fas fa-check${msg.readBy?.includes(currentChatUser) ? '-double' : ''}"></i></span>` : ''}
        </div>
      </div>
      ${isMe ? `<img src="${avatarSrc}" class="message-avatar-small" alt="You">` : ''}
    `;
    
    return div;
  }

  // === AUDIO PLAYBACK ===

  window.toggleAudioPlayback = function(audioId, audioUrl) {
    const playIcon = document.getElementById(`play-icon-${audioId}`);
    const playBtn = document.getElementById(`play-btn-${audioId}`);
    
    if (currentlyPlayingAudio && currentlyPlayingAudio.id === audioId) {
      if (currentlyPlayingAudio.audio.paused) {
        currentlyPlayingAudio.audio.play();
        playIcon.className = 'fas fa-pause';
        playBtn.classList.add('playing');
      } else {
        currentlyPlayingAudio.audio.pause();
        playIcon.className = 'fas fa-play';
        playBtn.classList.remove('playing');
      }
    } else {
      if (currentlyPlayingAudio) {
        currentlyPlayingAudio.audio.pause();
        const oldPlayIcon = document.getElementById(`play-icon-${currentlyPlayingAudio.id}`);
        if (oldPlayIcon) oldPlayIcon.className = 'fas fa-play';
        const oldPlayBtn = document.getElementById(`play-btn-${currentlyPlayingAudio.id}`);
        if (oldPlayBtn) oldPlayBtn.classList.remove('playing');
        clearInterval(audioPlayingInterval);
      }
      
      const audio = new Audio(audioUrl);
      audio.playbackRate = audioPlaybackSpeed;
      currentlyPlayingAudio = { audio, id: audioId };
      
      audio.play();
      playIcon.className = 'fas fa-pause';
      playBtn.classList.add('playing');
      
      audioPlayingInterval = setInterval(() => {
        if (audio.duration) {
          const progress = (audio.currentTime / audio.duration) * 100;
          const progressBar = document.getElementById(`progress-${audioId}`);
          if (progressBar) progressBar.style.width = `${progress}%`;
          
          const durationDisplay = document.getElementById(`duration-${audioId}`);
          if (durationDisplay) {
            const currentTime = Math.floor(audio.currentTime);
            const minutes = Math.floor(currentTime / 60);
            const seconds = currentTime % 60;
            durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
        }
      }, 100);
      
      audio.addEventListener('ended', () => {
        playIcon.className = 'fas fa-play';
        playBtn.classList.remove('playing');
        const progressBar = document.getElementById(`progress-${audioId}`);
        if (progressBar) progressBar.style.width = '0%';
        clearInterval(audioPlayingInterval);
        currentlyPlayingAudio = null;
      });
    }
  };

  // === VOICE RECORDING ===

  async function startVoiceRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true
        }
      });
      
      mediaRecorder = new MediaRecorder(stream, { 
        mimeType: 'audio/webm;codecs=opus'
      });
      
      audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await sendVoiceMessage(audioBlob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start(100);
      isRecording = true;
      
      // Show UI
      messageInput.style.display = 'none';
      voiceRecordingUI.style.display = 'flex';
      voiceRecordBtn.innerHTML = '<i class="fas fa-stop"></i>';
      
      // Start timer
      recordingStartTime = Date.now();
      updateRecordingTimer();
      recordingTimer = setInterval(updateRecordingTimer, 1000);
      
    } catch (error) {
      showError('Cannot access microphone');
    }
  }

  function stopVoiceRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      
      // Hide UI
      messageInput.style.display = 'block';
      voiceRecordingUI.style.display = 'none';
      voiceRecordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
      
      // Clear timer
      if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
      }
    }
  }

  function updateRecordingTimer() {
    if (!recordingStartTime) return;
    
    const elapsed = Date.now() - recordingStartTime;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    
    voiceRecordTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  async function sendVoiceMessage(audioBlob) {
    if (!currentChatId || audioBlob.size === 0) return;
    
    const tempId = 'temp-voice-' + Date.now();
    const audioUrl = URL.createObjectURL(audioBlob);
    
    // Create optimistic message
    const optimisticMsg = {
      mediaUrl: audioUrl,
      mediaType: 'audio',
      text: '',
      senderId: currentUser.uid,
      timestamp: null,
      isUploading: true
    };
    
    const msgElement = renderMessageHTML(optimisticMsg, true, tempId);
    messagesContainer.appendChild(msgElement);
    scrollToBottom(true);
    
    try {
      // Upload to Cloudinary
      const formData = new FormData();
      formData.append('file', audioBlob, 'voice_note.webm');
      formData.append('upload_preset', 'Meet_video');
      formData.append('resource_type', 'video');
      
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      const data = await response.json();
      
      if (data.secure_url) {
        // Remove optimistic message
        const tempElement = document.getElementById(tempId);
        if (tempElement) tempElement.remove();
        
        // Send actual message
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: 'audio',
          text: '',
          senderId: currentUser.uid,
          timestamp: serverTimestamp(),
          deliveredTo: [currentChatUser]
        });
        
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: 'Voice message',
          lastMessageSender: currentUser.uid,
          updatedAt: serverTimestamp()
        });
        
        scrollToBottom(true);
      }
    } catch (error) {
      console.error('Audio upload error:', error);
      const tempElement = document.getElementById(tempId);
      if (tempElement) tempElement.remove();
      showError('Failed to send voice message');
    }
  }

  // Setup voice recording
  voiceRecordBtn.addEventListener('click', () => {
    if (!isRecording) {
      startVoiceRecording();
    } else {
      stopVoiceRecording();
    }
  });

  voiceRecordCancelBtn.addEventListener('click', () => {
    stopVoiceRecording();
  });

  // === MESSAGE SENDING ===

  document.getElementById('sendButton').addEventListener('click', sendMessage);

  async function sendMessage() {
    const text = messageInput.value.trim();
    if ((!text && !isRecording) || !currentChatId) return;
    
    messageInput.value = '';
    messageInput.style.height = '40px';
    
    try {
      await addDoc(collection(db, "conversations", currentChatId, "messages"), {
        text: text,
        senderId: currentUser.uid,
        timestamp: serverTimestamp(),
        deliveredTo: [currentChatUser]
      });
      
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: text.length > 50 ? text.substring(0, 50) + '...' : text,
        lastMessageSender: currentUser.uid,
        updatedAt: serverTimestamp()
      });
      
      scrollToBottom(true);
      
    } catch (error) {
      console.error("Send error:", error);
      showError("Failed to send message");
    }
  }

  messageInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // === FILE UPLOAD ===

  window.handleFileUpload = async (files) => {
    if (!files || !currentChatId) return;
    
    for (const file of files) {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('upload_preset', 'Meet_video');
      
      let resourceType = 'auto';
      if (file.type.startsWith('image/')) resourceType = 'image';
      else if (file.type.startsWith('video/')) resourceType = 'video';
      
      formData.append('resource_type', resourceType);
      
      try {
        const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
          method: 'POST',
          body: formData
        });
        
        const data = await response.json();
        
        if (data.secure_url) {
          const mediaType = file.type.startsWith('image/') ? 'image' : 
                           file.type.startsWith('video/') ? 'video' : 
                           file.type.startsWith('audio/') ? 'audio' : 'file';
          
          await addDoc(collection(db, "conversations", currentChatId, "messages"), {
            mediaUrl: data.secure_url,
            mediaType: mediaType,
            text: '',
            senderId: currentUser.uid,
            timestamp: serverTimestamp(),
            deliveredTo: [currentChatUser]
          });
          
          const lastMessageText = mediaType === 'image' ? 'Image' : 
                                 mediaType === 'video' ? 'Video' : 
                                 mediaType === 'audio' ? 'Audio' : 'File';
          
          await updateDoc(doc(db, "conversations", currentChatId), {
            lastMessage: lastMessageText,
            lastMessageSender: currentUser.uid,
            updatedAt: serverTimestamp()
          });
          
          scrollToBottom(true);
        }
      } catch (error) {
        console.error('File upload error:', error);
        showError(`Failed to upload file`);
      }
    }
  };

  // === CHAT MANAGEMENT ===

  window.clearAllMessages = async function() {
    if (!currentChatId || !confirm('Clear all messages in this chat?')) return;
    
    try {
      const messagesQuery = query(collection(db, "conversations", currentChatId, "messages"));
      const snapshot = await getDocs(messagesQuery);
      
      const batch = writeBatch(db);
      snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
      });
      
      await batch.commit();
      
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: '',
        updatedAt: serverTimestamp()
      });
      
      messagesContainer.innerHTML = '';
      
    } catch (error) {
      console.error("Error clearing chat:", error);
      showError("Failed to clear chat");
    }
  };

  async function clearAllChats() {
    if (!confirm('Delete all conversations?')) return;
    
    try {
      const conversationsQuery = query(
        collection(db, "conversations"), 
        where("participants", "array-contains", currentUser.uid)
      );
      
      const snapshot = await getDocs(conversationsQuery);
      const batch = writeBatch(db);
      
      snapshot.docs.forEach(convDoc => {
        batch.delete(convDoc.ref);
      });
      
      await batch.commit();
      
      document.getElementById('conversationsList').innerHTML = '';
      
      if (currentChatId) {
        resetChatView();
      }
      
    } catch (error) {
      console.error("Error clearing all chats:", error);
      showError("Failed to clear all chats");
    }
  }

  function resetChatView() {
    document.getElementById('emptyChat').style.display = 'flex';
    document.getElementById('chatHeader').style.display = 'none';
    document.getElementById('messagesContainer').style.display = 'none';
    document.getElementById('messageInputContainer').style.display = 'none';
    
    currentChatId = null;
    currentChatUser = null;
    currentChatUserName = '';
    currentChatUserAvatar = '';
    
    if (unsubscribeMessages) {
      unsubscribeMessages();
      unsubscribeMessages = null;
    }
    
    localStorage.removeItem('last_active_chat');
  }

  async function openChat(chatId, otherUserId, name, avatar) {
    try {
      if (unsubscribeMessages) {
        unsubscribeMessages();
      }
      
      currentChatId = chatId;
      currentChatUser = otherUserId;
      currentChatUserName = name;
      currentChatUserAvatar = avatar;
      
      document.getElementById('emptyChat').style.display = 'none';
      document.getElementById('chatHeader').style.display = 'flex';
      document.getElementById('messagesContainer').style.display = 'flex';
      document.getElementById('messageInputContainer').style.display = 'block';
      document.getElementById('chatUserName').innerText = name;
      document.getElementById('currentChatAvatar').src = avatar;
      
      if (window.innerWidth <= 767) {
        document.getElementById('chatArea').classList.add('active');
      }
      
      localStorage.setItem('last_active_chat', chatId);
      
      await loadMessages(chatId);
      
    } catch (error) {
      console.error("Error opening chat:", error);
      showError("Failed to open chat");
      resetChatView();
    }
  }

  function loadMessages(chatId) {
    if (unsubscribeMessages) unsubscribeMessages();
    
    messagesContainer.innerHTML = '';
    messagesContainer.appendChild(scrollAnchor);
    setupScrollManagement();
    
    isInitialLoad = true;
    userScrolled = false;
    
    const q = query(
      collection(db, "conversations", chatId, "messages"),
      orderBy("timestamp", "asc"),
      limit(100)
    );
    
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
      const fragment = document.createDocumentFragment();
      let lastDate = null;
      
      snapshot.docChanges().forEach(change => {
        if (change.type === 'added') {
          const msg = { id: change.doc.id, ...change.doc.data() };
          const isMe = msg.senderId === currentUser.uid;
          
          // Add date header if needed
          const msgDate = msg.timestamp ? new Date(msg.timestamp.seconds * 1000).toDateString() : null;
          if (msgDate !== lastDate) {
            const dateDiv = document.createElement('div');
            dateDiv.className = 'date-divider';
            dateDiv.innerHTML = `<span>${formatDate(msg.timestamp)}</span>`;
            fragment.appendChild(dateDiv);
            lastDate = msgDate;
          }
          
          const div = renderMessageHTML(msg, isMe, msg.id);
          fragment.appendChild(div);
        }
      });
      
      messagesContainer.appendChild(fragment);
      
      // Scroll handling - only scroll to bottom on initial load or if user is at bottom
      if (isInitialLoad) {
        scrollToBottom(true);
        isInitialLoad = false;
      } else if (!userScrolled) {
        scrollToBottom(false);
      }
      
    }, (error) => {
      console.error("Error loading messages:", error);
      showError("Failed to load messages");
    });
  }

  function formatDate(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp.seconds * 1000);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) return "Today";
    if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
    
    return date.toLocaleDateString('en-US', { 
      weekday: 'short',
      month: 'short', 
      day: 'numeric' 
    });
  }

  // === CALL FUNCTIONALITY ===

  async function startCall(type) {
    if (!currentChatId || !currentChatUser) {
      showError("No chat selected");
      return;
    }

    try {
      const constraints = {
        audio: true,
        video: type === 'video'
      };
      
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      if (type === 'video') {
        localVideo.srcObject = localStream;
        callVideoContainer.classList.remove('audio-call-interface');
      } else {
        callVideoContainer.classList.add('audio-call-interface');
        callVideoContainer.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%;">
            <img src="${currentChatUserAvatar}" class="audio-call-avatar">
            <div style="color:white; font-size:24px; margin-top:20px;">${currentChatUserName}</div>
          </div>
        `;
      }
      
      // Create call document
      const callRef = await addDoc(collection(db, "calls"), {
        callerId: currentUser.uid,
        receiverId: currentChatUser,
        type: type,
        status: "ringing",
        createdAt: serverTimestamp(),
        callerName: document.getElementById('navUserName').textContent,
        callerAvatar: document.getElementById('navUserImg').src
      });

      currentCallId = callRef.id;
      callType = type;
      
      // Play ringtone
      ringtone.play().catch(console.error);
      
      // Update UI
      document.getElementById('callUserName').textContent = currentChatUserName;
      document.getElementById('callStatus').textContent = "Calling...";
      callInterface.style.display = 'flex';
      
      // Setup WebRTC
      await initializeWebRTC(true);
      
      // Listen for answer
      const callDocRef = doc(db, "calls", currentCallId);
      onSnapshot(callDocRef, (doc) => {
        if (doc.exists()) {
          const callData = doc.data();
          if (callData.status === "accepted") {
            document.getElementById('callStatus').textContent = "Connected";
            ringtone.pause();
            ringtone.currentTime = 0;
            if (callData.answer) {
              handleAnswer(callData.answer);
            }
          } else if (callData.status === "ended") {
            endCall();
          }
        }
      });
      
    } catch (error) {
      console.error("Error starting call:", error);
      showError("Failed to start call");
    }
  }

  async function initializeWebRTC(isCaller) {
    try {
      peerConnection = new RTCPeerConnection(rtcConfig);
      
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });
      
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;
      
      peerConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
      };
      
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && currentCallId) {
          addDoc(collection(db, "calls", currentCallId, "candidates"), {
            candidate: event.candidate.toJSON(),
            sender: currentUser.uid,
            timestamp: serverTimestamp()
          });
        }
      };
      
      if (isCaller) {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        await updateDoc(doc(db, "calls", currentCallId), {
          offer: {
            type: offer.type,
            sdp: offer.sdp
          }
        });
        
        // Listen for answer and candidates
        onSnapshot(doc(db, "calls", currentCallId), (doc) => {
          const data = doc.data();
          if (data.answer && !peerConnection.remoteDescription) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
          }
        });
        
        onSnapshot(collection(db, "calls", currentCallId, "candidates"), (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const candidateData = change.doc.data();
              if (candidateData.sender !== currentUser.uid) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
              }
            }
          });
        });
      }
      
    } catch (error) {
      console.error("WebRTC error:", error);
      showError("Call setup failed");
    }
  }

  async function handleAnswer(answer) {
    if (!peerConnection.remoteDescription) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }
  }

  function setupIncomingCallListener() {
    if (!currentUser) return;
    
    const q = query(
      collection(db, "calls"),
      where("receiverId", "==", currentUser.uid),
      where("status", "==", "ringing")
    );
    
    onSnapshot(q, (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        if (change.type === "added") {
          const callData = change.doc.data();
          const callId = change.doc.id;
          
          ringtone.play().catch(console.error);
          
          document.getElementById('incomingCallName').textContent = callData.callerName || 'Unknown';
          document.getElementById('incomingCallAvatar').src = callData.callerAvatar || 'https://ui-avatars.com/api/?name=Caller&background=0080FF&color=fff';
          document.getElementById('incomingCallType').textContent = 
            `Incoming ${callData.type === "video" ? "Video" : "Audio"} Call`;
          
          document.getElementById('incomingCallModal').style.display = 'flex';
          
          window.currentIncomingCallId = callId;
          window.currentIncomingCallData = callData;
        }
      });
    });
  }

  window.acceptCall = async function() {
    const callId = window.currentIncomingCallId;
    const callData = window.currentIncomingCallData;
    
    if (!callId) return;
    
    try {
      ringtone.pause();
      ringtone.currentTime = 0;
      
      const constraints = {
        audio: true,
        video: callData.type === 'video'
      };
      
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      if (callData.type === 'video') {
        localVideo.srcObject = localStream;
        callVideoContainer.classList.remove('audio-call-interface');
      } else {
        callVideoContainer.classList.add('audio-call-interface');
        callVideoContainer.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%;">
            <img src="${callData.callerAvatar || 'https://ui-avatars.com/api/?name=Caller&background=0080FF&color=fff'}" class="audio-call-avatar">
            <div style="color:white; font-size:24px; margin-top:20px;">${callData.callerName || 'Caller'}</div>
          </div>
        `;
      }
      
      currentCallId = callId;
      callType = callData.type;
      
      document.getElementById('callUserName').textContent = callData.callerName || 'Caller';
      document.getElementById('callStatus').textContent = "Connecting...";
      document.getElementById('incomingCallModal').style.display = 'none';
      callInterface.style.display = 'flex';
      
      await initializeWebRTC(false);
      
      if (callData.offer) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
        
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        await updateDoc(doc(db, "calls", callId), {
          answer: {
            type: answer.type,
            sdp: answer.sdp
          },
          status: "accepted",
          answeredAt: serverTimestamp()
        });
        
        onSnapshot(collection(db, "calls", callId, "candidates"), (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const candidateData = change.doc.data();
              if (candidateData.sender !== currentUser.uid) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidateData.candidate));
              }
            }
          });
        });
      }
      
    } catch (error) {
      console.error("Error accepting call:", error);
      showError("Failed to accept call");
    }
  };

  window.rejectCall = async function() {
    const callId = window.currentIncomingCallId;
    
    if (!callId) return;
    
    try {
      ringtone.pause();
      ringtone.currentTime = 0;
      
      await updateDoc(doc(db, "calls", callId), {
        status: "ended",
        endedAt: serverTimestamp()
      });
      
      document.getElementById('incomingCallModal').style.display = 'none';
      
    } catch (error) {
      console.error("Error rejecting call:", error);
    }
  };

  window.endCall = async function() {
    ringtone.pause();
    ringtone.currentTime = 0;
    
    if (currentCallId) {
      try {
        await updateDoc(doc(db, "calls", currentCallId), {
          status: "ended",
          endedAt: serverTimestamp()
        });
      } catch (error) {
        console.error("Error ending call:", error);
      }
    }
    
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    if (remoteStream) {
      remoteStream.getTracks().forEach(track => track.stop());
      remoteStream = null;
    }
    
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    callInterface.style.display = 'none';
    document.getElementById('incomingCallModal').style.display = 'none';
    currentCallId = null;
  };

  window.toggleMute = function() {
    if (localStream) {
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      
      const muteBtn = document.getElementById('muteBtn');
      if (isMuted) {
        muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
        muteBtn.classList.add('active');
      } else {
        muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
        muteBtn.classList.remove('active');
      }
    }
  };

  window.toggleVideo = function() {
    if (localStream && callType === 'video') {
      isVideoOn = !isVideoOn;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = isVideoOn;
      });
      
      const videoToggleBtn = document.getElementById('videoToggleBtn');
      if (!isVideoOn) {
        videoToggleBtn.innerHTML = '<i class="fas fa-video-slash"></i>';
        videoToggleBtn.classList.add('active');
      } else {
        videoToggleBtn.innerHTML = '<i class="fas fa-video"></i>';
        videoToggleBtn.classList.remove('active');
      }
    }
  };

  window.toggleSpeaker = function() {
    isSpeakerOn = !isSpeakerOn;
    if (remoteVideo) {
      remoteVideo.muted = !isSpeakerOn;
    }
    
    const speakerBtn = document.getElementById('speakerBtn');
    if (isSpeakerOn) {
      speakerBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
      speakerBtn.classList.add('active');
    } else {
      speakerBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
      speakerBtn.classList.remove('active');
    }
  };

  // === AUTHENTICATION ===

  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      document.getElementById('logoutBtn').addEventListener('click', () => {
        if (confirm('Log out?')) {
          signOut(auth);
        }
      });
      
      document.getElementById('nightToggleBtn').addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        localStorage.setItem('meet_dark_mode', document.body.classList.contains('dark-mode'));
      });
      
      clearAllChatsBtn.addEventListener('click', clearAllChats);
      
      audioCallBtn.addEventListener('click', () => startCall("audio"));
      videoCallBtn.addEventListener('click', () => startCall("video"));
      
      // Back button for mobile
      document.getElementById('backButton').addEventListener('click', () => {
        document.getElementById('chatArea').classList.remove('active');
      });
      
      try {
        const userDoc = await getDoc(doc(db, "users", user.uid));
        let photoURL = user.photoURL;
        let displayName = user.displayName;
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          if (userData.photoURL) photoURL = userData.photoURL;
          if (userData.name) displayName = userData.name;
        }
        
        document.getElementById('navUserImg').src = photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName || 'User')}&background=0080FF&color=fff`;
        document.getElementById('navUserName').textContent = displayName || 'User';
        
        if (!window.userNameCache) window.userNameCache = {};
        window.userNameCache[user.uid] = displayName || 'User';
        
        setupIncomingCallListener();
        loadConversations();
        
        // Load dark mode preference
        if (localStorage.getItem('meet_dark_mode') === 'true') {
          document.body.classList.add('dark-mode');
        }
        
        // Load last active chat
        const savedChatId = localStorage.getItem('last_active_chat');
        if (savedChatId) {
          setTimeout(() => {
            const convItem = document.querySelector(`[data-chat-id="${savedChatId}"]`);
            if (convItem) convItem.click();
          }, 1000);
        }
        
      } catch (error) {
        console.error("Error loading user data:", error);
      }
    }
  });

  function loadConversations() {
    const q = query(
      collection(db, "conversations"), 
      where("participants", "array-contains", currentUser.uid)
    );
    
    unsubscribeConversations = onSnapshot(q, async (snapshot) => {
      const list = document.getElementById('conversationsList');
      list.innerHTML = '';
      
      const convs = [];
      
      for (const doc of snapshot.docs) {
        const conv = { id: doc.id, ...doc.data() };
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        
        if (otherId) {
          try {
            const userDoc = await getDoc(doc(db, "users", otherId));
            const userData = userDoc.exists() ? userDoc.data() : {};
            conv.realName = userData.name || userData.displayName || 'User';
            conv.avatar = userData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(conv.realName)}&background=0080FF&color=fff`;
            convs.push(conv);
          } catch (error) {
            console.error("Error loading user:", error);
          }
        }
      }
      
      convs.sort((a, b) => (b.updatedAt?.seconds || 0) - (a.updatedAt?.seconds || 0));
      
      convs.forEach(conv => {
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        const name = conv.realName || 'User';
        const avatar = conv.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=0080FF&color=fff`;
        
        const div = document.createElement('div');
        div.className = 'conversation-item';
        div.setAttribute('data-chat-id', conv.id);
        
        div.innerHTML = `
          <img src="${avatar}" class="conversation-avatar" alt="${name}">
          <div class="conversation-info">
            <div class="conversation-name">${name}</div>
            <div class="conversation-preview">${conv.lastMessage || 'No messages yet'}</div>
          </div>
        `;
        
        div.onclick = () => {
          localStorage.setItem('last_active_chat', conv.id);
          openChat(conv.id, otherId, name, avatar);
        };
        
        list.appendChild(div);
      });
      
    }, (error) => {
      console.error("Error loading conversations:", error);
      showError("Failed to load conversations");
    });
  }

  // === INITIALIZATION ===

  document.addEventListener('DOMContentLoaded', () => {
    console.log("MEET Chat Application initialized");
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (window.innerWidth >= 768 && currentChatId) {
        document.getElementById('chatArea').classList.remove('active');
      }
    });
    
    // Handle page visibility
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && currentChatId) {
        loadMessages(currentChatId);
      }
    });
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      if (unsubscribeMessages) unsubscribeMessages();
      if (unsubscribeConversations) unsubscribeConversations();
      if (isRecording) stopVoiceRecording();
      if (currentlyPlayingAudio) currentlyPlayingAudio.audio.pause();
      if (peerConnection) peerConnection.close();
      if (localStream) localStream.getTracks().forEach(track => track.stop());
      ringtone.pause();
      ringtone.currentTime = 0;
    });
  });

</script>
</body>
</html>
