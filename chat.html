<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Professional Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --primary: #0080FF;
    --primary-dark: #0066CC;
    --bg-color: #f0f2f5;
    --card-bg: #ffffff;
    --text-color: #111111;
    --secondary-text: #65676b;
    --border-color: #dddfe2;
    --error: #ff3b30;
    --success: #34c759;
    --warning: #ff9500;
    --app-height: 100dvh;
    --chat-font: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --sent-bubble-bg: #0080FF;
    --sent-text-color: #ffffff;
    --received-bubble-bg: #ffffff;
    --received-text-color: #111111;
    --shadow-light: 0 1px 3px rgba(0,0,0,0.12);
    --shadow-medium: 0 4px 12px rgba(0,128,255,0.15);
    --shadow-heavy: 0 10px 40px rgba(0,0,0,0.1);
    --chat-container-width: 100%;
    --bubble-max-width: 65%;
  }

  @media (min-width: 768px) {
    :root {
      --chat-container-width: 85%;
      --bubble-max-width: 60%;
    }
  }

  @media (min-width: 1024px) {
    :root {
      --chat-container-width: 75%;
      --bubble-max-width: 55%;
    }
  }

  @media (min-width: 1200px) {
    :root {
      --chat-container-width: 65%;
      --bubble-max-width: 50%;
    }
  }

  body.dark-mode {
    --bg-color: #0f0f10;
    --card-bg: #1e1e1e;
    --text-color: #e4e6eb;
    --secondary-text: #b0b3b8;
    --border-color: #2f3031;
    --received-bubble-bg: #2a2b2c;
    --received-text-color: #e4e6eb;
    --shadow-light: 0 1px 3px rgba(0,0,0,0.3);
  }

  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
    -webkit-tap-highlight-color: transparent; 
  }

  html, body { 
    height: 100%; 
    overflow: hidden; 
    font-size: 14px; 
    font-family: var(--chat-font); 
    background: var(--bg-color); 
    color: var(--text-color); 
    transition: background 0.3s ease, color 0.3s ease;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .app-container { 
    display: flex; 
    height: var(--app-height); 
    position: relative; 
    overflow: hidden; 
  }

  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 0;
  }

  .sidebar {
    position: fixed; 
    top: 0; 
    left: 0; 
    height: 100%; 
    width: 280px;
    background: linear-gradient(180deg, #0080FF 0%, #0066CC 100%);
    z-index: 2000; 
    padding: 25px; 
    color: white;
    transform: translateX(-100%); 
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 4px 0 20px rgba(0,0,0,0.15);
  }
  .sidebar.open { transform: translateX(0); }
  
  .sidebar-header { 
    padding-bottom: 25px; 
    border-bottom: 1px solid rgba(255,255,255,0.2); 
    margin-bottom: 25px; 
    display: flex; 
    justify-content: space-between; 
    align-items: center;
  }
  
  .sidebar-header h2 {
    font-family: 'Poppins', sans-serif;
    letter-spacing: 1px;
    font-weight: 700;
    font-size: 22px;
  }
  
  .sidebar-menu { list-style: none; }
  .sidebar-menu li { margin-bottom: 8px; position: relative; }
  
  .notification-badge {
    position: absolute;
    top: -5px;
    right: 10px;
    background: var(--error);
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 11px;
    display: none;
    align-items: center;
    justify-content: center;
    font-weight: 600;
  }
  
  .sidebar-menu a { 
    display: flex; 
    align-items: center; 
    padding: 14px 12px; 
    text-decoration: none; 
    color: white; 
    border-radius: 12px; 
    font-size: 15px; 
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .sidebar-menu a:hover { 
    background: rgba(255, 255, 255, 0.15); 
  }
  .sidebar-menu a.active {
    background: rgba(255, 255, 255, 0.2);
    font-weight: 600;
  }
  
  .sidebar-menu i { 
    margin-right: 12px; 
    font-size: 18px; 
    width: 24px; 
    text-align: center; 
  }
  
  .sidebar-overlay { 
    display: none; 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background: rgba(0,0,0,0.5); 
    z-index: 1900; 
    transition: all 0.3s ease;
  }
  .sidebar-overlay.active { display: block; }

  .navbar {
    background: linear-gradient(135deg, #0080FF 0%, #0066CC 100%);
    padding: 12px 16px;
    display: flex; 
    justify-content: space-between; 
    align-items: center;
    color: white; 
    flex-shrink: 0; 
    position: relative;
    z-index: 100;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  
  .navbar-left { display: flex; align-items: center; gap: 15px; }
  .navbar-right { display: flex; align-items: center; gap: 10px; }
  
  .hamburger-btn { 
    background: none; 
    border: none; 
    color: white; 
    font-size: 20px; 
    cursor: pointer; 
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .hamburger-btn:hover {
    background: rgba(255,255,255,0.1);
  }
  
  .nav-user-img { 
    width: 36px;
    height: 36px;
    border-radius: 50%; 
    border: 2px solid rgba(255,255,255,0.8);
    object-fit: cover;
  }
  
  .nav-user-name {
    font-weight: 500;
    font-size: 14px;
    margin-left: 8px;
  }
  
  .btn { 
    background: rgba(255, 255, 255, 0.2); 
    color: white; 
    border: none; 
    padding: 8px 12px;
    border-radius: 8px; 
    cursor: pointer; 
    font-size: 12px;
    font-weight: 500;
    display: flex; 
    align-items: center; 
    gap: 6px;
    transition: all 0.2s ease; 
  }
  .btn:hover { 
    background: rgba(255, 255, 255, 0.3); 
  }

  .chat-container { 
    flex: 1; 
    background: var(--card-bg); 
    overflow: hidden; 
    display: flex; 
    min-height: 0; 
    position: relative; 
    width: 100%;
    max-width: 100%;
  }
  
  .conversations-sidebar { 
    width: 100%; 
    height: 100%;
    display: flex; 
    flex-direction: column; 
    background: var(--card-bg);
    border-right: 1px solid var(--border-color);
  }
  
  .chat-header { 
    padding: 15px;
    border-bottom: 1px solid var(--border-color); 
    display: flex; 
    justify-content: space-between; 
    align-items: center;
    background: var(--card-bg);
  }
  
  .chat-header h3 {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-color);
  }
  
  .new-chat-btn { 
    background: var(--primary); 
    color: white; 
    border: none; 
    width: 36px;
    height: 36px;
    border-radius: 50%; 
    cursor: pointer; 
    transition: all 0.2s ease; 
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }
  .new-chat-btn:hover { 
    transform: scale(1.05); 
  }
  
  .chat-search { 
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color); 
    background: var(--bg-color);
  }
  .chat-search input { 
    width: 100%; 
    padding: 10px 14px;
    border-radius: 20px; 
    border: 1px solid var(--border-color); 
    background: var(--card-bg); 
    color: var(--text-color); 
    outline: none; 
    transition: all 0.2s ease; 
    font-size: 14px;
  }
  .chat-search input:focus { 
    border-color: var(--primary); 
  }
  
  .conversations-list { 
    flex: 1; 
    overflow-y: auto; 
    scroll-behavior: smooth;
  }
  
  .conversation-item { 
    display: flex; 
    align-items: center; 
    gap: 12px;
    padding: 14px 15px;
    cursor: pointer; 
    border-bottom: 1px solid var(--border-color); 
    transition: all 0.2s ease; 
    position: relative;
  }
  
  .conversation-item:hover, 
  .conversation-item.active { 
    background: rgba(0,128,255,0.05); 
  }
  
  .conversation-avatar { 
    width: 45px;
    height: 45px;
    border-radius: 50%; 
    object-fit: cover; 
    border: 2px solid var(--border-color);
  }
  
  .conversation-info { 
    flex: 1; 
    min-width: 0; 
  }
  
  .conversation-name { 
    font-weight: 500; 
    font-size: 14px;
    margin-bottom: 3px;
    color: var(--text-color);
  }
  
  .conversation-preview { 
    font-size: 12px;
    color: var(--secondary-text); 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    line-height: 1.3;
  }

  .unread-count {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--primary);
    color: white;
    border-radius: 10px;
    min-width: 18px;
    height: 18px;
    font-size: 10px;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 5px;
  }

  .chat-area { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    height: 100%; 
    background: var(--bg-color); 
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: translateX(100%);
    transition: transform 0.3s ease;
  }
  
  .chat-area.active { 
    transform: translateX(0); 
  }
  
  .chat-area-header { 
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color); 
    display: flex; 
    align-items: center; 
    gap: 10px;
    background: var(--card-bg); 
    z-index: 10; 
    flex-shrink: 0;
  }
  
  .chat-user-info {
    flex: 1;
    margin-left: 8px;
  }
  
  .chat-user-name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-color);
    margin-bottom: 1px;
  }
  
  .chat-user-status {
    font-size: 11px;
    color: var(--secondary-text);
  }
  
  .chat-actions { 
    display: flex; 
    gap: 6px;
    margin-left: auto; 
  }
  
  .chat-action-btn { 
    background: none; 
    border: none; 
    color: var(--secondary-text); 
    font-size: 16px;
    cursor: pointer; 
    transition: all 0.2s ease; 
    padding: 8px;
    border-radius: 50%; 
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .chat-action-btn:hover { 
    background: rgba(0,128,255,0.1); 
    color: var(--primary);
  }

  .empty-chat {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--secondary-text);
    text-align: center;
    padding: 40px;
  }
  
  .empty-chat i {
    font-size: 60px;
    opacity: 0.3;
    margin-bottom: 20px;
    color: var(--primary);
  }
  
  .empty-chat h3 {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text-color);
  }
  
  .empty-chat p {
    font-size: 14px;
    opacity: 0.7;
    max-width: 250px;
    line-height: 1.5;
  }

  .messages-container { 
    flex: 1; 
    padding: 15px;
    overflow-y: auto; 
    display: flex; 
    flex-direction: column; 
    gap: 4px;
    background: var(--bg-color); 
    scroll-behavior: smooth;
    position: relative;
    will-change: transform;
  }

  .date-divider { 
    text-align: center; 
    margin: 15px 0;
    position: relative; 
  }
  
  .date-divider::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--border-color), transparent);
  }
  
  .date-divider span { 
    background: rgba(0,0,0,0.1); 
    color: var(--text-color); 
    padding: 4px 10px;
    border-radius: 12px; 
    font-size: 11px;
    font-weight: 500; 
    position: relative;
    z-index: 1;
  }

  body.dark-mode .date-divider span {
    background: rgba(255,255,255,0.1);
  }

  /* WhatsApp/Telegram style message bubbles */
  .message-wrapper { 
    display: flex; 
    gap: 8px;
    max-width: var(--bubble-max-width); 
    align-items: flex-end; 
    margin-bottom: 2px;
    animation: messageSlideIn 0.2s ease-out; 
    transition: opacity 0.2s ease;
  }
  
  @keyframes messageSlideIn { 
    from { 
      opacity: 0; 
      transform: translateY(5px);
    } 
    to { 
      opacity: 1; 
      transform: translateY(0); 
    } 
  }
  
  .message-wrapper.sent { 
    align-self: flex-end; 
    flex-direction: row-reverse; 
  }
  
  .message-wrapper.received {
    align-self: flex-start;
  }
  
  .message-avatar-small { 
    width: 28px;
    height: 28px;
    border-radius: 50%; 
    object-fit: cover; 
    flex-shrink: 0; 
    margin-bottom: 2px;
    border: 2px solid var(--card-bg);
  }

  /* WhatsApp/Telegram style bubble sizing */
  .message-bubble { 
    padding: 6px 12px 8px 12px;
    border-radius: 18px; 
    position: relative; 
    word-break: break-word;
    overflow-wrap: break-word;
    font-size: 14px;
    line-height: 1.4; 
    max-width: 100%; 
    font-family: var(--chat-font);
    min-width: 0;
    width: fit-content;
    max-width: 100%;
    transition: background-color 0.2s ease;
  }
  
  .received .message-bubble { 
    background: var(--received-bubble-bg); 
    color: var(--received-text-color);
    border: 1px solid var(--border-color);
    border-bottom-left-radius: 4px;
  }
  
  .sent .message-bubble { 
    background: var(--sent-bubble-bg); 
    color: var(--sent-text-color); 
    border-bottom-right-radius: 4px;
  }

  /* WhatsApp tail effect */
  .sent .message-bubble::before {
    content: '';
    position: absolute;
    bottom: 0;
    right: -8px;
    width: 0;
    height: 0;
    border-left: 8px solid var(--sent-bubble-bg);
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
  }
  
  .received .message-bubble::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: -8px;
    width: 0;
    height: 0;
    border-right: 8px solid var(--received-bubble-bg);
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
  }

  .message-content {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  .message-text {
    word-break: break-word;
    overflow-wrap: break-word;
    line-height: 1.4;
    font-size: 14px;
    white-space: pre-wrap;
  }

  .message-text img,
  .message-text video {
    max-width: 100%;
    border-radius: 8px;
    margin-top: 4px;
  }

  .message-time { 
    font-size: 11px;
    opacity: 0.7; 
    text-align: right; 
    margin-top: 2px;
    display: flex;
    align-items: center;
    gap: 4px;
    justify-content: flex-end;
  }
  
  /* WhatsApp style read receipt system */
  .message-status {
    display: inline-flex;
    align-items: center;
    margin-left: 2px;
  }
  
  .status-sending {
    color: rgba(255,255,255,0.6);
  }
  
  .status-sent {
    color: rgba(255,255,255,0.6);
  }
  
  .status-delivered {
    color: rgba(255,255,255,0.6);
  }
  
  .status-read {
    color: #4fc3f7;
  }

  .upload-overlay { 
    position: absolute; 
    inset: 0; 
    background: rgba(0,0,0,0.5); 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    border-radius: 8px; 
    color: white; 
    font-size: 20px;
  }

  .typing-indicator { 
    display: none; 
    padding: 8px 12px;
    background: var(--card-bg); 
    border-radius: 18px; 
    margin: 8px 15px;
    width: fit-content; 
    align-self: flex-start; 
    font-size: 12px;
    color: var(--secondary-text); 
    font-style: italic; 
    border: 1px solid var(--border-color);
  }
  
  .typing-indicator span { 
    animation: typingBlink 1.4s infinite both; 
  }
  .typing-indicator span:nth-child(2) { animation-delay: .2s; }
  .typing-indicator span:nth-child(3) { animation-delay: .4s; }
  
  @keyframes typingBlink { 
    0%, 80%, 100% { opacity: .2; } 
    40% { opacity: 1; } 
  }

  .message-input-container { 
    padding: 10px 15px;
    border-top: 1px solid var(--border-color); 
    background: var(--card-bg); 
    position: relative;
    flex-shrink: 0;
  }

  .message-input-wrapper { 
    display: flex; 
    align-items: flex-end; 
    gap: 10px;
  }
  
  .message-input-actions { 
    display: flex; 
    align-items: center; 
    gap: 6px;
    margin-bottom: 6px;
  }
  
  .input-action { 
    background: transparent; 
    border: none; 
    color: var(--secondary-text); 
    cursor: pointer; 
    font-size: 18px;
    padding: 8px;
    border-radius: 50%; 
    transition: all 0.2s ease;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .input-action:hover { 
    color: var(--primary); 
    background: rgba(0,128,255,0.1); 
  }

  .message-input { 
    flex: 1; 
    padding: 10px 14px;
    border-radius: 25px; 
    border: 1px solid var(--border-color); 
    background: var(--bg-color); 
    color: var(--text-color); 
    resize: none; 
    font-family: var(--chat-font);
    font-size: 14px;
    max-height: 100px; 
    min-height: 40px;
    height: 40px; 
    outline: none; 
    overflow-y: auto; 
    line-height: 1.5; 
    transition: all 0.2s ease;
  }
  
  .message-input:focus { 
    border-color: var(--primary); 
  }
  
  .send-button { 
    background: var(--primary); 
    color: white; 
    border: 0; 
    width: 40px;
    height: 40px;
    border-radius: 50%; 
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    flex-shrink: 0; 
    transition: all 0.2s ease;
    font-size: 14px;
  }
  
  .send-button:hover { 
    background: var(--primary-dark); 
  }

  /* Voice recording styles */
  .voice-record-container {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(0,128,255,0.1);
    border-radius: 20px;
    margin-right: 10px;
    animation: recordingPulse 1.5s infinite;
  }

  @keyframes recordingPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(0,128,255,0.4); }
    50% { box-shadow: 0 0 0 8px rgba(0,128,255,0); }
  }

  .voice-record-timer {
    font-size: 12px;
    font-weight: 600;
    color: var(--primary);
    min-width: 40px;
    text-align: center;
  }

  .voice-record-visualizer {
    flex: 1;
    height: 4px;
    background: rgba(0,128,255,0.2);
    border-radius: 2px;
    overflow: hidden;
    position: relative;
  }

  .voice-record-wave {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, transparent, var(--primary), transparent);
    animation: wave 1s infinite linear;
  }

  @keyframes wave {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  .voice-record-cancel {
    background: none;
    border: none;
    color: var(--error);
    cursor: pointer;
    font-size: 14px;
    padding: 4px;
    border-radius: 50%;
    transition: all 0.2s ease;
  }

  .voice-record-cancel:hover {
    background: rgba(239, 68, 68, 0.1);
  }

  /* WhatsApp/Telegram style voice note player */
  .voice-note-player {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--received-bubble-bg);
    border-radius: 18px;
    min-width: 140px;
    max-width: 220px;
    border: 1px solid var(--border-color);
    position: relative;
    cursor: pointer;
  }

  .voice-note-player.sent {
    background: var(--sent-bubble-bg);
    border: none;
  }

  .voice-note-play-btn {
    background: var(--primary);
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
    z-index: 2;
  }

  .voice-note-play-btn:hover {
    background: var(--primary-dark);
  }

  .voice-note-waveform {
    flex: 1;
    height: 24px;
    position: relative;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    overflow: hidden;
  }

  .voice-note-player.received .voice-note-waveform {
    background: rgba(0, 0, 0, 0.05);
  }

  .voice-note-progress {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: rgba(255, 255, 255, 0.25);
    width: 0%;
    transition: width 0.1s linear;
  }

  .voice-note-player.received .voice-note-progress {
    background: rgba(0, 128, 255, 0.25);
  }

  .voice-note-duration {
    font-size: 11px;
    font-weight: 500;
    color: var(--sent-text-color);
    min-width: 35px;
    text-align: right;
    flex-shrink: 0;
  }

  .voice-note-player.received .voice-note-duration {
    color: var(--received-text-color);
  }

  .voice-note-wave {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      90deg,
      transparent,
      transparent 2px,
      rgba(255, 255, 255, 0.3) 2px,
      rgba(255, 255, 255, 0.3) 4px
    );
    background-size: 200% 100%;
    animation: waveMove 2s linear infinite;
  }

  .voice-note-player.received .voice-note-wave {
    background: repeating-linear-gradient(
      90deg,
      transparent,
      transparent 2px,
      rgba(0, 128, 255, 0.3) 2px,
      rgba(0, 128, 255, 0.3) 4px
    );
  }

  @keyframes waveMove {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  /* Call Interface Styles */
  .call-interface {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    z-index: 3000;
    display: none;
    flex-direction: column;
  }

  .call-header {
    padding: 20px;
    background: rgba(0,0,0,0.8);
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 10;
  }

  .call-user-info {
    text-align: center;
    flex: 1;
  }

  .call-user-name {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 5px;
  }

  .call-status {
    font-size: 14px;
    opacity: 0.8;
  }

  .call-video-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .remote-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .local-video {
    position: absolute;
    bottom: 100px;
    right: 20px;
    width: 100px;
    height: 140px;
    border-radius: 10px;
    border: 2px solid white;
    object-fit: cover;
    z-index: 20;
  }

  .call-controls {
    padding: 25px 20px;
    display: flex;
    justify-content: center;
    gap: 25px;
    background: rgba(0,0,0,0.8);
  }

  .call-control-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    cursor: pointer;
    transition: all 0.3s ease;
    background: rgba(255,255,255,0.2);
    color: white;
  }

  .call-control-btn.end-call {
    background: #ff4444;
  }

  .call-control-btn:hover {
    transform: scale(1.1);
  }

  .incoming-call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 3000;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .incoming-call-content {
    background: var(--card-bg);
    border-radius: 20px;
    padding: 30px;
    text-align: center;
    max-width: 350px;
    width: 90%;
    animation: modalSlideIn 0.3s ease;
  }

  .incoming-call-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto 15px;
    object-fit: cover;
  }

  .incoming-call-name {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .incoming-call-type {
    font-size: 14px;
    color: var(--secondary-text);
    margin-bottom: 25px;
  }

  .incoming-call-buttons {
    display: flex;
    gap: 20px;
    justify-content: center;
  }

  .call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .accept-call {
    background: #00C851;
    color: white;
  }

  .reject-call {
    background: #ff4444;
    color: white;
  }

  /* Audio call specific */
  .audio-call-interface .call-video-container {
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  }

  .audio-call-avatar {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 4px solid var(--primary);
    object-fit: cover;
  }

  /* Modal and overlay styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .modal-content {
    background: var(--card-bg);
    border-radius: 16px;
    padding: 25px;
    max-width: 500px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color);
  }

  .modal-header h3 {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-color);
  }

  .close-modal {
    background: none;
    border: none;
    font-size: 24px;
    color: var(--secondary-text);
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: all 0.2s ease;
  }

  .close-modal:hover {
    background: rgba(239, 68, 68, 0.1);
    color: var(--error);
  }

  /* Scroll to bottom button */
  .scroll-to-bottom-btn {
    position: absolute;
    bottom: 80px;
    right: 15px;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 100;
    transition: all 0.3s ease;
  }
  
  .scroll-to-bottom-btn:hover {
    background: var(--primary-dark);
    transform: scale(1.1);
  }

  /* Message options */
  .msg-options-btn { 
    opacity: 0; 
    transition: all 0.2s ease; 
    background: var(--card-bg); 
    border: 1px solid var(--border-color); 
    color: var(--secondary-text); 
    cursor: pointer; 
    padding: 4px 6px;
    border-radius: 50%; 
    font-size: 10px;
    align-self: center; 
    margin: 0 4px;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .message-wrapper:hover .msg-options-btn { 
    opacity: 1; 
  }
  
  .msg-options-menu { 
    display: none; 
    position: absolute; 
    top: 100%; 
    right: 0; 
    background: var(--card-bg); 
    border-radius: 8px; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
    z-index: 100; 
    min-width: 140px;
    overflow: hidden; 
    border: 1px solid var(--border-color); 
    animation: menuSlideIn 0.2s ease; 
  }
  
  @keyframes menuSlideIn { 
    from { 
      transform: scale(0.95) translateY(-5px); 
      opacity: 0; 
    } 
    to { 
      transform: scale(1) translateY(0); 
      opacity: 1; 
    } 
  }
  
  .msg-options-menu.active { display: block; }
  
  .msg-option-item { 
    padding: 10px 12px;
    cursor: pointer; 
    font-size: 12px;
    color: var(--text-color); 
    display: flex; 
    align-items: center; 
    gap: 8px;
    transition: all 0.2s ease;
    font-weight: 500;
  }
  
  .msg-option-item:hover { 
    background: rgba(0,128,255,0.08); 
    color: var(--primary); 
  }
  
  .msg-option-item.delete { 
    color: var(--error) !important; 
  }
  
  .msg-option-item.delete:hover { 
    background: rgba(239, 68, 68, 0.1) !important; 
  }

  /* Responsive adjustments */
  @media (min-width: 768px) {
    .conversations-sidebar { 
      width: 350px; 
      position: relative;
      transform: none !important;
    }
    
    .chat-area { 
      position: relative;
      transform: none !important;
    }
    
    .navbar {
      padding: 12px 20px;
    }
    
    .message-bubble {
      max-width: 55%;
    }
    
    .voice-note-player {
      min-width: 160px;
      max-width: 260px;
    }
  }

  @media (max-width: 767px) {
    .sidebar {
      width: 260px;
    }
    
    .navbar {
      padding: 10px 15px;
    }
    
    .hamburger-btn {
      width: 36px;
      height: 36px;
    }
    
    .nav-user-img {
      width: 32px;
      height: 32px;
    }
    
    .nav-user-name {
      font-size: 13px;
    }
    
    .btn {
      padding: 6px 10px;
      font-size: 11px;
    }
    
    .conversation-item {
      padding: 12px 15px;
    }
    
    .conversation-avatar {
      width: 40px;
      height: 40px;
    }
    
    .message-bubble {
      max-width: 70%;
    }
    
    .voice-note-player {
      min-width: 130px;
      max-width: 200px;
    }
    
    .call-controls {
      padding: 20px;
      gap: 15px;
    }
    
    .call-control-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }
    
    .local-video {
      width: 80px;
      height: 120px;
      bottom: 80px;
      right: 15px;
    }
    
    .incoming-call-content {
      padding: 25px;
    }
    
    .incoming-call-avatar {
      width: 70px;
      height: 70px;
    }
    
    .call-action-btn {
      width: 50px;
      height: 50px;
      font-size: 20px;
    }
  }

  @media (max-width: 480px) {
    .message-bubble {
      max-width: 75%;
    }
    
    .voice-note-player {
      min-width: 120px;
      max-width: 180px;
    }
    
    .message-input-container {
      padding: 8px 12px;
    }
    
    .message-input {
      padding: 8px 12px;
      font-size: 13px;
    }
    
    .input-action {
      width: 32px;
      height: 32px;
      font-size: 16px;
    }
    
    .send-button {
      width: 36px;
      height: 36px;
    }
    
    .conversation-preview {
      font-size: 11px;
    }
  }

  body.dark-mode .sidebar {
    background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
  }
  
  body.dark-mode .navbar {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  }
  
  body.dark-mode .message-bubble {
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
</style>
</head>
<body>
<div class="app-container">
  <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
  
  <div class="sidebar" id="mainSidebar">
    <div class="sidebar-header">
      <h2>MEET</h2>
      <button onclick="toggleSidebar()" class="close-modal"><i class="fas fa-times"></i></button>
    </div>
    <ul class="sidebar-menu">
      <li>
        <a href="feed.html" id="feedLink">
          <i class="fas fa-home"></i> <span>Feed</span>
          <span class="notification-badge" id="feedNotificationBadge">0</span>
        </a>
      </li>
      <li><a href="profile.html"><i class="fas fa-user"></i> <span>Profile</span></a></li>
      <li><a href="chat.html" class="active"><i class="fas fa-comment"></i> <span>Chat</span></a></li>
      <li><a href="conference.html"><i class="fas fa-video"></i> <span>Conference</span></a></li>
      <li><a href="meetrader.html"><i class="fas fa-store"></i> <span>Meetrader</span></a></li>
    </ul>
  </div>

  <div class="main-content">
    <div class="navbar">
      <div class="navbar-left">
        <button class="hamburger-btn" onclick="toggleSidebar()"><i class="fas fa-bars"></i></button>
        <h2 style="font-weight:600; font-size:16px;">Chat</h2>
      </div>
      <div class="navbar-right">
        <img src="https://ui-avatars.com/api/?name=User&background=0080FF&color=fff" id="navUserImg" class="nav-user-img" alt="Me">
        <span id="navUserName" class="nav-user-name">User</span>
        <button class="btn" id="nightToggleBtn" title="Toggle Dark Mode"><i class="fas fa-moon"></i></button>
        <button class="btn" id="clearAllChatsBtn" title="Clear All Chats"><i class="fas fa-trash-alt"></i></button>
        <button class="btn" id="logoutBtn" title="Logout"><i class="fas fa-sign-out-alt"></i></button>
      </div>
    </div>

    <div class="chat-container">
      <div class="conversations-sidebar" id="conversationsSidebar">
        <div class="chat-header">
          <h3>Messages</h3>
          <button class="new-chat-btn" onclick="openUserSearchModal()"><i class="fas fa-plus"></i></button>
        </div>
        <div class="chat-search">
          <input type="text" placeholder="Search chats..." id="chatSearch">
        </div>
        <div class="conversations-list" id="conversationsList">
          <!-- Conversations will be loaded here -->
        </div>
      </div>

      <div class="chat-area" id="chatArea">
        <div id="emptyChat" class="empty-chat">
          <i class="far fa-comments"></i>
          <h3>Select a conversation</h3>
          <p>Choose a contact to start chatting</p>
        </div>

        <div class="chat-area-header" id="chatHeader" style="display: none;">
          <button class="chat-action-btn" id="backButton" style="color:var(--text-color);"><i class="fas fa-arrow-left"></i></button>
          <img src="" id="currentChatAvatar" class="conversation-avatar">
          <div class="chat-user-info">
            <div class="chat-user-name" id="chatUserName">User</div>
            <div class="chat-user-status">Last seen recently</div>
          </div>
          <div class="chat-actions">
            <button class="chat-action-btn" onclick="openClearChatModal()" title="Clear Chat"><i class="fas fa-trash-alt"></i></button>
            <button class="chat-action-btn" id="audioCallBtn" title="Voice Call"><i class="fas fa-phone-alt"></i></button>
            <button class="chat-action-btn" id="videoCallBtn" title="Video Call"><i class="fas fa-video"></i></button>
          </div>
        </div>

        <div class="messages-container" id="messagesContainer" style="display: none;">
          <!-- Messages will be loaded here -->
        </div>

        <button class="scroll-to-bottom-btn" id="scrollToBottomBtn" title="Scroll to bottom">
          <i class="fas fa-chevron-down"></i>
        </button>

        <div class="typing-indicator" id="typingIndicator">
          <span id="typingUserName">User</span> is typing <span>.</span><span>.</span><span>.</span>
        </div>

        <div class="message-input-container" id="messageInputContainer" style="display: none;">
          <div class="message-input-wrapper">
            <div class="message-input-actions">
              <button class="input-action" onclick="toggleEmojiPicker()" title="Emoji"><i class="far fa-smile"></i></button>
              
              <!-- Voice recording button -->
              <button class="input-action" id="voiceRecordBtn" title="Voice Note"><i class="fas fa-microphone"></i></button>
              
              <!-- File upload button -->
              <input type="file" id="fileInputHidden" accept="image/*,video/*,audio/*" style="display:none" onchange="handleFileUpload(this.files)">
              <button class="input-action" onclick="document.getElementById('fileInputHidden').click()" title="Send File"><i class="fas fa-paperclip"></i></button>
            </div>
            
            <!-- Voice recording UI -->
            <div id="voiceRecordingUI" style="display: none;" class="voice-record-container">
              <div class="voice-record-timer" id="voiceRecordTimer">0:00</div>
              <div class="voice-record-visualizer">
                <div class="voice-record-wave"></div>
              </div>
              <button class="voice-record-cancel" id="voiceRecordCancelBtn" title="Cancel Recording"><i class="fas fa-times"></i></button>
            </div>
            
            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1" spellcheck="true"></textarea>
            <button class="send-button" id="sendButton" title="Send Message"><i class="fas fa-paper-plane"></i></button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Ringtone Audio -->
<audio id="ringtone" loop style="display: none;">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-classic-alarm-995.mp3" type="audio/mpeg">
</audio>

<!-- Call Interface -->
<div class="call-interface" id="callInterface">
  <div class="call-header">
    <div class="call-user-info">
      <div class="call-user-name" id="callUserName">John Doe</div>
      <div class="call-status" id="callStatus">Connecting...</div>
    </div>
    <button class="close-modal" onclick="endCall()" style="color:white;"><i class="fas fa-times"></i></button>
  </div>
  <div class="call-video-container" id="callVideoContainer">
    <!-- Video streams will be added here -->
  </div>
  <div class="call-controls">
    <button class="call-control-btn mute" id="muteBtn" onclick="toggleMute()">
      <i class="fas fa-microphone"></i>
    </button>
    <button class="call-control-btn video-toggle" id="videoToggleBtn" onclick="toggleVideo()">
      <i class="fas fa-video"></i>
    </button>
    <button class="call-control-btn speaker" id="speakerBtn" onclick="toggleSpeaker()">
      <i class="fas fa-volume-up"></i>
    </button>
    <button class="call-control-btn end-call" onclick="endCall()">
      <i class="fas fa-phone"></i>
    </button>
  </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incomingCallModal">
  <div class="incoming-call-content">
    <img src="" id="incomingCallAvatar" class="incoming-call-avatar">
    <div class="incoming-call-name" id="incomingCallName">John Doe</div>
    <div class="incoming-call-type" id="incomingCallType">Incoming Voice Call</div>
    <div class="incoming-call-buttons">
      <button class="call-action-btn accept-call" onclick="acceptCall()">
        <i class="fas fa-phone"></i>
      </button>
      <button class="call-action-btn reject-call" onclick="rejectCall()">
        <i class="fas fa-phone-slash"></i>
      </button>
    </div>
  </div>
</div>

<!-- Clear Chat Modal -->
<div class="modal-overlay" id="clearChatModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Clear Chat</h3>
      <button class="close-modal" onclick="closeClearChatModal()">&times;</button>
    </div>
    <div style="padding: 20px 0;">
      <p style="margin-bottom: 15px; color: var(--text-color);">Are you sure you want to clear all messages in this chat? This action cannot be undone.</p>
      <div style="display: flex; gap: 10px;">
        <button onclick="closeClearChatModal()" style="flex:1; padding:10px; background:var(--bg-color); color:var(--text-color); border:1px solid var(--border-color); border-radius:8px; cursor:pointer;">Cancel</button>
        <button onclick="clearCurrentChat()" style="flex:1; padding:10px; background:var(--error); color:white; border:none; border-radius:8px; cursor:pointer;">Clear Chat</button>
      </div>
    </div>
  </div>
</div>

<!-- Delete All Chats Modal -->
<div class="modal-overlay" id="deleteAllChatsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Delete All Chats</h3>
      <button class="close-modal" onclick="closeDeleteAllChatsModal()">&times;</button>
    </div>
    <div style="padding: 20px 0;">
      <p style="margin-bottom: 15px; color: var(--text-color);">Are you sure you want to delete all your conversations? This action cannot be undone.</p>
      <div style="display: flex; gap: 10px;">
        <button onclick="closeDeleteAllChatsModal()" style="flex:1; padding:10px; background:var(--bg-color); color:var(--text-color); border:1px solid var(--border-color); border-radius:8px; cursor:pointer;">Cancel</button>
        <button onclick="deleteAllChats()" style="flex:1; padding:10px; background:var(--error); color:white; border:none; border-radius:8px; cursor:pointer;">Delete All</button>
      </div>
    </div>
  </div>
</div>

<!-- User Search Modal -->
<div class="modal-overlay" id="userSearchModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>New Conversation</h3>
      <button class="close-modal" onclick="closeUserSearchModal()">&times;</button>
    </div>
    <div style="padding: 20px 0;">
      <div class="chat-search">
        <input type="text" placeholder="Search by name or email..." id="userSearchInput">
      </div>
      <div id="userSearchResults" style="max-height: 300px; overflow-y: auto; margin-top: 15px;">
        <!-- Search results will appear here -->
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Settings</h3>
      <button class="close-modal" onclick="closeSettingsModal()">&times;</button>
    </div>
    <div style="padding: 20px 0;">
      <div style="margin-bottom: 20px;">
        <h4 style="font-size: 14px; color: var(--text-color); margin-bottom: 10px; font-weight: 600;">Chat Settings</h4>
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
          <span>Dark Mode</span>
          <input type="checkbox" id="darkModeToggle" style="transform: scale(1.2);">
        </div>
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
          <span>Message Sounds</span>
          <input type="checkbox" id="messageSoundsToggle" checked style="transform: scale(1.2);">
        </div>
      </div>
      <div>
        <h4 style="font-size: 14px; color: var(--text-color); margin-bottom: 10px; font-weight: 600;">Danger Zone</h4>
        <button onclick="openDeleteAllChatsModal()" style="width:100%; padding:12px; background:rgba(239,68,68,0.1); color:var(--error); border:1px solid var(--error); border-radius:8px; cursor:pointer; font-weight:500;">Delete All Conversations</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getFirestore, collection, addDoc, updateDoc, doc, getDoc, getDocs, onSnapshot, serverTimestamp, query, orderBy, where, setDoc, limit, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDtqM_pMGIYkUgy0OWGsQbfS9MtYQhrgZM",
    authDomain: "meet-6e159.firebaseapp.com",
    projectId: "meet-6e159",
    storageBucket: "meet-6e159.firebasestorage.app",
    messagingSenderId: "252353608421",
    appId: "1:252353608421:web:6706056048e9a8f12db20c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Global state variables
  let currentUser = null;
  let currentChatId = null;
  let currentChatUser = null;
  let currentChatUserName = '';
  let currentChatUserAvatar = '';
  let unsubscribeMessages = null;
  let unsubscribeConversations = null;
  let unsubscribeUserProfiles = null;
  let unsubscribeFeedNotifications = null;
  
  // Message state
  let replyToMsg = null;
  let editingMsgId = null;
  
  // UI state
  let currentConversationContext = null;

  // Voice recording state
  let mediaRecorder = null;
  let audioChunks = [];
  let recordingTimer = null;
  let recordingStartTime = null;
  let isRecording = false;
  
  // Voice note playing state
  let currentlyPlayingAudio = null;
  let audioPlayingInterval = null;

  // Scroll management
  let autoScrollEnabled = true;
  let isUserScrolling = false;
  let scrollTimeout = null;
  let lastScrollTop = 0;

  // Call state
  let currentCallId = null;
  let localStream = null;
  let remoteStream = null;
  let peerConnection = null;
  let callType = 'audio';
  let isMuted = false;
  let isVideoOn = true;
  let isSpeakerOn = true;

  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer');
  const messageInput = document.getElementById('messageInput');
  const sidebar = document.getElementById('mainSidebar');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const navUserImg = document.getElementById('navUserImg');
  const navUserName = document.getElementById('navUserName');
  const voiceRecordBtn = document.getElementById('voiceRecordBtn');
  const voiceRecordingUI = document.getElementById('voiceRecordingUI');
  const voiceRecordTimer = document.getElementById('voiceRecordTimer');
  const voiceRecordCancelBtn = document.getElementById('voiceRecordCancelBtn');
  const audioCallBtn = document.getElementById('audioCallBtn');
  const videoCallBtn = document.getElementById('videoCallBtn');
  const callInterface = document.getElementById('callInterface');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const ringtone = document.getElementById('ringtone');
  const clearAllChatsBtn = document.getElementById('clearAllChatsBtn');
  const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
  const nightToggleBtn = document.getElementById('nightToggleBtn');
  const logoutBtn = document.getElementById('logoutBtn');

  // === UTILITY FUNCTIONS ===

  function showError(message, duration = 3000) {
    console.error('Error:', message);
    
    // Create error toast
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--error);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      animation: slideIn 0.3s ease;
    `;
    toast.innerHTML = `<i class="fas fa-exclamation-circle" style="margin-right:8px;"></i>${message}`;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, duration);
    
    // Add keyframes
    if (!document.getElementById('toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.textContent = `
        @keyframes slideIn {
          from { top: -100px; opacity: 0; }
          to { top: 20px; opacity: 1; }
        }
        @keyframes slideOut {
          from { top: 20px; opacity: 1; }
          to { top: -100px; opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
  }

  function showSuccess(message, duration = 2000) {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--success);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      animation: slideIn 0.3s ease;
    `;
    toast.innerHTML = `<i class="fas fa-check-circle" style="margin-right:8px;"></i>${message}`;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  function formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp.seconds * 1000);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function formatDateHeader(timestamp) {
    if (!timestamp) return null;
    
    const date = new Date(timestamp.seconds * 1000);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) return "Today";
    if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
    
    const daysDiff = Math.floor((today - date) / (1000 * 60 * 60 * 24));
    if (daysDiff < 7) {
      return date.toLocaleDateString('en-US', { weekday: 'long' });
    }
    
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: date.getFullYear() !== today.getFullYear() ? 'numeric' : undefined 
    });
  }

  async function getUserDisplayName(userId) {
    if (!userId) return 'Unknown User';
    
    try {
      if (window.userNameCache && window.userNameCache[userId]) {
        return window.userNameCache[userId];
      }
      
      const userDoc = await getDoc(doc(db, "users", userId));
      if (userDoc.exists()) {
        const userData = userDoc.data();
        const displayName = userData.name || userData.displayName || userData.firstName || 'User';
        
        if (!window.userNameCache) window.userNameCache = {};
        window.userNameCache[userId] = displayName;
        
        return displayName;
      }
      return 'User';
    } catch (error) {
      console.error("Error fetching user name:", error);
      return 'User';
    }
  }

  async function getUserProfilePicture(userId) {
    if (!userId) return `https://ui-avatars.com/api/?name=User&background=0080FF&color=fff`;
    
    try {
      const userDoc = await getDoc(doc(db, "users", userId));
      if (userDoc.exists()) {
        const userData = userDoc.data();
        return userData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(userData.name || 'User')}&background=0080FF&color=fff`;
      }
    } catch (error) {
      console.error("Error fetching user profile picture:", error);
    }
    
    return `https://ui-avatars.com/api/?name=User&background=0080FF&color=fff`;
  }

  // === MESSAGE RENDERING ===

  function renderMessageHTML(msg, isMe, id) {
    const avatarSrc = isMe ? navUserImg.src : currentChatUserAvatar;
    const userName = isMe ? 'You' : currentChatUserName;
    
    let content = '';
    let mediaContent = '';
    
    if (msg.mediaType === 'image') {
      mediaContent = `
        <div style="margin-top: 4px;">
          <img src="${msg.mediaUrl}" style="max-width:100%; max-height:200px; border-radius:8px; display:block;" 
               onerror="this.src='https://via.placeholder.com/200?text=Image+Failed+to+Load'">
        </div>
      `;
    } else if (msg.mediaType === 'video') {
      mediaContent = `
        <div style="margin-top: 4px;">
          <video src="${msg.mediaUrl}" controls style="max-width:100%; max-height:200px; border-radius:8px; display:block;"></video>
        </div>
      `;
    } else if (msg.mediaType === 'audio') {
      mediaContent = `
        <div class="voice-note-player ${isMe ? 'sent' : 'received'}" data-audio-id="${id}" onclick="toggleAudioPlayback('${id}', '${msg.mediaUrl}')">
          <button class="voice-note-play-btn" id="play-btn-${id}">
            <i class="fas fa-play" id="play-icon-${id}" style="font-size:12px;"></i>
          </button>
          <div class="voice-note-waveform">
            <div class="voice-note-wave"></div>
            <div class="voice-note-progress" id="progress-${id}" style="width: 0%"></div>
          </div>
          <div class="voice-note-duration" id="duration-${id}">0:00</div>
        </div>
      `;
    }
    
    if (msg.text) {
      const formattedText = msg.text
        .replace(/\n/g, '<br>')
        .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color:inherit; text-decoration:underline;">$1</a>');
      content = `<div class="message-text">${formattedText}</div>`;
    }
    
    // Message status
    let statusIcon = 'fas fa-clock';
    let statusClass = 'status-sending';
    
    if (msg.isOptimistic) {
      statusIcon = 'fas fa-clock';
      statusClass = 'status-sending';
    } else if (msg.readBy && msg.readBy.includes(currentChatUser)) {
      statusIcon = 'fas fa-check-double';
      statusClass = 'status-read';
    } else if (msg.deliveredTo && msg.deliveredTo.includes(currentChatUser)) {
      statusIcon = 'fas fa-check-double';
      statusClass = 'status-delivered';
    } else if (msg.timestamp) {
      statusIcon = 'fas fa-check';
      statusClass = 'status-sent';
    }
    
    const statusHtml = isMe ? 
      `<span class="message-status ${statusClass}"><i class="${statusIcon}"></i></span>` : '';
    
    const timeString = msg.timestamp ? formatTime(msg.timestamp) : '...';
    
    const div = document.createElement('div');
    div.className = `message-wrapper ${isMe ? 'sent' : 'received'}`;
    div.id = id;
    div.setAttribute('data-sender', msg.senderId);
    
    div.innerHTML = `
      ${!isMe ? `<img src="${avatarSrc}" class="message-avatar-small" alt="${userName}">` : ''}
      <div class="message-bubble">
        <div class="message-content">
          ${content}
          ${mediaContent}
          <div class="message-time">
            ${timeString}
            ${statusHtml}
          </div>
        </div>
      </div>
      ${isMe ? `<img src="${avatarSrc}" class="message-avatar-small" alt="${userName}">` : ''}
    `;
    
    return div;
  }

  // === AUDIO PLAYBACK ===
  window.toggleAudioPlayback = function(audioId, audioUrl) {
    const playIcon = document.getElementById(`play-icon-${audioId}`);
    const progressBar = document.getElementById(`progress-${audioId}`);
    const durationDisplay = document.getElementById(`duration-${audioId}`);
    
    if (currentlyPlayingAudio && currentlyPlayingAudio.id === audioId) {
      // Pause current audio
      if (currentlyPlayingAudio.audio.paused) {
        currentlyPlayingAudio.audio.play();
        playIcon.className = 'fas fa-pause';
        
        // Update progress bar
        audioPlayingInterval = setInterval(() => {
          if (currentlyPlayingAudio.audio.duration) {
            const progress = (currentlyPlayingAudio.audio.currentTime / currentlyPlayingAudio.audio.duration) * 100;
            progressBar.style.width = `${progress}%`;
            
            // Update duration display
            const currentTime = Math.floor(currentlyPlayingAudio.audio.currentTime);
            const minutes = Math.floor(currentTime / 60);
            const seconds = currentTime % 60;
            durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
        }, 100);
      } else {
        currentlyPlayingAudio.audio.pause();
        playIcon.className = 'fas fa-play';
        clearInterval(audioPlayingInterval);
      }
    } else {
      // Stop any currently playing audio
      if (currentlyPlayingAudio) {
        currentlyPlayingAudio.audio.pause();
        const oldPlayIcon = document.getElementById(`play-icon-${currentlyPlayingAudio.id}`);
        if (oldPlayIcon) oldPlayIcon.className = 'fas fa-play';
        const oldProgressBar = document.getElementById(`progress-${currentlyPlayingAudio.id}`);
        if (oldProgressBar) oldProgressBar.style.width = '0%';
        clearInterval(audioPlayingInterval);
      }
      
      // Start new audio
      const audio = new Audio(audioUrl);
      currentlyPlayingAudio = { audio, id: audioId };
      
      audio.play();
      playIcon.className = 'fas fa-pause';
      
      // Set up progress tracking
      audio.addEventListener('loadedmetadata', () => {
        const duration = Math.floor(audio.duration);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      });
      
      audioPlayingInterval = setInterval(() => {
        if (audio.duration) {
          const progress = (audio.currentTime / audio.duration) * 100;
          progressBar.style.width = `${progress}%`;
          
          // Update duration display
          const currentTime = Math.floor(audio.currentTime);
          const minutes = Math.floor(currentTime / 60);
          const seconds = currentTime % 60;
          durationDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
      }, 100);
      
      audio.addEventListener('ended', () => {
        playIcon.className = 'fas fa-play';
        progressBar.style.width = '0%';
        clearInterval(audioPlayingInterval);
        currentlyPlayingAudio = null;
        durationDisplay.textContent = '0:00';
      });
    }
  };

  // === SCROLL MANAGEMENT ===
  function setupScrollHandling() {
    messagesContainer.addEventListener('scroll', () => {
      const scrollTop = messagesContainer.scrollTop;
      const scrollHeight = messagesContainer.scrollHeight;
      const clientHeight = messagesContainer.clientHeight;
      
      // Check if user is scrolling up
      if (scrollTop < lastScrollTop) {
        isUserScrolling = true;
      }
      
      lastScrollTop = scrollTop;
      
      // Check if near bottom
      const isNearBottom = scrollHeight - clientHeight - scrollTop < 100;
      
      // Show/hide scroll to bottom button
      if (!isNearBottom) {
        scrollToBottomBtn.style.display = 'flex';
      } else {
        scrollToBottomBtn.style.display = 'none';
      }
      
      // Reset scrolling flag after 2 seconds of inactivity
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isUserScrolling = false;
      }, 2000);
    });
    
    scrollToBottomBtn.addEventListener('click', () => {
      scrollToBottom(true);
      scrollToBottomBtn.style.display = 'none';
    });
  }

  function scrollToBottom(force = false) {
    if (!messagesContainer) return;
    
    setTimeout(() => {
      const scrollHeight = messagesContainer.scrollHeight;
      const clientHeight = messagesContainer.clientHeight;
      
      if (scrollHeight > clientHeight) {
        // Only scroll if forced or user is not actively scrolling
        if (force || !isUserScrolling) {
          messagesContainer.scrollTop = scrollHeight;
        }
      }
    }, 50);
  }

  // === CHAT MANAGEMENT ===
  async function loadConversations() {
    if (!currentUser) return;
    
    const q = query(
      collection(db, "conversations"), 
      where("participants", "array-contains", currentUser.uid),
      orderBy("updatedAt", "desc")
    );
    
    unsubscribeConversations = onSnapshot(q, async (snapshot) => {
      const list = document.getElementById('conversationsList');
      list.innerHTML = '';
      
      const convs = [];
      
      for (const doc of snapshot.docs) {
        const conv = { id: doc.id, ...doc.data() };
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        
        if (otherId) {
          const realName = await getUserDisplayName(otherId);
          conv.realName = realName;
          convs.push(conv);
        }
      }
      
      convs.forEach(conv => {
        const otherId = conv.participants.find(p => p !== currentUser.uid);
        const name = conv.realName || conv.participantNames?.[otherId] || 'User';
        const avatar = conv.participantAvatars?.[otherId] || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=0080FF&color=fff`;
        
        const div = document.createElement('div');
        div.className = `conversation-item ${currentChatId === conv.id ? 'active' : ''}`;
        div.setAttribute('data-chat-id', conv.id);
        
        const lastRead = localStorage.getItem(`meet_last_read_${conv.id}`);
        const hasUnread = !lastRead || (conv.updatedAt?.seconds * 1000 > parseInt(lastRead) && conv.lastMessageSender !== currentUser.uid);
        
        div.innerHTML = `
          <img src="${avatar}" class="conversation-avatar" alt="${name}">
          <div class="conversation-info">
            <div class="conversation-name">${name}</div>
            <div class="conversation-preview">${conv.lastMessage || 'No messages yet'}</div>
          </div>
          ${hasUnread ? `<span class="unread-count">1</span>` : ''}
        `;
        
        div.addEventListener('click', () => {
          localStorage.setItem('last_active_chat', conv.id);
          localStorage.setItem(`meet_last_read_${conv.id}`, Date.now());
          openChat(conv.id, otherId, name, avatar);
          
          const unreadIndicator = div.querySelector('.unread-count');
          if (unreadIndicator) {
            unreadIndicator.remove();
          }
        });
        
        list.appendChild(div);
      });
      
    }, (error) => {
      console.error("Error loading conversations:", error);
      showError("Failed to load conversations");
    });
  }

  async function openChat(chatId, otherUserId, name, avatar) {
    try {
      if (unsubscribeMessages) {
        unsubscribeMessages();
      }
      
      // Reset state
      currentChatId = null;
      messagesContainer.innerHTML = '';
      isUserScrolling = false;
      
      const convDoc = await getDoc(doc(db, "conversations", chatId));
      if (!convDoc.exists()) {
        throw new Error("Conversation not found");
      }

      const convData = convDoc.data();
      if (!convData.participants.includes(currentUser.uid)) {
        throw new Error("Access denied");
      }

      currentChatId = chatId;
      currentChatUser = otherUserId;
      currentChatUserName = name;
      currentChatUserAvatar = avatar;
      
      // Update UI
      document.getElementById('emptyChat').style.display = 'none';
      document.getElementById('chatHeader').style.display = 'flex';
      document.getElementById('messagesContainer').style.display = 'flex';
      document.getElementById('messageInputContainer').style.display = 'block';
      document.getElementById('chatUserName').textContent = name;
      document.getElementById('currentChatAvatar').src = avatar;
      document.getElementById('typingUserName').textContent = name;
      
      // Mark conversation as read
      document.querySelectorAll('.conversation-item').forEach(el => el.classList.remove('active'));
      const activeItem = document.querySelector(`[data-chat-id="${chatId}"]`);
      if (activeItem) activeItem.classList.add('active');

      // Show chat area on mobile
      if (window.innerWidth < 768) {
        document.getElementById('chatArea').classList.add('active');
      }
      
      // Load messages
      await loadMessages(chatId);
      
    } catch (error) {
      console.error("Error opening chat:", error);
      showError("Failed to open chat");
    }
  }

  function loadMessages(chatId) {
    if (unsubscribeMessages) unsubscribeMessages();
    
    const q = query(
      collection(db, "conversations", chatId, "messages"),
      orderBy("timestamp", "asc"),
      limit(100)
    );
    
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
      let lastHeader = null;
      let hasMessages = false;
      
      messagesContainer.innerHTML = '';
      
      snapshot.docs.forEach(doc => {
        hasMessages = true;
        const msg = { id: doc.id, ...doc.data() };
        const isMe = msg.senderId === currentUser.uid;
        const currentHeader = formatDateHeader(msg.timestamp);
        
        if (currentHeader && currentHeader !== lastHeader) {
          const div = document.createElement('div');
          div.className = 'date-divider';
          div.innerHTML = `<span>${currentHeader}</span>`;
          messagesContainer.appendChild(div);
          lastHeader = currentHeader;
        }

        const div = renderMessageHTML(msg, isMe, msg.id);
        messagesContainer.appendChild(div);
      });
      
      if (hasMessages) {
        // Initial scroll to bottom
        setTimeout(() => {
          scrollToBottom(true);
        }, 100);
      }
      
    }, (error) => {
      console.error("Error loading messages:", error);
      showError("Failed to load messages");
    });
  }

  // === MESSAGE SENDING ===
  async function sendMessage() {
    const text = messageInput.value.trim();
    if (!text || !currentChatId) return;
    
    messageInput.value = '';
    messageInput.style.height = '40px';
    
    const msgPayload = {
      text: text,
      senderId: currentUser.uid,
      timestamp: serverTimestamp(),
      deliveredTo: [currentChatUser],
      readBy: []
    };
    
    try {
      await addDoc(collection(db, "conversations", currentChatId, "messages"), msgPayload);
      
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: text.length > 30 ? text.substring(0, 30) + '...' : text,
        lastMessageSender: currentUser.uid,
        updatedAt: serverTimestamp()
      });
      
      // Don't auto-scroll - let user stay where they are
      
    } catch (error) {
      console.error("Send error:", error);
      messageInput.value = text;
      showError("Failed to send message");
    }
  }

  // === VOICE RECORDING ===
  async function startVoiceRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await sendVoiceMessage(audioBlob);
        
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      isRecording = true;
      
      // Show recording UI
      messageInput.style.display = 'none';
      voiceRecordingUI.style.display = 'flex';
      voiceRecordBtn.innerHTML = '<i class="fas fa-stop"></i>';
      
      // Start timer
      recordingStartTime = Date.now();
      updateRecordingTimer();
      recordingTimer = setInterval(updateRecordingTimer, 1000);
      
    } catch (error) {
      console.error('Error accessing microphone:', error);
      showError('Microphone access denied');
    }
  }

  function stopVoiceRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      
      // Hide recording UI
      messageInput.style.display = 'block';
      voiceRecordingUI.style.display = 'none';
      voiceRecordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
      
      // Clear timer
      if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
      }
    }
  }

  function updateRecordingTimer() {
    if (!recordingStartTime) return;
    
    const elapsed = Date.now() - recordingStartTime;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    
    voiceRecordTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  async function sendVoiceMessage(audioBlob) {
    if (!currentChatId || audioBlob.size === 0) return;
    
    const audioUrl = URL.createObjectURL(audioBlob);
    
    try {
      // Upload to Cloudinary
      const formData = new FormData();
      formData.append('file', audioBlob, 'voice_note.webm');
      formData.append('upload_preset', 'Meet_video');
      formData.append('resource_type', 'video');
      
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) throw new Error('Upload failed');
      
      const data = await response.json();
      
      if (data.secure_url) {
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: 'audio',
          text: '',
          senderId: currentUser.uid,
          timestamp: serverTimestamp(),
          deliveredTo: [currentChatUser]
        });
        
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: 'Voice message',
          lastMessageSender: currentUser.uid,
          updatedAt: serverTimestamp()
        });
      }
    } catch (error) {
      console.error('Voice upload error:', error);
      showError('Failed to send voice message');
    }
  }

  // === CALL FUNCTIONALITY ===
  async function startCall(type) {
    if (!currentChatId || !currentChatUser) {
      showError("No chat selected");
      return;
    }

    try {
      // Get user media
      const constraints = {
        audio: true,
        video: type === 'video'
      };
      
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      callType = type;
      
      // Create call document
      const callRef = await addDoc(collection(db, "calls"), {
        callerId: currentUser.uid,
        callerName: navUserName.textContent,
        callerAvatar: navUserImg.src,
        receiverId: currentChatUser,
        type: type,
        status: 'ringing',
        createdAt: serverTimestamp()
      });

      currentCallId = callRef.id;
      
      // Play ringtone for caller
      ringtone.play().catch(e => console.log("Ringtone play failed:", e));
      
      // Update UI
      document.getElementById('callUserName').textContent = currentChatUserName;
      document.getElementById('callStatus').textContent = "Calling...";
      callInterface.style.display = 'flex';
      
      if (type === 'audio') {
        callVideoContainer.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);">
            <img src="${currentChatUserAvatar}" class="audio-call-avatar">
            <div style="color:white; font-size:22px; margin-top:15px;">${currentChatUserName}</div>
          </div>
        `;
      } else {
        const localVideoEl = document.createElement('video');
        localVideoEl.id = 'localVideo';
        localVideoEl.className = 'local-video';
        localVideoEl.autoplay = true;
        localVideoEl.playsInline = true;
        localVideoEl.muted = true;
        localVideoEl.srcObject = localStream;
        callVideoContainer.innerHTML = '';
        callVideoContainer.appendChild(localVideoEl);
      }
      
      // Listen for call acceptance
      const callDocRef = doc(db, "calls", currentCallId);
      const unsubscribe = onSnapshot(callDocRef, (doc) => {
        if (doc.exists()) {
          const callData = doc.data();
          if (callData.status === 'accepted') {
            document.getElementById('callStatus').textContent = "Connected";
            ringtone.pause();
            ringtone.currentTime = 0;
            
            // Setup WebRTC connection
            setupWebRTCConnection(callData);
            unsubscribe();
            
          } else if (callData.status === 'rejected' || callData.status === 'ended') {
            endCall();
            unsubscribe();
          }
        }
      });
      
    } catch (error) {
      console.error("Error starting call:", error);
      showError("Failed to start call");
      endCall();
    }
  }

  function setupWebRTCConnection(callData) {
    // This is a simplified WebRTC setup
    // In production, you would need proper signaling and STUN/TURN servers
    
    try {
      // Create peer connection
      const configuration = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      };
      
      peerConnection = new RTCPeerConnection(configuration);
      
      // Add local stream
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });
      
      // Create remote stream
      remoteStream = new MediaStream();
      
      // Handle remote stream
      peerConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
        
        // Display remote video/audio
        if (callType === 'video') {
          const remoteVideoEl = document.createElement('video');
          remoteVideoEl.id = 'remoteVideo';
          remoteVideoEl.className = 'remote-video';
          remoteVideoEl.autoplay = true;
          remoteVideoEl.playsInline = true;
          remoteVideoEl.srcObject = remoteStream;
          callVideoContainer.appendChild(remoteVideoEl);
        }
      };
      
      // Create and send offer
      peerConnection.createOffer()
        .then(offer => peerConnection.setLocalDescription(offer))
        .then(() => {
          // Send offer to Firestore
          updateDoc(doc(db, "calls", currentCallId), {
            offer: peerConnection.localDescription.toJSON(),
            status: 'connected'
          });
        })
        .catch(error => {
          console.error("WebRTC error:", error);
          showError("Call connection failed");
        });
      
    } catch (error) {
      console.error("WebRTC setup error:", error);
      showError("Call setup failed");
    }
  }

  function setupIncomingCallListener() {
    if (!currentUser) return;
    
    const q = query(
      collection(db, "calls"),
      where("receiverId", "==", currentUser.uid),
      where("status", "==", "ringing")
    );
    
    onSnapshot(q, (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added") {
          const callData = change.doc.data();
          const callId = change.doc.id;
          
          // Play ringtone
          ringtone.play().catch(e => console.log("Ringtone play failed:", e));
          
          // Show incoming call modal
          document.getElementById('incomingCallName').textContent = callData.callerName || 'Unknown';
          document.getElementById('incomingCallAvatar').src = callData.callerAvatar || 'https://ui-avatars.com/api/?name=Caller&background=0080FF&color=fff';
          document.getElementById('incomingCallType').textContent = `Incoming ${callData.type === "video" ? "Video" : "Audio"} Call`;
          
          incomingCallModal.style.display = 'flex';
          
          // Store call info
          window.currentIncomingCallId = callId;
          window.currentIncomingCallData = callData;
        }
      });
    });
  }

  window.acceptCall = async function() {
    const callId = window.currentIncomingCallId;
    const callData = window.currentIncomingCallData;
    
    if (!callId) return;
    
    try {
      // Stop ringtone
      ringtone.pause();
      ringtone.currentTime = 0;
      
      // Get user media
      const constraints = {
        audio: true,
        video: callData.type === 'video'
      };
      
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      callType = callData.type;
      currentCallId = callId;
      
      // Update UI
      document.getElementById('callUserName').textContent = callData.callerName || 'Caller';
      document.getElementById('callStatus').textContent = "Connecting...";
      incomingCallModal.style.display = 'none';
      callInterface.style.display = 'flex';
      
      if (callData.type === 'audio') {
        callVideoContainer.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);">
            <img src="${callData.callerAvatar || 'https://ui-avatars.com/api/?name=Caller&background=0080FF&color=fff'}" class="audio-call-avatar">
            <div style="color:white; font-size:22px; margin-top:15px;">${callData.callerName || 'Caller'}</div>
          </div>
        `;
      } else {
        const localVideoEl = document.createElement('video');
        localVideoEl.id = 'localVideo';
        localVideoEl.className = 'local-video';
        localVideoEl.autoplay = true;
        localVideoEl.playsInline = true;
        localVideoEl.muted = true;
        localVideoEl.srcObject = localStream;
        callVideoContainer.innerHTML = '';
        callVideoContainer.appendChild(localVideoEl);
      }
      
      // Update call status
      await updateDoc(doc(db, "calls", callId), {
        status: 'accepted',
        answeredAt: serverTimestamp()
      });
      
      // Setup WebRTC
      setupWebRTCConnection(callData);
      
    } catch (error) {
      console.error("Error accepting call:", error);
      showError("Failed to accept call");
    }
  };

  window.rejectCall = async function() {
    const callId = window.currentIncomingCallId;
    
    if (!callId) return;
    
    try {
      ringtone.pause();
      ringtone.currentTime = 0;
      
      await updateDoc(doc(db, "calls", callId), {
        status: 'rejected',
        endedAt: serverTimestamp()
      });
      
      incomingCallModal.style.display = 'none';
      
    } catch (error) {
      console.error("Error rejecting call:", error);
    }
  };

  window.endCall = async function() {
    // Stop ringtone
    ringtone.pause();
    ringtone.currentTime = 0;
    
    if (currentCallId) {
      try {
        await updateDoc(doc(db, "calls", currentCallId), {
          status: 'ended',
          endedAt: serverTimestamp()
        });
      } catch (error) {
        console.error("Error updating call status:", error);
      }
    }
    
    // Clean up media streams
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    if (remoteStream) {
      remoteStream.getTracks().forEach(track => track.stop());
      remoteStream = null;
    }
    
    // Clean up peer connection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    // Reset UI
    callInterface.style.display = 'none';
    incomingCallModal.style.display = 'none';
    currentCallId = null;
  };

  window.toggleMute = function() {
    if (localStream) {
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      
      const muteBtn = document.getElementById('muteBtn');
      if (isMuted) {
        muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
        muteBtn.style.background = '#ff4444';
      } else {
        muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
        muteBtn.style.background = '';
      }
    }
  };

  window.toggleVideo = function() {
    if (localStream && callType === 'video') {
      isVideoOn = !isVideoOn;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = isVideoOn;
      });
      
      const videoToggleBtn = document.getElementById('videoToggleBtn');
      if (!isVideoOn) {
        videoToggleBtn.innerHTML = '<i class="fas fa-video-slash"></i>';
        videoToggleBtn.style.background = '#ff4444';
      } else {
        videoToggleBtn.innerHTML = '<i class="fas fa-video"></i>';
        videoToggleBtn.style.background = '';
      }
    }
  };

  window.toggleSpeaker = function() {
    isSpeakerOn = !isSpeakerOn;
    
    const speakerBtn = document.getElementById('speakerBtn');
    if (isSpeakerOn) {
      speakerBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
      speakerBtn.style.background = '#0080FF';
    } else {
      speakerBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
      speakerBtn.style.background = '';
    }
  };

  // === FILE UPLOAD ===
  window.handleFileUpload = async (files) => {
    if (!files || !currentChatId) return;
    
    for (const file of files) {
      const maxSize = 25 * 1024 * 1024;
      if (file.size > maxSize) {
        showError(`File "${file.name}" is too large. Max size is 25MB.`);
        continue;
      }
      
      let mediaType = 'file';
      if (file.type.startsWith('image/')) {
        mediaType = 'image';
      } else if (file.type.startsWith('video/')) {
        mediaType = 'video';
      } else if (file.type.startsWith('audio/')) {
        mediaType = 'audio';
      }
      
      try {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('upload_preset', 'Meet_video');
        
        let resourceType = 'raw';
        if (mediaType === 'image') resourceType = 'image';
        else if (mediaType === 'video' || mediaType === 'audio') resourceType = 'video';
        
        formData.append('resource_type', resourceType);
        
        const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) throw new Error('Upload failed');
        
        const data = await response.json();
        
        if (data.secure_url) {
          const msgData = {
            mediaUrl: data.secure_url,
            mediaType: mediaType,
            text: mediaType === 'file' ? `File: ${file.name}` : '',
            senderId: currentUser.uid,
            timestamp: serverTimestamp(),
            deliveredTo: [currentChatUser]
          };
          
          if (mediaType === 'file') {
            msgData.fileName = file.name;
            msgData.fileSize = file.size;
          }
          
          await addDoc(collection(db, "conversations", currentChatId, "messages"), msgData);
          
          const lastMessageText = mediaType === 'image' ? 'Image' : 
                                 mediaType === 'video' ? 'Video' : 
                                 mediaType === 'audio' ? 'Audio' : 
                                 `File: ${file.name}`;
          
          await updateDoc(doc(db, "conversations", currentChatId), {
            lastMessage: lastMessageText,
            lastMessageSender: currentUser.uid,
            updatedAt: serverTimestamp()
          });
          
          showSuccess('File sent successfully');
        }
      } catch (error) {
        console.error('File upload error:', error);
        showError(`Failed to upload "${file.name}"`);
      }
    }
  };

  // === MODAL FUNCTIONS ===
  function openClearChatModal() {
    document.getElementById('clearChatModal').style.display = 'flex';
  }

  function closeClearChatModal() {
    document.getElementById('clearChatModal').style.display = 'none';
  }

  function openDeleteAllChatsModal() {
    document.getElementById('deleteAllChatsModal').style.display = 'flex';
  }

  function closeDeleteAllChatsModal() {
    document.getElementById('deleteAllChatsModal').style.display = 'none';
  }

  function openUserSearchModal() {
    document.getElementById('userSearchModal').style.display = 'flex';
    document.getElementById('userSearchInput').focus();
  }

  function closeUserSearchModal() {
    document.getElementById('userSearchModal').style.display = 'none';
    document.getElementById('userSearchInput').value = '';
    document.getElementById('userSearchResults').innerHTML = '';
  }

  function openSettingsModal() {
    document.getElementById('settingsModal').style.display = 'flex';
  }

  function closeSettingsModal() {
    document.getElementById('settingsModal').style.display = 'none';
  }

  // === DELETE FUNCTIONS ===
  async function clearCurrentChat() {
    if (!currentChatId) {
      closeClearChatModal();
      return;
    }
    
    try {
      const messagesQuery = query(collection(db, "conversations", currentChatId, "messages"));
      const snapshot = await getDocs(messagesQuery);
      
      const batch = writeBatch(db);
      snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
      });
      
      await batch.commit();
      
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: '',
        updatedAt: serverTimestamp()
      });
      
      messagesContainer.innerHTML = '';
      closeClearChatModal();
      showSuccess('Chat cleared successfully');
      
    } catch (error) {
      console.error("Error clearing chat:", error);
      showError("Failed to clear chat");
    }
  }

  async function deleteAllChats() {
    if (!currentUser) return;
    
    try {
      const conversationsQuery = query(
        collection(db, "conversations"), 
        where("participants", "array-contains", currentUser.uid)
      );
      
      const snapshot = await getDocs(conversationsQuery);
      const batch = writeBatch(db);
      
      // Delete all conversations
      snapshot.docs.forEach(convDoc => {
        batch.delete(convDoc.ref);
      });
      
      await batch.commit();
      
      // Clear the conversations list
      document.getElementById('conversationsList').innerHTML = '';
      
      // Reset current chat view if open
      if (currentChatId) {
        document.getElementById('emptyChat').style.display = 'flex';
        document.getElementById('chatHeader').style.display = 'none';
        document.getElementById('messagesContainer').style.display = 'none';
        document.getElementById('messageInputContainer').style.display = 'none';
        
        currentChatId = null;
        currentChatUser = null;
        
        if (unsubscribeMessages) {
          unsubscribeMessages();
          unsubscribeMessages = null;
        }
      }
      
      closeDeleteAllChatsModal();
      showSuccess('All chats deleted successfully');
      
    } catch (error) {
      console.error("Error deleting all chats:", error);
      showError("Failed to delete all chats");
    }
  }

  // === USER SEARCH ===
  document.getElementById('userSearchInput').addEventListener('input', async (e) => {
    const term = e.target.value.toLowerCase().trim();
    const resDiv = document.getElementById('userSearchResults');
    resDiv.innerHTML = '';
    
    if (term.length < 2) {
      resDiv.innerHTML = '<div style="padding:20px; text-align:center; color:var(--secondary-text);">Type at least 2 characters</div>';
      return;
    }
    
    try {
      const usersQuery = query(
        collection(db, "users"),
        where("email", ">=", term),
        limit(10)
      );
      
      const snap = await getDocs(usersQuery);
      let hasResults = false;
      
      if (snap.empty) {
        resDiv.innerHTML = '<div style="padding:20px; text-align:center; color:var(--secondary-text);">No users found</div>';
        return;
      }
      
      for (const doc of snap.docs) {
        if (doc.id === currentUser.uid) continue;
        
        const userData = doc.data();
        const userName = userData.name || userData.displayName || 'User';
        const userEmail = userData.email || '';
        
        if (userName.toLowerCase().includes(term) || userEmail.toLowerCase().includes(term)) {
          hasResults = true;
          const div = document.createElement('div');
          div.className = 'conversation-item';
          div.innerHTML = `
            <img src="${userData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(userName)}&background=0080FF&color=fff`}" 
                 class="conversation-avatar" alt="${userName}">
            <div class="conversation-info">
              <div class="conversation-name">${userName}</div>
              <div class="conversation-preview">${userEmail}</div>
            </div>
          `;
          div.onclick = () => startNewChat(doc.id, userData);
          resDiv.appendChild(div);
        }
      }
      
      if (!hasResults) {
        resDiv.innerHTML = '<div style="padding:20px; text-align:center; color:var(--secondary-text);">No users found</div>';
      }
      
    } catch (error) {
      console.error("Search error:", error);
      resDiv.innerHTML = '<div style="padding:20px; text-align:center; color:var(--error);">Error searching users</div>';
    }
  });

  async function startNewChat(otherId, otherData) {
    const participants = [currentUser.uid, otherId].sort();
    const chatId = participants.join('_');
    
    try {
      const existingConv = await getDoc(doc(db, "conversations", chatId));
      
      if (existingConv.exists()) {
        const convData = existingConv.data();
        const otherUserId = convData.participants.find(p => p !== currentUser.uid);
        const realName = convData.participantNames?.[otherUserId] || await getUserDisplayName(otherUserId);
        const avatar = convData.participantAvatars?.[otherUserId] || otherData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(realName)}&background=0080FF&color=fff`;
        
        openChat(chatId, otherId, realName, avatar);
      } else {
        const currentUserName = navUserName.textContent;
        const otherUserName = otherData.name || otherData.displayName || 'User';
        
        await setDoc(doc(db, "conversations", chatId), {
          participants,
          participantNames: {
            [currentUser.uid]: currentUserName,
            [otherId]: otherUserName
          },
          participantAvatars: {
            [currentUser.uid]: navUserImg.src,
            [otherId]: otherData.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUserName)}&background=0080FF&color=fff`
          },
          updatedAt: serverTimestamp(),
          lastMessage: '',
          createdAt: serverTimestamp()
        });
        
        openChat(chatId, otherId, otherUserName, otherData.photoURL);
      }
      
      closeUserSearchModal();
      
    } catch (error) {
      console.error("Error starting new chat:", error);
      showError("Failed to start conversation");
    }
  }

  // === AUTHENTICATION ===
  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      try {
        const userDoc = await getDoc(doc(db, "users", user.uid));
        let photoURL = user.photoURL;
        let displayName = user.displayName;
        
        if (userDoc.exists()) {
          const userData = userDoc.data();
          if (userData.photoURL) photoURL = userData.photoURL;
          if (userData.name) displayName = userData.name;
        }
        
        navUserImg.src = photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName || 'User')}&background=0080FF&color=fff`;
        navUserName.textContent = displayName || 'User';
        
        // Load conversations
        loadConversations();
        setupIncomingCallListener();
        setupScrollHandling();
        
        // Load saved chat if exists
        const savedChatId = localStorage.getItem('last_active_chat');
        if (savedChatId) {
          // Check if conversation still exists
          try {
            const convDoc = await getDoc(doc(db, "conversations", savedChatId));
            if (convDoc.exists()) {
              const convData = convDoc.data();
              if (convData.participants.includes(currentUser.uid)) {
                const otherId = convData.participants.find(p => p !== currentUser.uid);
                const name = convData.participantNames?.[otherId] || await getUserDisplayName(otherId);
                const avatar = convData.participantAvatars?.[otherId] || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=0080FF&color=fff`;
                
                setTimeout(() => {
                  openChat(savedChatId, otherId, name, avatar);
                }, 500);
              }
            }
          } catch (error) {
            console.error("Error loading saved chat:", error);
          }
        }
        
      } catch (error) {
        console.error("Error loading user data:", error);
        navUserImg.src = `https://ui-avatars.com/api/?name=User&background=0080FF&color=fff`;
        navUserName.textContent = 'User';
      }
    }
  });

  // === EVENT LISTENERS ===
  window.toggleSidebar = () => {
    sidebar.classList.toggle('open');
    sidebarOverlay.classList.toggle('active');
  };

  // Voice recording
  voiceRecordBtn.addEventListener('click', () => {
    if (!isRecording) {
      startVoiceRecording();
    } else {
      stopVoiceRecording();
    }
  });

  voiceRecordCancelBtn.addEventListener('click', stopVoiceRecording);

  // Call buttons
  audioCallBtn.addEventListener('click', () => startCall('audio'));
  videoCallBtn.addEventListener('click', () => startCall('video'));

  // Message sending
  document.getElementById('sendButton').addEventListener('click', sendMessage);

  messageInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  messageInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 100) + 'px';
  });

  // Back button for mobile
  document.getElementById('backButton').addEventListener('click', () => {
    document.getElementById('chatArea').classList.remove('active');
  });

  // Dark mode toggle
  nightToggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('meet_dark_mode', document.body.classList.contains('dark-mode'));
  });

  // Load dark mode preference
  if (localStorage.getItem('meet_dark_mode') === 'true') {
    document.body.classList.add('dark-mode');
    document.getElementById('darkModeToggle').checked = true;
  }

  // Logout
  logoutBtn.addEventListener('click', () => {
    if (confirm('Are you sure you want to logout?')) {
      signOut(auth);
    }
  });

  // Clear all chats button
  clearAllChatsBtn.addEventListener('click', openDeleteAllChatsModal);

  // Close modals when clicking outside
  document.querySelectorAll('.modal-overlay').forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
      }
    });
  });

  // Close modals with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.style.display = 'none';
      });
      incomingCallModal.style.display = 'none';
      callInterface.style.display = 'none';
      
      if (isRecording) {
        stopVoiceRecording();
      }
    }
  });

  // Window resize handling
  window.addEventListener('resize', () => {
    if (window.innerWidth >= 768 && document.getElementById('chatArea').classList.contains('active')) {
      document.getElementById('chatArea').classList.remove('active');
    }
  });

  // Handle page visibility
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && currentChatId) {
      // Mark conversation as read
      localStorage.setItem(`meet_last_read_${currentChatId}`, Date.now());
    }
  });

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (unsubscribeMessages) unsubscribeMessages();
    if (unsubscribeConversations) unsubscribeConversations();
    if (unsubscribeUserProfiles) unsubscribeUserProfiles();
    if (unsubscribeFeedNotifications) unsubscribeFeedNotifications();
    
    if (isRecording) stopVoiceRecording();
    if (currentlyPlayingAudio) {
      currentlyPlayingAudio.audio.pause();
      clearInterval(audioPlayingInterval);
    }
    
    ringtone.pause();
    ringtone.currentTime = 0;
    
    if (peerConnection) peerConnection.close();
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
  });

</script>
</body>
</html>
