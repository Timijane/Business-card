<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Professional Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  /* ... (Previous CSS remains the same until the media query section) ... */

  /* FIXED: Mobile interface bottom fix - moved message input up */
  @media (max-width: 768px) {
    .main-content {
      padding: 0;
      height: 100vh;
      padding-bottom: env(safe-area-inset-bottom); /* Add safe area for iOS */
    }
    
    .navbar {
      width: 100% !important;
      max-width: 100% !important;
      border-radius: 0;
      margin-bottom: 0;
      padding: 12px 15px;
      height: 60px;
      min-height: 60px;
    }
    
    .chat-container { 
      border-radius: 0; 
      height: calc(100vh - 60px - env(safe-area-inset-bottom)); /* Adjust for safe area */
      margin: 0;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    .messages-container {
      padding-bottom: 80px; /* Add padding to prevent messages from being hidden */
    }
    
    .message-input-container {
      position: sticky;
      bottom: 0;
      background: var(--card-bg);
      padding: 10px 12px;
      border-top: 1px solid var(--border-color);
      z-index: 100;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      margin-top: auto; /* Push to bottom */
    }
    
    .message-input-wrapper {
      gap: 8px;
    }
    
    .message-input {
      min-height: 45px;
      height: 45px;
      padding: 10px 15px;
    }
    
    .send-button {
      width: 45px;
      height: 45px;
    }
    
    .input-action {
      width: 36px;
      height: 36px;
      padding: 8px;
    }
    
    /* Ensure conversation list doesn't overflow */
    .conversations-list {
      padding-bottom: 80px;
    }
    
    /* Voice recording inline adjustments */
    .voice-recording-active {
      margin-right: 5px;
      padding: 6px 10px;
    }
    
    /* Call interface adjustments */
    .call-controls {
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .call-btn {
      width: 60px;
      height: 60px;
      font-size: 20px;
    }
  }

  @media (max-width: 480px) {
    .main-content {
      padding-bottom: max(env(safe-area-inset-bottom), 10px);
    }
    
    .chat-container {
      height: calc(100vh - 55px - env(safe-area-inset-bottom));
    }
    
    .navbar {
      padding: 10px 12px;
      height: 55px;
      min-height: 55px;
    }
    
    .message-input-container {
      padding: 8px 10px;
    }
    
    .message-input {
      padding: 8px 12px;
      font-size: 14px;
    }
    
    /* Voice note adjustments for small screens */
    .voice-note-container {
      max-width: 180px;
      min-width: 140px;
      padding: 6px 10px;
    }
    
    .voice-note-waveform {
      height: 22px;
    }
    
    .voice-note-duration {
      font-size: 11px;
      min-width: 35px;
    }
    
    .voice-note-speed {
      font-size: 11px;
      padding: 1px 3px;
    }
  }

  /* ... (Rest of the CSS remains the same) ... */

  /* NEW: Read receipt styles */
  .read-receipt {
    display: inline-flex;
    align-items: center;
    margin-left: 5px;
    font-size: 12px;
  }
  
  .read-receipt i {
    margin-left: -3px;
  }
  
  .read-receipt .sent {
    color: var(--secondary-text);
  }
  
  .read-receipt .delivered {
    color: var(--secondary-text);
  }
  
  .read-receipt .read {
    color: #34B7F1; /* WhatsApp-like blue for read receipts */
  }
  
  /* NEW: Updated voice note waveform - simpler design */
  .voice-note-waveform-simple {
    flex: 1;
    height: 24px;
    position: relative;
    background: linear-gradient(90deg, 
      transparent 0%, 
      rgba(0,128,255,0.1) 50%, 
      transparent 100%);
    border-radius: 12px;
    overflow: hidden;
    min-width: 0;
  }
  
  .sent .voice-note-waveform-simple {
    background: linear-gradient(90deg, 
      transparent 0%, 
      rgba(255,255,255,0.2) 50%, 
      transparent 100%);
  }
  
  .waveform-progress-simple {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: linear-gradient(90deg, 
      rgba(0,128,255,0.3) 0%, 
      rgba(0,128,255,0.1) 100%);
    width: 0%;
    border-radius: 12px;
    transition: width 0.1s linear;
  }
  
  .sent .waveform-progress-simple {
    background: linear-gradient(90deg, 
      rgba(255,255,255,0.4) 0%, 
      rgba(255,255,255,0.2) 100%);
  }
  
  .waveform-line {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--primary);
    transform: translateY(-50%);
    opacity: 0.3;
  }
  
  .sent .waveform-line {
    background: white;
  }
  
  /* NEW: Voice note inline playback controls */
  .voice-note-playback-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .playback-speed-indicator {
    font-size: 11px;
    color: var(--secondary-text);
    padding: 2px 6px;
    background: rgba(0,0,0,0.05);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .sent .playback-speed-indicator {
    color: rgba(255,255,255,0.9);
    background: rgba(255,255,255,0.1);
  }
  
  .playback-speed-indicator:hover {
    background: rgba(0,0,0,0.1);
  }
  
  .sent .playback-speed-indicator:hover {
    background: rgba(255,255,255,0.2);
  }
</style>
</head>
<body>
<!-- HTML structure remains the same until the settings modal -->

<!-- Settings Modal - UPDATED: Added ringing time setting -->
<div class="settings-modal" id="settingsModal">
  <div class="settings-content">
    <div class="settings-header">
      <h3>Chat Personalization</h3>
      <button class="settings-close" onclick="closeSettingsModal()">&times;</button>
    </div>
    
    <div class="settings-section">
      <h4><i class="fas fa-font"></i> Typography</h4>
      <select id="fontSelect" class="font-select" onchange="changeFont()">
        <!-- Font options will be populated by JavaScript -->
      </select>
    </div>
      
    <div class="settings-section">
      <h4><i class="fas fa-palette"></i> Bubble Style</h4>
      <div class="color-grid" id="colorGrid">
        <!-- Color options will be populated by JavaScript -->
      </div>
    </div>

    <!-- NEW: Ringing Time Setting -->
    <div class="settings-section">
      <h4><i class="fas fa-bell"></i> Call Settings</h4>
      <div style="margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <span style="font-weight: 500;">Ringing Time</span>
          <span id="ringingTimeValue" style="color: var(--primary); font-weight: 600;">30 seconds</span>
        </div>
        <input type="range" id="ringingTimeSlider" min="5" max="60" step="5" value="30" 
               style="width: 100%; height: 6px; border-radius: 3px; background: var(--bg-color); outline: none;"
               oninput="updateRingingTime(this.value)">
        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--secondary-text); margin-top: 5px;">
          <span>5s</span>
          <span>60s</span>
        </div>
      </div>
    </div>

    <div class="settings-section">
      <h4><i class="fas fa-robot"></i> AI Features</h4>
      <div style="display:flex; justify-content:space-between; align-items:center; padding:10px 0;">
        <span style="font-weight:500;">Auto-Reply Suggestions</span>
        <input type="checkbox" id="aiToggle" style="transform:scale(1.5); accent-color:var(--primary);">
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getFirestore, collection, addDoc, updateDoc, doc, getDoc, getDocs, onSnapshot, serverTimestamp, query, orderBy, where, setDoc, limit, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDtqM_pMGIYkUgy0OWGsQbfS9MtYQhrgZM",
    authDomain: "meet-6e159.firebaseapp.com",
    projectId: "meet-6e159",
    storageBucket: "meet-6e159.firebasestorage.app",
    messagingSenderId: "252353608421",
    appId: "1:252353608421:web:6706056048e9a8f12db20c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Global state variables
  let currentUser = null;
  let currentChatId = null;
  let currentChatUser = null;
  let currentChatUserName = '';
  let currentChatUserAvatar = '';
  let unsubscribeMessages = null;
  let unsubscribeConversations = null;
  let unsubscribeUserProfiles = null;
  let unsubscribeFeedNotifications = null;
  let unsubscribeTypingStatus = null;
  let unsubscribeUserStatus = null;
  
  // Message state
  let replyToMsg = null;
  let editingMsgId = null;
  
  // UI state
  let currentConversationContext = null;

  // Wallpaper state
  let currentWallpaperPage = {};
  const wallpapersPerPage = 10;
  const wallpaperCategories = ['Nature', 'Abstract', 'Tech', 'Minimal', 'City', 'Space', 'Dark'];
  let tempWallpaper = null;

  // Notification state
  let unreadMessagesCount = 0;
  let unreadConversations = new Set();
  let userListeners = new Map();

  // Voice recording state
  let mediaRecorder = null;
  let audioChunks = [];
  let recordingTimer = null;
  let recordingSeconds = 0;
  let currentPlayingAudio = null;
  let audioPlayers = new Map();
  let isRecording = false;

  // Typing state
  let typingTimeout = null;
  let isTyping = false;

  // Voice call state - UPDATED: Added ringing time
  let peerConnection = null;
  let localStream = null;
  let remoteStream = null;
  let currentCallId = null;
  let currentCallType = null;
  let callTimerInterval = null;
  let callSeconds = 0;
  let isMuted = false;
  let isSpeaker = false;
  let ringingTime = 30; // Default 30 seconds
  let ringingTimeout = null;
  let isRinging = false;
  let iceServers = {
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
      { urls: "stun:stun2.l.google.com:19302" },
      { urls: "stun:stun3.l.google.com:19302" },
      { urls: "stun:stun4.l.google.com:19302" }
    ]
  };

  // DOM elements
  const messagesContainer = document.getElementById('messagesContainer');
  const messageInput = document.getElementById('messageInput');
  const emojiPicker = document.getElementById('emojiPicker');
  const sidebar = document.getElementById('mainSidebar');
  const sidebarOverlay = document.getElementById('sidebarOverlay');
  const navUserImg = document.getElementById('navUserImg');
  const navUserName = document.getElementById('navUserName');
  const feedNotificationBadge = document.getElementById('feedNotificationBadge');
  const voiceNoteBtn = document.getElementById('voiceNoteBtn');
  const chatUserStatus = document.getElementById('chatUserStatus');
  const typingIndicator = document.getElementById('typingIndicator');
  const voiceRecordingInline = document.getElementById('voiceRecordingInline');
  const recordingTimeInline = document.getElementById('recordingTimeInline');
  const stopRecordingBtnInline = document.getElementById('stopRecordingBtnInline');
  const cancelRecordingBtnInline = document.getElementById('cancelRecordingBtnInline');
  const voiceCallInterface = document.getElementById('voiceCallInterface');
  const incomingCallOverlay = document.getElementById('incomingCallOverlay');
  const callUserName = document.getElementById('callUserName');
  const callUserAvatar = document.getElementById('callUserAvatar');
  const callStatus = document.getElementById('callStatus');
  const callTimer = document.getElementById('callTimer');
  const callControls = document.getElementById('callControls');
  const incomingCallName = document.getElementById('incomingCallName');
  const incomingCallAvatar = document.getElementById('incomingCallAvatar');

  // === UTILITY FUNCTIONS ===

  // ... (Previous utility functions remain the same) ...

  // === UPDATED: Voice Note Functions - Inline WhatsApp style ===

  voiceNoteBtn.onclick = async () => {
    if (!isRecording) {
      startInlineRecording();
    } else {
      stopInlineRecording();
    }
  };

  async function startInlineRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];

      mediaRecorder.ondataavailable = event => {
        audioChunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        // We'll handle the blob when sending
      };

      mediaRecorder.start();
      isRecording = true;
      
      // Update UI
      voiceNoteBtn.innerHTML = '<i class="fas fa-stop"></i>';
      voiceNoteBtn.style.color = 'var(--error)';
      voiceRecordingInline.style.display = 'flex';
      
      // Start timer
      recordingSeconds = 0;
      recordingTimer = setInterval(() => {
        recordingSeconds++;
        const minutes = Math.floor(recordingSeconds / 60).toString().padStart(2, '0');
        const seconds = (recordingSeconds % 60).toString().padStart(2, '0');
        recordingTimeInline.textContent = `${minutes}:${seconds}`;
      }, 1000);
      
    } catch (error) {
      console.error("Error starting recording:", error);
      showError("Microphone access denied. Please allow microphone access to record voice notes.");
    }
  }

  function stopInlineRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      clearInterval(recordingTimer);
      
      // Stop all tracks
      mediaRecorder.stream.getTracks().forEach(track => track.stop());
      
      // Reset UI
      voiceNoteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
      voiceNoteBtn.style.color = '';
      voiceRecordingInline.style.display = 'none';
      isRecording = false;
      
      // Send voice note
      if (audioChunks.length > 0) {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        uploadVoiceNote(audioBlob);
      }
    }
  }

  stopRecordingBtnInline.onclick = () => {
    stopInlineRecording();
  };

  cancelRecordingBtnInline.onclick = () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      clearInterval(recordingTimer);
      
      // Stop all tracks
      mediaRecorder.stream.getTracks().forEach(track => track.stop());
      
      // Reset UI
      voiceNoteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
      voiceNoteBtn.style.color = '';
      voiceRecordingInline.style.display = 'none';
      isRecording = false;
      audioChunks = [];
    }
  };

  async function uploadVoiceNote(audioBlob) {
    if (!currentChatId) return;
    
    const tempId = 'temp-voice-' + Date.now();
    const optimisticMsg = {
      mediaUrl: URL.createObjectURL(audioBlob),
      mediaType: 'audio',
      text: "",
      senderId: currentUser.uid,
      timestamp: null,
      isUploading: true,
      isOptimistic: true,
      duration: recordingSeconds
    };
    
    const msgElement = renderMessageHTML(optimisticMsg, true, tempId);
    messagesContainer.appendChild(msgElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    const formData = new FormData();
    formData.append('file', audioBlob);
    formData.append('upload_preset', 'Meet_video');
    formData.append('resource_type', 'auto');

    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dcwof2ngn/upload`, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error('Upload failed');
      }
      
      const data = await response.json();
      
      if (data.secure_url) {
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          mediaUrl: data.secure_url,
          mediaType: 'audio',
          text: "",
          senderId: currentUser.uid,
          timestamp: serverTimestamp(),
          duration: recordingSeconds
        });
        
        const tempElement = document.getElementById(tempId);
        if (tempElement) tempElement.remove();
        
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: 'Voice note',
          updatedAt: serverTimestamp()
        });
      }
    } catch (error) {
      console.error('Voice note upload error:', error);
      
      const tempElement = document.getElementById(tempId);
      if (tempElement) tempElement.remove();
      
      showError("Failed to send voice note. Please try again.");
    }
  }

  // UPDATED: Voice note playback with WhatsApp-like simple waveform
  function createVoiceNotePlayer(audioUrl, duration, isMe, messageId) {
    const player = document.createElement('div');
    player.className = 'voice-note-container';
    player.id = `voice-player-${messageId}`;
    
    player.innerHTML = `
      <button class="voice-note-play-btn" onclick="toggleVoicePlayback('${messageId}', '${audioUrl}', ${isMe})">
        <i class="fas fa-play"></i>
      </button>
      <div class="voice-note-waveform-simple">
        <div class="waveform-progress-simple" id="waveform-progress-${messageId}"></div>
        <div class="waveform-line"></div>
      </div>
      <div class="voice-note-playback-controls">
        <div class="voice-note-duration" id="duration-${messageId}">${formatDuration(duration)}</div>
        <div class="playback-speed-indicator" onclick="changePlaybackSpeedInline('${messageId}')" id="speed-indicator-${messageId}">
          1x
        </div>
      </div>
    `;
    
    return player;
  }

  function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  window.toggleVoicePlayback = async function(messageId, audioUrl, isMe) {
    const playBtn = document.querySelector(`#voice-player-${messageId} .voice-note-play-btn i`);
    const waveformProgress = document.getElementById(`waveform-progress-${messageId}`);
    const durationDisplay = document.getElementById(`duration-${messageId}`);
    
    // Stop any currently playing audio
    if (currentPlayingAudio && currentPlayingAudio.messageId !== messageId) {
      currentPlayingAudio.audio.pause();
      const oldPlayBtn = document.querySelector(`#voice-player-${currentPlayingAudio.messageId} .voice-note-play-btn i`);
      if (oldPlayBtn) {
        oldPlayBtn.className = 'fas fa-play';
      }
      const oldWaveform = document.getElementById(`waveform-progress-${currentPlayingAudio.messageId}`);
      if (oldWaveform) {
        oldWaveform.style.width = '0%';
      }
    }
    
    if (!audioPlayers.has(messageId)) {
      const audio = new Audio(audioUrl);
      audioPlayers.set(messageId, audio);
      
      audio.addEventListener('timeupdate', () => {
        if (audio.duration) {
          const progress = (audio.currentTime / audio.duration) * 100;
          if (waveformProgress) {
            waveformProgress.style.width = `${progress}%`;
          }
          
          // Update duration display
          if (durationDisplay) {
            const remaining = audio.duration - audio.currentTime;
            durationDisplay.textContent = formatDuration(remaining);
          }
        }
      });
      
      audio.addEventListener('ended', () => {
        if (playBtn) {
          playBtn.className = 'fas fa-play';
        }
        if (waveformProgress) {
          waveformProgress.style.width = '0%';
        }
        if (durationDisplay) {
          durationDisplay.textContent = formatDuration(audio.duration);
        }
        currentPlayingAudio = null;
      });
    }
    
    const audio = audioPlayers.get(messageId);
    
    if (audio.paused) {
      // Set playback speed from indicator
      const speedIndicator = document.getElementById(`speed-indicator-${messageId}`);
      if (speedIndicator) {
        const speedText = speedIndicator.textContent;
        const speed = parseFloat(speedText.replace('x', ''));
        audio.playbackRate = speed;
      }
      
      await audio.play();
      playBtn.className = 'fas fa-pause';
      currentPlayingAudio = { audio, messageId };
    } else {
      audio.pause();
      playBtn.className = 'fas fa-play';
      currentPlayingAudio = null;
    }
  };

  // UPDATED: WhatsApp-like speed change
  window.changePlaybackSpeedInline = function(messageId) {
    const speedIndicator = document.getElementById(`speed-indicator-${messageId}`);
    if (!speedIndicator) return;
    
    const currentSpeedText = speedIndicator.textContent;
    const currentSpeed = parseFloat(currentSpeedText.replace('x', ''));
    let newSpeed;
    
    // Cycle through speeds: 1x → 1.5x → 2x → 0.5x → 1x
    if (currentSpeed === 1) newSpeed = 1.5;
    else if (currentSpeed === 1.5) newSpeed = 2;
    else if (currentSpeed === 2) newSpeed = 0.5;
    else newSpeed = 1;
    
    speedIndicator.textContent = `${newSpeed}x`;
    
    // Update audio playback rate if currently playing
    if (audioPlayers.has(messageId)) {
      const audio = audioPlayers.get(messageId);
      audio.playbackRate = newSpeed;
    }
  };

  // === UPDATED: Voice Call Functions with Real Implementation ===

  async function startVoiceCall() {
    if (!currentChatId || !currentChatUser) {
      showError("Please select a conversation first");
      return;
    }

    try {
      // Get user media for audio
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false
      });

      // Create peer connection
      peerConnection = new RTCPeerConnection(iceServers);

      // Add local tracks
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Create call document
      const callRef = doc(collection(db, "calls"));
      await setDoc(callRef, {
        callerId: currentUser.uid,
        receiverId: currentChatUser,
        type: "audio",
        status: "calling",
        createdAt: serverTimestamp(),
        ringing: true
      });

      currentCallId = callRef.id;
      currentCallType = "outgoing";

      // Create offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await updateDoc(callRef, {
        offer: {
          type: offer.type,
          sdp: offer.sdp
        }
      });

      // Set up ICE candidate handling
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate) {
          await addDoc(
            collection(db, "calls", currentCallId, "callerCandidates"),
            event.candidate.toJSON()
          );
        }
      };

      // Set up remote stream handling
      remoteStream = new MediaStream();
      peerConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
      };

      // Listen for answer
      onSnapshot(callRef, async (snapshot) => {
        const data = snapshot.data();
        if (!data) return;

        if (data.answer && !peerConnection.currentRemoteDescription) {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(data.answer)
          );
        }

        if (data.status === "connected") {
          stopRinging();
          showCallInterface("connected");
          startCallTimer();
        }

        if (data.status === "ended" || data.status === "declined") {
          endCall();
        }
      });

      // Listen for callee candidates
      onSnapshot(
        collection(db, "calls", currentCallId, "calleeCandidates"),
        (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidate = new RTCIceCandidate(change.doc.data());
              await peerConnection.addIceCandidate(candidate);
            }
          });
        }
      );

      // Set up connection state change handler
      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "disconnected" ||
            peerConnection.connectionState === "failed" ||
            peerConnection.connectionState === "closed") {
          endCall();
        }
      };

      // Show calling interface with ringing
      showCallInterface("calling");
      startRinging(true); // Caller hears ringing tone

    } catch (error) {
      console.error("Error starting voice call:", error);
      showError("Failed to start voice call. Please try again.");
      cleanupCall();
    }
  }

  function showCallInterface(status) {
    voiceCallInterface.style.display = 'flex';
    callUserName.textContent = currentChatUserName;
    callUserAvatar.src = currentChatUserAvatar;
    
    // Update controls based on status
    callControls.innerHTML = '';
    
    if (status === "calling") {
      callStatus.textContent = "Calling...";
      callControls.innerHTML = `
        <button class="call-btn end" onclick="endCall()"><i class="fas fa-phone-slash"></i></button>
      `;
      // Add ringing animation
      callStatus.classList.add('ringing-animation');
    } else if (status === "ringing") {
      callStatus.textContent = "Ringing...";
      callControls.innerHTML = `
        <button class="call-btn decline" onclick="declineCall()"><i class="fas fa-phone-slash"></i></button>
        <button class="call-btn accept" onclick="acceptCall()"><i class="fas fa-phone"></i></button>
      `;
      callStatus.classList.add('ringing-animation');
    } else if (status === "connected") {
      callStatus.textContent = "Connected";
      callStatus.classList.remove('ringing-animation');
      callControls.innerHTML = `
        <button class="call-btn mute" onclick="toggleMute()">
          <i class="fas ${isMuted ? 'fa-microphone-slash' : 'fa-microphone'}"></i>
        </button>
        <button class="call-btn speaker" onclick="toggleSpeaker()">
          <i class="fas ${isSpeaker ? 'fa-volume-up' : 'fa-volume-off'}"></i>
        </button>
        <button class="call-btn end" onclick="endCall()"><i class="fas fa-phone-slash"></i></button>
      `;
    }
  }

  function startRinging(isCaller = false) {
    isRinging = true;
    
    // Create ringing audio
    const ringingAudio = new Audio();
    ringingAudio.loop = true;
    
    // Different tones for caller and receiver
    if (isCaller) {
      // Caller hears ringback tone
      ringingAudio.src = "data:audio/wav;base64,UklGRnoCAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUYKAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg";
    } else {
      // Receiver hears ringing tone
      ringingAudio.src = "data:audio/wav;base64,UklGRnoCAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUYKAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg";
    }
    
    ringingAudio.play().catch(e => console.log("Audio play failed:", e));
    
    // Stop ringing after configured time
    ringingTimeout = setTimeout(() => {
      if (isRinging) {
        stopRinging();
        if (currentCallType === "outgoing") {
          showError("Call timed out. No answer.");
          endCall();
        }
      }
    }, ringingTime * 1000);
    
    // Store reference to stop later
    window.currentRingingAudio = ringingAudio;
  }

  function stopRinging() {
    isRinging = false;
    if (ringingTimeout) {
      clearTimeout(ringingTimeout);
      ringingTimeout = null;
    }
    if (window.currentRingingAudio) {
      window.currentRingingAudio.pause();
      window.currentRingingAudio.currentTime = 0;
      window.currentRingingAudio = null;
    }
    callStatus.classList.remove('ringing-animation');
  }

  function startCallTimer() {
    callSeconds = 0;
    clearInterval(callTimerInterval);
    callTimerInterval = setInterval(() => {
      callSeconds++;
      const minutes = Math.floor(callSeconds / 60).toString().padStart(2, '0');
      const seconds = (callSeconds % 60).toString().padStart(2, '0');
      callTimer.textContent = `${minutes}:${seconds}`;
    }, 1000);
  }

  function toggleMute() {
    if (localStream) {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        isMuted = !audioTrack.enabled;
        
        // Update UI
        const muteBtn = document.querySelector('.call-btn.mute i');
        if (muteBtn) {
          muteBtn.className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone';
        }
      }
    }
  }

  function toggleSpeaker() {
    isSpeaker = !isSpeaker;
    
    // Update UI
    const speakerBtn = document.querySelector('.call-btn.speaker i');
    if (speakerBtn) {
      speakerBtn.className = isSpeaker ? 'fas fa-volume-up' : 'fas fa-volume-off';
    }
    
    // In a real app, you would set the audio output device
  }

  async function endCall() {
    stopRinging();
    
    if (currentCallId) {
      try {
        await updateDoc(doc(db, "calls", currentCallId), {
          status: "ended",
          endedAt: serverTimestamp()
        });
      } catch (error) {
        console.error("Error updating call status:", error);
      }
    }
    
    cleanupCall();
  }

  function cleanupCall() {
    // Stop call timer
    clearInterval(callTimerInterval);
    
    // Close peer connection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    // Stop local stream
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    // Hide call interface
    voiceCallInterface.style.display = 'none';
    incomingCallOverlay.style.display = 'none';
    
    // Reset call state
    currentCallId = null;
    currentCallType = null;
    callSeconds = 0;
    callTimer.textContent = '00:00';
    isMuted = false;
    isSpeaker = false;
    isRinging = false;
  }

  // Listen for incoming calls
  function setupIncomingCallListener() {
    if (!currentUser) return;
    
    const q = query(
      collection(db, "calls"),
      where("receiverId", "==", currentUser.uid),
      where("status", "==", "calling")
    );
    
    onSnapshot(q, (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added") {
          const callData = change.doc.data();
          currentCallId = change.doc.id;
          currentCallType = "incoming";
          
          // Get caller info
          const callerName = await getUserDisplayName(callData.callerId);
          const callerAvatar = await getUserProfilePicture(callData.callerId);
          
          // Show incoming call interface
          incomingCallName.textContent = callerName;
          incomingCallAvatar.src = callerAvatar;
          incomingCallOverlay.style.display = 'flex';
          
          // Start ringing for incoming call
          startRinging(false);
          
          // Auto-decline after configured ringing time
          setTimeout(() => {
            if (incomingCallOverlay.style.display === 'flex') {
              declineCall();
            }
          }, ringingTime * 1000);
        }
      });
    });
  }

  async function acceptCall() {
    if (!currentCallId) return;
    
    try {
      // Get user media
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false
      });
      
      // Create peer connection
      peerConnection = new RTCPeerConnection(iceServers);
      
      // Add local tracks
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });
      
      // Get call data
      const callRef = doc(db, "calls", currentCallId);
      const callSnap = await getDoc(callRef);
      const callData = callSnap.data();
      
      // Set remote description
      await peerConnection.setRemoteDescription(
        new RTCSessionDescription(callData.offer)
      );
      
      // Create answer
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      
      // Update call with answer
      await updateDoc(callRef, {
        answer: {
          type: answer.type,
          sdp: answer.sdp
        },
        status: "connected",
        ringing: false
      });
      
      // Set up ICE candidate handling
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate) {
          await addDoc(
            collection(db, "calls", currentCallId, "calleeCandidates"),
            event.candidate.toJSON()
          );
        }
      };
      
      // Set up remote stream handling
      remoteStream = new MediaStream();
      peerConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => {
          remoteStream.addTrack(track);
        });
      };
      
      // Listen for caller candidates
      onSnapshot(
        collection(db, "calls", currentCallId, "callerCandidates"),
        (snapshot) => {
          snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
              const candidate = new RTCIceCandidate(change.doc.data());
              await peerConnection.addIceCandidate(candidate);
            }
          });
        }
      );
      
      // Set up connection state change handler
      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "disconnected" ||
            peerConnection.connectionState === "failed" ||
            peerConnection.connectionState === "closed") {
          endCall();
        }
      };
      
      // Show call interface
      stopRinging();
      showCallInterface("connected");
      startCallTimer();
      incomingCallOverlay.style.display = 'none';
      
    } catch (error) {
      console.error("Error accepting call:", error);
      showError("Failed to accept call. Please try again.");
      cleanupCall();
    }
  }

  async function declineCall() {
    stopRinging();
    
    if (currentCallId) {
      try {
        await updateDoc(doc(db, "calls", currentCallId), {
          status: "declined",
          endedAt: serverTimestamp(),
          ringing: false
        });
      } catch (error) {
        console.error("Error declining call:", error);
      }
    }
    cleanupCall();
  }

  // === NEW: Read Receipt System ===

  // Function to update message read status
  async function updateMessageReadStatus(messageId) {
    if (!currentChatId || !currentUser) return;
    
    try {
      await updateDoc(doc(db, "conversations", currentChatId, "messages", messageId), {
        readBy: {
          [currentUser.uid]: serverTimestamp()
        }
      });
    } catch (error) {
      console.error("Error updating read status:", error);
    }
  }

  // Function to mark all messages as read
  async function markAllMessagesAsRead() {
    if (!currentChatId || !currentUser || !currentChatUser) return;
    
    try {
      const messagesQuery = query(
        collection(db, "conversations", currentChatId, "messages"),
        where("senderId", "==", currentChatUser),
        where("readBy." + currentUser.uid, "==", null)
      );
      
      const snapshot = await getDocs(messagesQuery);
      const batch = writeBatch(db);
      
      snapshot.docs.forEach(doc => {
        batch.update(doc.ref, {
          [`readBy.${currentUser.uid}`]: serverTimestamp()
        });
      });
      
      if (snapshot.docs.length > 0) {
        await batch.commit();
      }
    } catch (error) {
      console.error("Error marking messages as read:", error);
    }
  }

  // Function to get read receipt HTML
  function getReadReceiptHTML(msg, isMe) {
    if (!isMe) return '';
    
    let receiptHTML = '<span class="read-receipt">';
    
    if (msg.readBy && msg.readBy[currentChatUser]) {
      // Message has been read by the other user
      receiptHTML += '<i class="fas fa-check-double read"></i><i class="fas fa-check-double read"></i>';
    } else if (msg.delivered) {
      // Message has been delivered but not read
      receiptHTML += '<i class="fas fa-check-double delivered"></i><i class="fas fa-check-double delivered"></i>';
    } else {
      // Message has been sent but not delivered
      receiptHTML += '<i class="fas fa-check sent"></i>';
    }
    
    receiptHTML += '</span>';
    return receiptHTML;
  }

  // Function to update delivery status
  async function updateDeliveryStatus(messageId) {
    if (!currentChatId || !currentChatUser) return;
    
    try {
      await updateDoc(doc(db, "conversations", currentChatId, "messages", messageId), {
        delivered: true,
        deliveredAt: serverTimestamp()
      });
    } catch (error) {
      console.error("Error updating delivery status:", error);
    }
  }

  // === MESSAGE RENDERING - UPDATED with Read Receipts ===

  function renderMessageHTML(msg, isMe, id) {
    const avatarSrc = isMe ? navUserImg.src : currentChatUserAvatar;
    let content = "";
    
    if (msg.replyTo) {
      content += `
        <div style="background:rgba(0,128,255,0.1); padding:8px 12px; border-left:3px solid var(--primary); border-radius:8px; font-size:12px; margin-bottom:8px; opacity:0.9;">
          <div style="font-weight:600; color:var(--primary); margin-bottom:2px;">${msg.replyTo.user}</div>
          <div style="color:var(--secondary-text);">${msg.replyTo.text.substring(0,50)}${msg.replyTo.text.length > 50 ? '...' : ''}</div>
        </div>
      `;
    }

    if (msg.mediaType === 'image') {
      content += `
        <div style="position:relative;">
          <img src="${msg.mediaUrl}" class="message-img" onerror="this.src='https://via.placeholder.com/200?text=Failed+to+load'" loading="lazy">
          ${msg.isUploading ? '<div class="upload-overlay"><div class="loading-spinner"></div></div>' : ''}
        </div>
      `;
    } else if (msg.mediaType === 'video') {
      content += `
        <div style="position:relative;">
          <video src="${msg.mediaUrl}" controls class="message-video" preload="metadata"></video>
          ${msg.isUploading ? '<div class="upload-overlay"><div class="loading-spinner"></div></div>' : ''}
        </div>
      `;
    } else if (msg.mediaType === 'audio') {
      // Voice note player with new simple waveform
      const voicePlayer = createVoiceNotePlayer(msg.mediaUrl, msg.duration || 0, isMe, id);
      content += voicePlayer.outerHTML;
    }
    
    if (msg.text) {
      const formattedText = msg.text
        .replace(/\n/g, '<br>')
        .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color:inherit; text-decoration:underline;">$1</a>');
      content += `<div style="word-break: break-word;">${formattedText}</div>`;
    }

    const div = document.createElement('div');
    div.className = `message-wrapper ${isMe ? 'sent' : 'received'} ${msg.isOptimistic ? 'optimistic-msg' : ''}`;
    div.id = id;
    
    const ts = msg.timestamp ? msg.timestamp.seconds : Date.now() / 1000;
    div.setAttribute('data-timestamp', ts);

    const optionsHtml = `
      <button class="msg-options-btn" onclick="toggleMsgOptions('${id}')" title="Message options">
        <i class="fas fa-chevron-down"></i>
      </button>
      <div class="msg-options-menu" id="options-${id}">
        <div class="msg-option-item" onclick="handleReply('${id}', '${(msg.text || 'Media').replace(/'/g, "\\'")}', '${isMe ? 'You' : currentChatUserName}')">
          <i class="fas fa-reply"></i> Reply
        </div>
        <div class="msg-option-item" onclick="handleCopy('${(msg.text || '').replace(/'/g, "\\'")}')">
          <i class="fas fa-copy"></i> Copy Text
        </div>
        ${isMe ? `
          <div class="msg-option-item" onclick="handleEdit('${id}', '${(msg.text || '').replace(/'/g, "\\'")}')">
            <i class="fas fa-edit"></i> Edit
          </div>
        ` : ''}
        ${isMe ? `
          <div class="msg-option-item delete" onclick="handleDelete('${id}')">
            <i class="fas fa-trash-alt"></i> Delete
          </div>
        ` : ''}
      </div>
    `;

    let timeString = '';
    if (msg.timestamp) {
      const msgTime = new Date(msg.timestamp.seconds * 1000);
      timeString = msgTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else {
      timeString = '<i class="far fa-clock" title="Sending..."></i>';
    }

    // Add read receipt for sent messages
    const readReceiptHTML = getReadReceiptHTML(msg, isMe);

    div.innerHTML = `
      ${isMe ? optionsHtml : ''}
      <img src="${avatarSrc}" class="message-avatar-small" alt="${isMe ? 'You' : currentChatUserName}">
      <div class="message-bubble">
        ${content}
        <div class="message-time">
          ${msg.isEdited ? '<i class="fas fa-pencil-alt" style="font-size:8px; margin-right:4px;" title="Edited"></i>' : ''}   
          ${timeString}
          ${readReceiptHTML}
        </div>
      </div>
      ${!isMe ? optionsHtml : ''}
    `;
    
    return div;
  }

  // === SETTINGS - UPDATED with Ringing Time ===

  // Function to update ringing time
  window.updateRingingTime = function(value) {
    ringingTime = parseInt(value);
    document.getElementById('ringingTimeValue').textContent = value + ' seconds';
    localStorage.setItem('meet_ringing_time', value);
  };

  // Load saved ringing time
  function loadRingingTime() {
    const savedRingingTime = localStorage.getItem('meet_ringing_time');
    if (savedRingingTime) {
      ringingTime = parseInt(savedRingingTime);
      document.getElementById('ringingTimeSlider').value = ringingTime;
      document.getElementById('ringingTimeValue').textContent = ringingTime + ' seconds';
    }
  }

  // ... (Rest of the code remains the same with the following additions) ...

  // In the onAuthStateChanged function, add:
  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      // Load ringing time setting
      loadRingingTime();
      
      // ... (rest of the auth code) ...
    }
  });

  // In the loadMessages function, update to mark messages as read when viewed
  function loadMessages(chatId) {
    if (unsubscribeMessages) unsubscribeMessages();
    messagesContainer.innerHTML = '';
    
    const loadingDiv = showLoading(messagesContainer, 'Loading messages...');
    
    const q = query(
      collection(db, "conversations", chatId, "messages"),
      orderBy("timestamp", "asc")
    );
    
    unsubscribeMessages = onSnapshot(q, (snapshot) => {
      if (loadingDiv.parentNode) {
        loadingDiv.remove();
      }
      
      let lastHeader = null;
      let hasMessages = false;
      
      snapshot.docChanges().forEach(async (change) => {
        const msg = change.doc.data();
        const isMe = msg.senderId === currentUser.uid;

        if (change.type === "added") {
          hasMessages = true;
          
          const existingMsg = document.getElementById(change.doc.id);
          if (existingMsg && existingMsg.classList.contains('optimistic-msg')) {
            existingMsg.remove();
          }

          const currentHeader = formatDateHeader(msg.timestamp);
          if (currentHeader && currentHeader !== lastHeader) {
            const div = document.createElement('div');
            div.className = 'date-divider';
            div.innerHTML = `<span>${currentHeader}</span>`;
            messagesContainer.appendChild(div);
            lastHeader = currentHeader;
          }

          const div = renderMessageHTML(msg, isMe, change.doc.id);
          messagesContainer.appendChild(div);
          
          // Update delivery status for messages sent by current user
          if (isMe && !msg.delivered) {
            await updateDeliveryStatus(change.doc.id);
          }
          
          // Mark received messages as read
          if (!isMe && (!msg.readBy || !msg.readBy[currentUser.uid])) {
            await updateMessageReadStatus(change.doc.id);
          }
        } else if (change.type === "modified") {
          const el = document.getElementById(change.doc.id);
          if (el) el.replaceWith(renderMessageHTML(msg, isMe, change.doc.id));
        } else if (change.type === "removed") {
          const el = document.getElementById(change.doc.id);
          if (el) el.remove();
        }
      });
      
      if (hasMessages) {
        setTimeout(() => {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }, 100);
      }
      
    }, (error) => {
      console.error("Error loading messages:", error);
      
      if (loadingDiv.parentNode) {
        loadingDiv.remove();
      }
      
      messagesContainer.innerHTML = `
        <div class="error-message">
          <i class="fas fa-exclamation-triangle"></i>
          <span>Failed to load messages</span>
          <button class="retry-btn" onclick="loadMessages('${chatId}')">Retry</button>
        </div>
      `;
    });
  }

  // Add CSS for ringing animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes ring {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .ringing-animation {
      animation: ring 1s infinite;
      color: var(--primary) !important;
    }
    
    .call-status.ringing-animation::after {
      content: ' 🔊';
    }
  `;
  document.head.appendChild(style);

</script>
</body>
</html>
