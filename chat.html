
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Professional Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --primary: #0080FF;
    --primary-dark: #0066CC;
    --bg-color: #f0f2f5;
    --card-bg: #fff;
    --text-color: #111;
    --secondary-text: #65676b;
    --border-color: #dddfe2;
    --error: #EF4444;
    --success: #10B981;
    --warning: #F59E0B;
    --app-height: 100dvh;
    --chat-font: 'Poppins', sans-serif;
    --sent-bubble-bg: #0080FF;
    --sent-text-color: #fff;
    --received-bubble-bg: #fff;
    --received-text-color: #111;
    --shadow-light: 0 2px 10px rgba(0,0,0,0.05);
    --shadow-medium: 0 4px 15px rgba(0,128,255,0.2);
    --shadow-heavy: 0 10px 40px rgba(0,0,0,0.2);
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: var(--chat-font);
    background: var(--bg-color);
    color: var(--text-color);
    height: var(--app-height);
    overflow: hidden;
  }

  .app-container {
    display: flex;
    height: var(--app-height);
  }

  /* Sidebar Styles */
  .sidebar {
    width: 260px;
    background: linear-gradient(180deg, var(--primary) 0%, var(--primary-dark) 100%);
    color: white;
    display: flex;
    flex-direction: column;
    position: fixed;
    height: var(--app-height);
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    box-shadow: var(--shadow-heavy);
  }

  .sidebar.active {
    transform: translateX(0);
  }

  .sidebar-header {
    padding: 25px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }

  .sidebar-header h2 {
    font-size: 28px;
    font-weight: 700;
  }

  .sidebar-menu {
    list-style: none;
    padding: 20px 0;
    flex: 1;
  }

  .sidebar-menu li {
    margin: 5px 0;
  }

  .sidebar-menu a {
    color: rgba(255,255,255,0.9);
    text-decoration: none;
    padding: 15px 25px;
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 16px;
    font-weight: 500;
    transition: all 0.2s ease;
    border-left: 4px solid transparent;
  }

  .sidebar-menu a:hover {
    background: rgba(255,255,255,0.1);
    color: white;
  }

  .sidebar-menu a.active {
    background: rgba(255,255,255,0.15);
    color: white;
    border-left-color: white;
  }

  .sidebar-menu i {
    font-size: 18px;
    width: 24px;
    text-align: center;
  }

  .sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 999;
    display: none;
    backdrop-filter: blur(3px);
  }

  /* Navbar Styles */
  .navbar {
    height: 70px;
    background: var(--card-bg);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 25px;
    box-shadow: var(--shadow-light);
    z-index: 100;
    position: relative;
  }

  .navbar-left, .navbar-right {
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .hamburger-btn {
    background: none;
    border: none;
    font-size: 22px;
    color: var(--text-color);
    cursor: pointer;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .hamburger-btn:hover {
    background: var(--bg-color);
  }

  .nav-user-img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid var(--primary);
  }

  .nav-user-name {
    font-weight: 500;
    font-size: 15px;
  }

  .btn {
    background: var(--bg-color);
    border: none;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-color);
    font-size: 18px;
    transition: all 0.2s ease;
  }

  .btn:hover {
    background: var(--primary);
    color: white;
    transform: translateY(-2px);
  }

  /* Main Content */
  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: var(--app-height);
  }

  /* Chat Container */
  .chat-container {
    flex: 1;
    display: flex;
    overflow: hidden;
  }

  /* Conversations Sidebar */
  .conversations-sidebar {
    width: 350px;
    background: var(--card-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .chat-header {
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--border-color);
  }

  .chat-header h3 {
    font-size: 20px;
    font-weight: 600;
  }

  .new-chat-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    border: none;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .new-chat-btn:hover {
    background: var(--primary-dark);
    transform: rotate(90deg);
  }

  .chat-search {
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color);
  }

  .chat-search input {
    width: 100%;
    padding: 12px 20px;
    border: 1px solid var(--border-color);
    border-radius: 25px;
    font-family: var(--chat-font);
    font-size: 14px;
    background: var(--bg-color);
    color: var(--text-color);
    outline: none;
    transition: all 0.2s ease;
  }

  .chat-search input:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(0,128,255,0.1);
  }

  .conversations-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
  }

  .conversation-item {
    display: flex;
    align-items: center;
    padding: 15px 20px;
    gap: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    border-bottom: 1px solid var(--border-color);
  }

  .conversation-item:hover {
    background: var(--bg-color);
  }

  .conversation-item.active {
    background: rgba(0,128,255,0.1);
    border-left: 4px solid var(--primary);
  }

  .conversation-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid var(--primary);
  }

  .conversation-info {
    flex: 1;
    min-width: 0;
  }

  .conversation-name {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .conversation-preview {
    font-size: 13px;
    color: var(--secondary-text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .conversation-meta {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 5px;
  }

  .conversation-time {
    font-size: 12px;
    color: var(--secondary-text);
  }

  .unread-badge {
    background: var(--primary);
    color: white;
    font-size: 12px;
    min-width: 20px;
    height: 20px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 6px;
  }

  /* Chat Area */
  .chat-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .empty-chat {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 40px;
    color: var(--secondary-text);
  }

  .empty-chat i {
    font-size: 80px;
    margin-bottom: 20px;
    color: var(--border-color);
  }

  .empty-chat h3 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text-color);
  }

  .empty-chat p {
    font-size: 15px;
    max-width: 400px;
    line-height: 1.6;
  }

  /* Chat Area Header */
  .chat-area-header {
    height: 70px;
    background: var(--card-bg);
    border-bottom: 1px solid var(--border-color);
    display: none;
    align-items: center;
    padding: 0 25px;
    gap: 15px;
  }

  .chat-user-info {
    flex: 1;
  }

  .chat-user-name {
    font-weight: 600;
    font-size: 17px;
    margin-bottom: 2px;
  }

  .chat-user-status {
    font-size: 13px;
    color: var(--secondary-text);
  }

  .chat-actions {
    display: flex;
    gap: 10px;
  }

  .chat-action-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--bg-color);
    border: none;
    color: var(--text-color);
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .chat-action-btn:hover {
    background: var(--primary);
    color: white;
  }

  /* Messages Container */
  .messages-container {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: none;
    flex-direction: column;
    gap: 10px;
    background: var(--bg-color);
    background-size: cover;
    background-position: center;
  }

  /* Message Bubbles */
  .message-bubble {
    max-width: 60%;
    padding: 12px 16px;
    border-radius: 18px;
    position: relative;
    word-wrap: break-word;
    line-height: 1.4;
  }

  .message-bubble.sent {
    background: var(--sent-bubble-bg);
    color: var(--sent-text-color);
    align-self: flex-end;
    border-bottom-right-radius: 4px;
  }

  .message-bubble.received {
    background: var(--received-bubble-bg);
    color: var(--received-text-color);
    align-self: flex-start;
    border-bottom-left-radius: 4px;
    box-shadow: var(--shadow-light);
  }

  .message-text {
    font-size: 15px;
  }

  .message-time {
    font-size: 11px;
    opacity: 0.7;
    text-align: right;
    margin-top: 5px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
  }

  .received .message-time {
    color: var(--secondary-text);
  }

  .message-status {
    font-size: 10px;
  }

  /* Image Message */
  .image-message {
    border-radius: 15px;
    overflow: hidden;
    max-width: 300px;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .image-message:hover {
    transform: scale(1.02);
  }

  .image-message img {
    width: 100%;
    height: auto;
    display: block;
  }

  /* Typing Indicator */
  .typing-indicator {
    padding: 15px 25px;
    background: var(--card-bg);
    border-top: 1px solid var(--border-color);
    display: none;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    color: var(--secondary-text);
  }

  .typing-indicator span:nth-child(2) {
    animation: typing 1.4s infinite;
    animation-delay: 0.2s;
  }

  .typing-indicator span:nth-child(3) {
    animation: typing 1.4s infinite;
    animation-delay: 0.4s;
  }

  .typing-indicator span:nth-child(4) {
    animation: typing 1.4s infinite;
    animation-delay: 0.6s;
  }

  @keyframes typing {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 1; }
  }

  /* Message Input */
  .message-input-container {
    background: var(--card-bg);
    border-top: 1px solid var(--border-color);
    padding: 15px 25px;
    display: none;
  }

  .reply-preview-bar {
    background: var(--bg-color);
    border-left: 4px solid var(--primary);
    padding: 10px 15px;
    border-radius: 10px;
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 15px;
  }

  .reply-preview-content {
    flex: 1;
  }

  .reply-name {
    font-weight: 600;
    font-size: 13px;
    color: var(--primary);
    display: block;
    margin-bottom: 2px;
  }

  .reply-text {
    font-size: 13px;
    color: var(--secondary-text);
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .writing-assist-bar {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
  }

  .assist-chip {
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    padding: 8px 15px;
    font-size: 13px;
    font-family: var(--chat-font);
    color: var(--text-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s ease;
  }

  .assist-chip:hover {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
  }

  .message-input-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 10px;
    background: var(--bg-color);
    border-radius: 25px;
    padding: 5px 5px 5px 20px;
  }

  .message-input-actions {
    display: flex;
    gap: 5px;
    margin-right: 5px;
  }

  .input-action {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: transparent;
    border: none;
    color: var(--secondary-text);
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .input-action:hover {
    background: rgba(0,128,255,0.1);
    color: var(--primary);
  }

  .magic-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white !important;
  }

  .magic-btn:hover {
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%) !important;
  }

  .message-input {
    flex: 1;
    border: none;
    background: transparent;
    font-family: var(--chat-font);
    font-size: 15px;
    color: var(--text-color);
    resize: none;
    max-height: 120px;
    min-height: 40px;
    padding: 10px 0;
    outline: none;
  }

  .send-button {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    border: none;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .send-button:hover {
    background: var(--primary-dark);
    transform: rotate(30deg);
  }

  /* Emoji Picker */
  .emoji-picker {
    position: absolute;
    bottom: 85px;
    left: 25px;
    width: 350px;
    height: 350px;
    background: var(--card-bg);
    border-radius: 15px;
    box-shadow: var(--shadow-heavy);
    display: none;
    flex-direction: column;
    overflow: hidden;
    z-index: 100;
  }

  .emoji-header {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .emoji-tab {
    padding: 8px 15px;
    border: none;
    background: var(--bg-color);
    border-radius: 10px;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .emoji-tab:hover {
    background: var(--primary);
    color: white;
  }

  .emoji-content {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 10px;
  }

  .emoji-item {
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.2s ease;
  }

  .emoji-item:hover {
    background: var(--bg-color);
    transform: scale(1.2);
  }

  /* Modals */
  .settings-modal,
  .user-search-overlay,
  .wallpaper-modal,
  .wallpaper-preview-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(5px);
    padding: 20px;
  }

  .modal-content {
    background: var(--card-bg);
    border-radius: 20px;
    max-width: 500px;
    width: 100%;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: var(--shadow-heavy);
  }

  .modal-header {
    padding: 25px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .modal-header h3 {
    font-size: 20px;
    font-weight: 600;
  }

  .modal-body {
    padding: 25px;
    overflow-y: auto;
    max-height: 60vh;
  }

  .modal-close {
    background: none;
    border: none;
    font-size: 24px;
    color: var(--secondary-text);
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .modal-close:hover {
    background: var(--bg-color);
    color: var(--text-color);
  }

  /* Settings Options */
  .settings-option {
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.2s ease;
  }

  .settings-option:hover {
    background: var(--bg-color);
  }

  .option-info {
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .option-icon {
    width: 40px;
    height: 40px;
    border-radius: 10px;
    background: var(--primary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
  }

  .option-text h4 {
    font-weight: 600;
    margin-bottom: 2px;
  }

  .option-text p {
    font-size: 13px;
    color: var(--secondary-text);
  }

  .option-switch {
    width: 50px;
    height: 26px;
    background: var(--border-color);
    border-radius: 13px;
    position: relative;
    cursor: pointer;
  }

  .option-switch.active {
    background: var(--success);
  }

  .option-switch::after {
    content: '';
    position: absolute;
    width: 22px;
    height: 22px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: transform 0.2s ease;
  }

  .option-switch.active::after {
    transform: translateX(24px);
  }

  /* Conversation Options Menu */
  .conversation-options-menu {
    position: fixed;
    background: var(--card-bg);
    border-radius: 15px;
    box-shadow: var(--shadow-heavy);
    min-width: 200px;
    z-index: 1000;
    display: none;
    overflow: hidden;
  }

  .msg-option-item {
    padding: 15px 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .msg-option-item:hover {
    background: var(--bg-color);
  }

  .msg-option-item i {
    width: 20px;
    text-align: center;
  }

  /* === WEBRTC CALL INTERFACE STYLES === */
  .call-interface {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    z-index: 3000;
    display: none;
    flex-direction: column;
  }

  .call-active .call-interface {
    display: flex;
  }

  .video-container {
    flex: 1;
    display: flex;
    position: relative;
    overflow: hidden;
  }

  .local-video-container {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 120px;
    height: 160px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    z-index: 10;
    border: 2px solid var(--primary);
  }

  .remote-video-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
    position: relative;
  }

  .video-element {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .local-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1); /* Mirror local video */
  }

  .remote-video-wrapper {
    position: relative;
    width: 90%;
    height: 90%;
    max-width: 1200px;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 40px rgba(0,128,255,0.3);
  }

  .call-controls {
    position: absolute;
    bottom: 30px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 20px;
    z-index: 20;
  }

  .call-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.2s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }

  .call-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
  }

  .end-call-btn {
    background: var(--error);
    color: white;
  }

  .mute-btn {
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    color: white;
  }

  .mute-btn.active {
    background: var(--error);
  }

  .video-toggle-btn {
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    color: white;
  }

  .video-toggle-btn.active {
    background: var(--error);
  }

  .call-info {
    position: absolute;
    top: 30px;
    left: 30px;
    color: white;
    z-index: 10;
    backdrop-filter: blur(10px);
    padding: 15px 25px;
    border-radius: 12px;
    background: rgba(0,0,0,0.5);
  }

  .caller-name {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 5px;
  }

  .call-status {
    font-size: 14px;
    opacity: 0.8;
  }

  /* Shy chat overlay during call */
  .shy-chat-overlay {
    position: absolute;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 12px 20px;
    border-radius: 12px;
    max-width: 80%;
    backdrop-filter: blur(10px);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 15;
    text-align: center;
    font-size: 16px;
    border: 1px solid rgba(255,255,255,0.2);
  }

  .shy-chat-overlay.visible {
    opacity: 1;
  }

  /* Call incoming modal */
  .incoming-call-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 4000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
  }

  .incoming-call-modal.active {
    display: flex;
  }

  .call-modal-content {
    background: var(--card-bg);
    border-radius: 24px;
    padding: 40px;
    text-align: center;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    animation: modalSlideIn 0.3s ease;
  }

  .caller-avatar {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    margin: 0 auto 20px;
    border: 4px solid var(--primary);
    object-fit: cover;
  }

  .caller-info h3 {
    font-size: 24px;
    margin-bottom: 10px;
    color: var(--text-color);
  }

  .call-type {
    color: var(--secondary-text);
    margin-bottom: 30px;
    font-size: 16px;
  }

  .call-actions {
    display: flex;
    gap: 20px;
    justify-content: center;
  }

  .accept-call-btn {
    background: var(--success);
    color: white;
    border: none;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 24px;
    transition: all 0.2s ease;
  }

  .decline-call-btn {
    background: var(--error);
    color: white;
    border: none;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 24px;
    transition: all 0.2s ease;
  }

  .accept-call-btn:hover,
  .decline-call-btn:hover {
    transform: scale(1.1);
  }

  /* Voice message recording */
  .voice-message-container {
    display: none;
    position: absolute;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--card-bg);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    z-index: 100;
    min-width: 300px;
    text-align: center;
    border: 1px solid var(--border-color);
  }

  .voice-message-container.recording {
    display: block;
  }

  .recording-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-bottom: 15px;
  }

  .recording-dot {
    width: 12px;
    height: 12px;
    background: var(--error);
    border-radius: 50%;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .recording-timer {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-color);
  }

  .recording-controls {
    display: flex;
    gap: 15px;
    justify-content: center;
  }

  .stop-recording-btn {
    background: var(--error);
    color: white;
    border: none;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.2s ease;
  }

  .cancel-recording-btn {
    background: var(--secondary-text);
    color: white;
    border: none;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.2s ease;
  }

  .stop-recording-btn:hover,
  .cancel-recording-btn:hover {
    transform: scale(1.1);
  }

  /* Audio message styling */
  .audio-message {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 15px;
    background: var(--bg-color);
    border-radius: 20px;
    max-width: 250px;
  }

  .audio-message.sent {
    background: var(--primary);
    color: white;
  }

  .audio-controls {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .play-pause-btn {
    background: none;
    border: none;
    color: inherit;
    cursor: pointer;
    font-size: 18px;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
  }

  .play-pause-btn:hover {
    background: rgba(255,255,255,0.1);
  }

  .audio-progress {
    flex: 1;
    height: 4px;
    background: rgba(255,255,255,0.3);
    border-radius: 2px;
    overflow: hidden;
  }

  .audio-progress-bar {
    height: 100%;
    background: white;
    width: 0%;
    transition: width 0.1s linear;
  }

  .audio-duration {
    font-size: 12px;
    opacity: 0.8;
    min-width: 40px;
  }

  /* Call shy chat input */
  .call-chat-input {
    position: absolute;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 10px;
    z-index: 20;
  }

  .call-active .call-chat-input {
    display: flex;
  }

  .call-chat-input input {
    padding: 12px 20px;
    border-radius: 25px;
    border: none;
    background: rgba(255,255,255,0.1);
    color: white;
    backdrop-filter: blur(10px);
    width: 300px;
    font-size: 14px;
    outline: none;
  }

  .call-chat-input input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  .call-chat-send-btn {
    background: var(--primary);
    color: white;
    border: none;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.2s ease;
  }

  .call-chat-send-btn:hover {
    background: var(--primary-dark);
    transform: scale(1.1);
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .conversations-sidebar {
      width: 100%;
      position: absolute;
      z-index: 10;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
    }
    
    .conversations-sidebar.active {
      transform: translateX(0);
    }
    
    .sidebar {
      width: 280px;
    }
    
    .local-video-container {
      width: 80px;
      height: 120px;
      top: 10px;
      right: 10px;
    }

    .call-btn {
      width: 50px;
      height: 50px;
      font-size: 18px;
    }

    .call-info {
      top: 15px;
      left: 15px;
      padding: 10px 15px;
    }

    .caller-name {
      font-size: 18px;
    }

    .call-chat-input {
      width: 90%;
      bottom: 100px;
    }

    .call-chat-input input {
      width: 100%;
    }

    .remote-video-wrapper {
      width: 100%;
      height: 100%;
      border-radius: 0;
    }
    
    .emoji-picker {
      width: 300px;
      left: 50%;
      transform: translateX(-50%);
    }
  }

  @media (max-width: 480px) {
    .navbar {
      padding: 0 15px;
    }
    
    .chat-area-header {
      padding: 0 15px;
    }
    
    .message-input-container {
      padding: 15px;
    }
    
    .call-modal-content {
      padding: 30px 20px;
    }
    
    .voice-message-container {
      min-width: 250px;
    }
  }

  /* Animation */
  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Dark Mode */
  body.dark-mode {
    --bg-color: #0f172a;
    --card-bg: #1e293b;
    --text-color: #f1f5f9;
    --secondary-text: #94a3b8;
    --border-color: #334155;
    --received-bubble-bg: #334155;
    --received-text-color: #f1f5f9;
  }

  /* Loading Spinner */
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(0,128,255,0.3);
    border-radius: 50%;
    border-top-color: var(--primary);
    animation: spin 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>
</head>
<body>
<div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
<div class="app-container">
  <!-- Sidebar -->
  <div class="sidebar" id="mainSidebar">
    <div class="sidebar-header">
      <h2>MEET</h2>
      <button onclick="toggleSidebar()" style="background:none; border:none; color:white; font-size:24px; padding:8px; border-radius:50%; transition:all 0.2s ease;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'"><i class="fas fa-times"></i></button>
    </div>
    <ul class="sidebar-menu">
      <li><a href="feed.html"><i class="fas fa-home"></i> <span>Feed</span></a></li>
      <li><a href="profile.html"><i class="fas fa-user"></i> <span>Profile</span></a></li>
      <li><a href="chat.html" class="active"><i class="fas fa-comment"></i> <span>Chat</span></a></li>
      <li><a href="conference.html"><i class="fas fa-video"></i> <span>Conference</span></a></li>
      <li><a href="meetrader.html"><i class="fas fa-store"></i> <span>Meetrader</span></a></li>
    </ul>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Navbar -->
    <div class="navbar">
      <div class="navbar-left">
        <button class="hamburger-btn" onclick="toggleSidebar()"><i class="fas fa-bars"></i></button>
        <h2 style="font-weight:600; font-size:22px;">Chat</h2>
      </div>
      <div class="navbar-right">
        <img src="https://via.placeholder.com/40" id="navUserImg" class="nav-user-img" alt="Me">
        <span id="navUserName" class="nav-user-name"></span>
        <button class="btn" id="nightToggleBtn"><i class="fas fa-moon"></i></button>
        <button class="btn" id="logoutBtn"><i class="fas fa-sign-out-alt"></i></button>
      </div>
    </div>

    <!-- Chat Container -->
    <div class="chat-container">
      <!-- Conversations sidebar -->
      <div class="conversations-sidebar" id="conversationsSidebar">
        <div class="chat-header">
          <h3>Messages</h3>
          <button class="new-chat-btn" onclick="openUserSearchOverlay()"><i class="fas fa-plus"></i></button>
        </div>
        <div class="chat-search">
          <input type="text" placeholder="Search chats..." id="chatSearch">
        </div>
        <div class="conversations-list" id="conversationsList">
          <!-- Conversations will be loaded here -->
        </div>
      </div>

      <!-- Chat Area -->
      <div class="chat-area" id="chatArea">
        <!-- Empty chat state -->
        <div id="emptyChat" class="empty-chat">
          <i class="far fa-comments"></i>
          <h3>Select a conversation</h3>
          <p>Choose a contact to start chatting and stay connected with your network</p>
        </div>

        <!-- Chat header with call buttons -->
        <div class="chat-area-header" id="chatHeader" style="display: none;">
          <button class="chat-action-btn" id="backButton" style="color:var(--text-color); margin-right:5px;"><i class="fas fa-arrow-left"></i></button>
          <img src="" id="currentChatAvatar" class="conversation-avatar">
          <div class="chat-user-info">
            <div class="chat-user-name" id="chatUserName">User</div>
            <div class="chat-user-status">Last seen recently</div>
          </div>
          <div class="chat-actions">
            <button class="chat-action-btn" onclick="openSettingsModal()" title="Chat Settings"><i class="fas fa-sliders-h"></i></button>
            <button class="chat-action-btn" onclick="startVoiceCall()" title="Voice Call"><i class="fas fa-phone-alt"></i></button>
            <button class="chat-action-btn" onclick="startVideoCall()" title="Video Call"><i class="fas fa-video"></i></button>
            <button class="chat-action-btn" onclick="openWallpaperModal()" title="Wallpaper"><i class="fas fa-image"></i></button>
            <button class="chat-action-btn" id="voiceMessageBtn" title="Voice Message"><i class="fas fa-microphone"></i></button>
          </div>
        </div>

        <!-- Messages container -->
        <div class="messages-container" id="messagesContainer" style="display: none;"></div>

        <!-- Typing indicator -->
        <div class="typing-indicator" id="typingIndicator">
          <span id="typingUserName">User</span> is typing <span>.</span><span>.</span><span>.</span>
        </div>

        <!-- Message input container with voice message button -->
        <div class="message-input-container" id="messageInputContainer" style="display: none;">
          <!-- Reply preview -->
          <div class="reply-preview-bar" id="replyPreview">
            <div class="reply-preview-content">
              <span class="reply-name" id="replyName">Replying to User</span>
              <span class="reply-text" id="replyText">Message text...</span>
            </div>
            <button onclick="cancelReply()" style="background:none;border:none;cursor:pointer;font-size:20px;color:var(--secondary-text);padding:5px;border-radius:50%;transition:all 0.2s ease;" onmouseover="this.style.background='rgba(239,68,68,0.1)';this.style.color='var(--error)'" onmouseout="this.style.background='none';this.style.color='var(--secondary-text)'">&times;</button>
          </div>
          
          <!-- Writing assist -->
          <div class="writing-assist-bar" id="assistBar">
            <button class="assist-chip" onclick="applyWritingAssist('fix')"><i class="fas fa-spell-check"></i> Fix Grammar</button>
            <button class="assist-chip" onclick="applyWritingAssist('formal')"><i class="fas fa-user-tie"></i> Make Formal</button>
            <button class="assist-chip" onclick="applyWritingAssist('expand')"><i class="fas fa-expand-alt"></i> Expand Text</button>
          </div>

          <div class="message-input-wrapper">
            <div class="message-input-actions">
              <button class="input-action magic-btn" onclick="toggleAssistBar()" title="Writing Assistant"><i class="fas fa-magic"></i></button>
              <button class="input-action" onclick="toggleEmojiPicker()" title="Emoji"><i class="far fa-smile"></i></button>
              <input type="file" id="imageInputHidden" accept="image/*" style="display:none" onchange="uploadToCloudinary(this.files[0], 'image')">
              <input type="file" id="videoInputHidden" accept="video/*" style="display:none" onchange="uploadToCloudinary(this.files[0], 'video')">
              <button class="input-action" onclick="document.getElementById('imageInputHidden').click()" title="Send Image"><i class="fas fa-image"></i></button>
              <button class="input-action" onclick="document.getElementById('videoInputHidden').click()" title="Send Video"><i class="fas fa-video"></i></button>
              <button class="input-action" onclick="toggleVoiceMessage()" title="Voice Message" id="voiceMsgToggleBtn"><i class="fas fa-microphone"></i></button>
            </div>
            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1" spellcheck="true"></textarea>
            <button class="send-button" id="sendButton" title="Send Message"><i class="fas fa-paper-plane"></i></button>
          </div>
          
          <!-- Emoji picker -->
          <div class="emoji-picker" id="emojiPicker">
            <div class="emoji-header" id="emojiNav"></div>
            <div class="emoji-content" id="emojiContent"></div>
          </div>
        </div>

        <!-- Voice message recording UI -->
        <div class="voice-message-container" id="voiceMessageContainer">
          <div class="recording-indicator">
            <div class="recording-dot"></div>
            <div class="recording-timer" id="recordingTimer">00:00</div>
          </div>
          <div class="recording-controls">
            <button class="cancel-recording-btn" onclick="cancelVoiceRecording()">
              <i class="fas fa-times"></i>
            </button>
            <button class="stop-recording-btn" onclick="stopVoiceRecording()">
              <i class="fas fa-stop"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- WebRTC Call Interface -->
<div class="call-interface" id="callInterface">
  <div class="video-container">
    <div class="local-video-container">
      <video id="localVideo" class="local-video" autoplay muted playsinline></video>
    </div>
    
    <div class="remote-video-container">
      <div class="remote-video-wrapper">
        <video id="remoteVideo" class="video-element" autoplay playsinline></video>
        <!-- Shy chat overlay -->
        <div class="shy-chat-overlay" id="shyChatOverlay"></div>
      </div>
    </div>

    <!-- Call info -->
    <div class="call-info">
      <div class="caller-name" id="callUserName"></div>
      <div class="call-status" id="callStatus">Connecting...</div>
    </div>

    <!-- Call controls -->
    <div class="call-controls">
      <button class="call-btn mute-btn" id="muteBtn" title="Mute/Unmute">
        <i class="fas fa-microphone"></i>
      </button>
      <button class="call-btn video-toggle-btn" id="videoToggleBtn" title="Toggle Video">
        <i class="fas fa-video"></i>
      </button>
      <button class="call-btn end-call-btn" id="endCallBtn" title="End Call">
        <i class="fas fa-phone"></i>
      </button>
    </div>

    <!-- Shy chat input during call -->
    <div class="call-chat-input">
      <input type="text" id="callChatInput" placeholder="Type a message to appear on screen...">
      <button class="call-chat-send-btn" id="callChatSendBtn">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incomingCallModal">
  <div class="call-modal-content">
    <img src="" class="caller-avatar" id="callerAvatar" alt="Caller">
    <div class="caller-info">
      <h3 id="incomingCallerName">John Doe</h3>
      <div class="call-type" id="incomingCallType">Video Call</div>
    </div>
    <div class="call-actions">
      <button class="decline-call-btn" onclick="declineIncomingCall()">
        <i class="fas fa-phone-slash"></i>
      </button>
      <button class="accept-call-btn" onclick="acceptIncomingCall()">
        <i class="fas fa-phone"></i>
      </button>
    </div>
  </div>
</div>

<!-- Modals -->
<!-- Conversation Context Menu -->
<div class="conversation-options-menu" id="conversationOptionsMenu">
  <div class="msg-option-item" onclick="deleteConversation()" style="color:var(--error);"><i class="fas fa-trash-alt"></i> Delete Conversation</div>
</div>

<!-- Settings Modal -->
<div class="settings-modal" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Chat Settings</h3>
      <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="settings-option" onclick="toggleDarkMode()">
        <div class="option-info">
          <div class="option-icon">
            <i class="fas fa-moon"></i>
          </div>
          <div class="option-text">
            <h4>Dark Mode</h4>
            <p>Switch between light and dark themes</p>
          </div>
        </div>
        <div class="option-switch" id="darkModeSwitch"></div>
      </div>
      <div class="settings-option" onclick="clearChat()">
        <div class="option-info">
          <div class="option-icon">
            <i class="fas fa-trash"></i>
          </div>
          <div class="option-text">
            <h4>Clear Chat</h4>
            <p>Delete all messages in this conversation</p>
          </div>
        </div>
      </div>
      <div class="settings-option" onclick="changeWallpaper()">
        <div class="option-info">
          <div class="option-icon">
            <i class="fas fa-image"></i>
          </div>
          <div class="option-text">
            <h4>Change Wallpaper</h4>
            <p>Set a custom background for this chat</p>
          </div>
        </div>
      </div>
      <div class="settings-option" onclick="toggleNotifications()">
        <div class="option-info">
          <div class="option-icon">
            <i class="fas fa-bell"></i>
          </div>
          <div class="option-text">
            <h4>Notifications</h4>
            <p>Enable or disable message notifications</p>
          </div>
        </div>
        <div class="option-switch active" id="notificationsSwitch"></div>
      </div>
    </div>
  </div>
</div>

<!-- User Search Modal -->
<div class="user-search-overlay" id="userSearchOverlay">
  <div class="modal-content">
    <div class="modal-header">
      <h3>New Conversation</h3>
      <button class="modal-close" onclick="closeUserSearchOverlay()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="chat-search" style="padding:0 0 20px 0;">
        <input type="text" placeholder="Search users..." id="userSearchInput">
      </div>
      <div id="searchResults">
        <!-- Users will be listed here -->
      </div>
    </div>
  </div>
</div>

<!-- Wallpaper Modal -->
<div class="wallpaper-modal" id="wallpaperModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Choose Wallpaper</h3>
      <button class="modal-close" onclick="closeWallpaperModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="wallpaper-grid" id="wallpaperGrid">
        <!-- Wallpapers will be loaded here -->
      </div>
    </div>
  </div>
</div>

<!-- Wallpaper Preview Modal -->
<div class="wallpaper-preview-overlay" id="wpPreviewOverlay">
  <div class="modal-content" style="max-width:800px;">
    <div class="modal-header">
      <h3>Preview Wallpaper</h3>
      <button class="modal-close" onclick="closeWallpaperPreview()">&times;</button>
    </div>
    <div class="modal-body" style="padding:0;">
      <div id="wallpaperPreview" style="height:400px; background-size:cover; background-position:center;"></div>
      <div style="padding:20px; display:flex; gap:15px;">
        <button onclick="applyWallpaper()" style="flex:1; padding:15px; background:var(--primary); color:white; border:none; border-radius:10px; font-family:var(--chat-font); font-weight:600; cursor:pointer; transition:all 0.2s ease;">Apply</button>
        <button onclick="closeWallpaperPreview()" style="flex:1; padding:15px; background:var(--bg-color); color:var(--text-color); border:none; border-radius:10px; font-family:var(--chat-font); font-weight:600; cursor:pointer; transition:all 0.2s ease;">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getFirestore, collection, addDoc, updateDoc, doc, getDoc, getDocs, onSnapshot, serverTimestamp, query, orderBy, where, setDoc, limit, deleteDoc, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDtqM_pMGIYkUgy0OWGsQbfS9MtYQhrgZM",
    authDomain: "meet-6e159.firebaseapp.com",
    projectId: "meet-6e159",
    storageBucket: "meet-6e159.firebasestorage.app",
    messagingSenderId: "252353608421",
    appId: "1:252353608421:web:6706056048e9a8f12db20c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Global state variables
  let currentUser = null;
  let currentChatId = null;
  let currentChatUser = null;
  let currentChatUserName = '';
  let currentChatUserAvatar = '';
  let unsubscribeMessages = null;
  let unsubscribeConversations = null;
  let selectedWallpaper = null;
  let replyingToMessage = null;
  
  // WebRTC variables
  let peerConnection = null;
  let localStream = null;
  let remoteStream = null;
  let dataChannel = null;
  let isInitiator = false;
  let isCallActive = false;
  let callType = null; // 'video' or 'voice'
  let incomingCallId = null;
  let incomingCallSignalingData = null;
  let unsubscribeSignaling = null;
  
  // Voice message variables
  let mediaRecorder = null;
  let audioChunks = [];
  let recordingTimer = null;
  let recordingStartTime = null;
  
  // DOM elements
  const callInterface = document.getElementById('callInterface');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const muteBtn = document.getElementById('muteBtn');
  const videoToggleBtn = document.getElementById('videoToggleBtn');
  const endCallBtn = document.getElementById('endCallBtn');
  const callUserName = document.getElementById('callUserName');
  const callStatus = document.getElementById('callStatus');
  const shyChatOverlay = document.getElementById('shyChatOverlay');
  const callChatInput = document.getElementById('callChatInput');
  const callChatSendBtn = document.getElementById('callChatSendBtn');
  const incomingCallModal = document.getElementById('incomingCallModal');
  const callerAvatar = document.getElementById('callerAvatar');
  const incomingCallerName = document.getElementById('incomingCallerName');
  const incomingCallType = document.getElementById('incomingCallType');
  const voiceMessageContainer = document.getElementById('voiceMessageContainer');
  const recordingTimerEl = document.getElementById('recordingTimer');
  const voiceMsgToggleBtn = document.getElementById('voiceMsgToggleBtn');
  const messageInput = document.getElementById('messageInput');
  const sendButton = document.getElementById('sendButton');
  const conversationsList = document.getElementById('conversationsList');
  const messagesContainer = document.getElementById('messagesContainer');
  const typingIndicator = document.getElementById('typingIndicator');
  const chatSearch = document.getElementById('chatSearch');
  const backButton = document.getElementById('backButton');
  
  // WebRTC Configuration
  const configuration = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' }
    ]
  };

  // === UTILITY FUNCTIONS ===
  
  function showError(message) {
    console.error(message);
    // Create toast notification
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--error);
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      z-index: 9999;
      animation: slideIn 0.3s ease;
      box-shadow: var(--shadow-heavy);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }
  
  function showSuccess(message) {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--success);
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      z-index: 9999;
      animation: slideIn 0.3s ease;
      box-shadow: var(--shadow-heavy);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }
  
  function formatTime(timestamp) {
    if (!timestamp) return '';
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 24 * 60 * 60 * 1000) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diff < 7 * 24 * 60 * 60 * 1000) {
      return date.toLocaleDateString([], { weekday: 'short' });
    } else {
      return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }
  }
  
  // === CHAT FUNCTIONS ===
  
  async function loadConversations() {
    if (!currentUser) return;
    
    const conversationsQuery = query(
      collection(db, "conversations"),
      where("participants", "array-contains", currentUser.uid),
      orderBy("updatedAt", "desc")
    );
    
    unsubscribeConversations = onSnapshot(conversationsQuery, async (snapshot) => {
      conversationsList.innerHTML = '';
      
      for (const docSnap of snapshot.docs) {
        const conversation = docSnap.data();
        const otherUserId = conversation.participants.find(id => id !== currentUser.uid);
        
        if (!otherUserId) continue;
        
        const userDoc = await getDoc(doc(db, "users", otherUserId));
        const userData = userDoc.data() || {};
        
        const conversationItem = document.createElement('div');
        conversationItem.className = 'conversation-item';
        conversationItem.dataset.chatId = docSnap.id;
        conversationItem.dataset.userId = otherUserId;
        conversationItem.dataset.userName = userData.name || 'Unknown';
        conversationItem.dataset.userAvatar = userData.profilePicture || 'https://via.placeholder.com/50';
        
        conversationItem.innerHTML = `
          <img src="${userData.profilePicture || 'https://via.placeholder.com/50'}" class="conversation-avatar">
          <div class="conversation-info">
            <div class="conversation-name">${userData.name || 'Unknown'}</div>
            <div class="conversation-preview">${conversation.lastMessage || 'No messages yet'}</div>
          </div>
          <div class="conversation-meta">
            <div class="conversation-time">${formatTime(conversation.updatedAt)}</div>
            ${conversation.unread && conversation.unread[currentUser.uid] > 0 ? 
              `<div class="unread-badge">${conversation.unread[currentUser.uid]}</div>` : ''}
          </div>
        `;
        
        conversationItem.addEventListener('click', () => {
          openChat(docSnap.id, otherUserId, userData.name || 'Unknown', userData.profilePicture);
        });
        
        conversationsList.appendChild(conversationItem);
      }
    });
  }
  
  async function openChat(chatId, otherUserId, name, avatar) {
    // 1. Clean up old listener
    if (unsubscribeSignaling) {
      unsubscribeSignaling();
      unsubscribeSignaling = null;
    }
    
    // 2. Setup signaling listener for this new chat
    currentChatUser = otherUserId;
    setupSignalingListener();
    
    // 3. Set current chat info
    currentChatId = chatId;
    currentChatUserName = name;
    currentChatUserAvatar = avatar;
    
    // 4. Update UI
    document.getElementById('emptyChat').style.display = 'none';
    document.getElementById('chatHeader').style.display = 'flex';
    document.getElementById('messagesContainer').style.display = 'flex';
    document.getElementById('messageInputContainer').style.display = 'block';
    
    // 5. Update header
    document.getElementById('chatUserName').textContent = name;
    document.getElementById('currentChatAvatar').src = avatar || 'https://via.placeholder.com/50';
    
    // 6. Mark as read
    await markAsRead(chatId);
    
    // 7. Load messages
    loadMessages(chatId);
    
    // 8. On mobile, hide conversations sidebar
    if (window.innerWidth <= 768) {
      document.getElementById('conversationsSidebar').classList.remove('active');
    }
  }
  
  async function markAsRead(chatId) {
    if (!currentUser || !chatId) return;
    
    try {
      const conversationRef = doc(db, "conversations", chatId);
      await updateDoc(conversationRef, {
        [`unread.${currentUser.uid}`]: 0
      });
    } catch (error) {
      console.error('Error marking as read:', error);
    }
  }
  
  async function loadMessages(chatId) {
    if (unsubscribeMessages) {
      unsubscribeMessages();
    }
    
    const messagesQuery = query(
      collection(db, "conversations", chatId, "messages"),
      orderBy("timestamp", "asc"),
      limit(100)
    );
    
    unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
      messagesContainer.innerHTML = '';
      
      snapshot.forEach((docSnap) => {
        const message = docSnap.data();
        const isMe = message.senderId === currentUser.uid;
        
        let messageElement;
        
        if (message.type === 'audio') {
          messageElement = renderAudioMessageHTML(message, isMe, docSnap.id);
        } else if (message.type === 'image') {
          messageElement = renderImageMessageHTML(message, isMe, docSnap.id);
        } else {
          messageElement = renderTextMessageHTML(message, isMe, docSnap.id);
        }
        
        messagesContainer.appendChild(messageElement);
      });
      
      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    });
  }
  
  function renderTextMessageHTML(msg, isMe, id) {
    const div = document.createElement('div');
    div.className = `message-bubble ${isMe ? 'sent' : 'received'}`;
    div.id = id;
    
    div.innerHTML = `
      <div class="message-text">${msg.text || ''}</div>
      <div class="message-time">
        ${formatTime(msg.timestamp)}
        ${isMe ? `<span class="message-status"></span>` : ''}
      </div>
    `;
    
    // Add right-click context menu for replies
    div.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      replyingToMessage = { id: id, text: msg.text, senderId: msg.senderId };
      showReplyPreview();
    });
    
    return div;
  }
  
  function renderAudioMessageHTML(msg, isMe, id) {
    const div = document.createElement('div');
    div.className = `audio-message ${isMe ? 'sent' : 'received'}`;
    div.id = id;
    
    const audio = new Audio();
    audio.src = msg.audioData;
    
    const playPauseBtn = document.createElement('button');
    playPauseBtn.className = 'play-pause-btn';
    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    
    const progressBar = document.createElement('div');
    progressBar.className = 'audio-progress';
    const progressFill = document.createElement('div');
    progressFill.className = 'audio-progress-bar';
    progressBar.appendChild(progressFill);
    
    const durationSpan = document.createElement('span');
    durationSpan.className = 'audio-duration';
    durationSpan.textContent = formatDuration(msg.duration || 0);
    
    // Get audio duration
    audio.addEventListener('loadedmetadata', () => {
      durationSpan.textContent = formatDuration(audio.duration);
    });
    
    playPauseBtn.onclick = () => {
      if (audio.paused) {
        audio.play();
        playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
      } else {
        audio.pause();
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
      }
    };
    
    audio.addEventListener('timeupdate', () => {
      const progress = (audio.currentTime / audio.duration) * 100;
      progressFill.style.width = `${progress}%`;
      
      if (audio.currentTime === audio.duration) {
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
      }
    });
    
    audio.addEventListener('pause', () => {
      playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    });
    
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'audio-controls';
    controlsDiv.appendChild(playPauseBtn);
    controlsDiv.appendChild(progressBar);
    controlsDiv.appendChild(durationSpan);
    
    div.appendChild(controlsDiv);
    
    return div;
  }
  
  function renderImageMessageHTML(msg, isMe, id) {
    const div = document.createElement('div');
    div.className = `image-message message-bubble ${isMe ? 'sent' : 'received'}`;
    div.id = id;
    
    const img = document.createElement('img');
    img.src = msg.imageUrl;
    img.alt = 'Image message';
    
    const timeDiv = document.createElement('div');
    timeDiv.className = 'message-time';
    timeDiv.innerHTML = `
      ${formatTime(msg.timestamp)}
      ${isMe ? `<span class="message-status"></span>` : ''}
    `;
    
    div.appendChild(img);
    div.appendChild(timeDiv);
    
    // Click to view larger
    img.addEventListener('click', () => {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 4000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      const fullImg = document.createElement('img');
      fullImg.src = msg.imageUrl;
      fullImg.style.cssText = `
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
      `;
      
      overlay.appendChild(fullImg);
      overlay.addEventListener('click', () => overlay.remove());
      document.body.appendChild(overlay);
    });
    
    return div;
  }
  
  async function sendMessage() {
    const text = messageInput.value.trim();
    if (!text || !currentChatId || !currentUser) return;
    
    try {
      const messageData = {
        text: text,
        senderId: currentUser.uid,
        timestamp: serverTimestamp(),
        type: 'text'
      };
      
      if (replyingToMessage) {
        messageData.replyTo = {
          messageId: replyingToMessage.id,
          text: replyingToMessage.text,
          senderId: replyingToMessage.senderId
        };
      }
      
      await addDoc(collection(db, "conversations", currentChatId, "messages"), messageData);
      
      // Update conversation
      await updateDoc(doc(db, "conversations", currentChatId), {
        lastMessage: text,
        updatedAt: serverTimestamp(),
        [`unread.${currentChatUser}`]: arrayUnion(1)
      });
      
      // Clear input and reply
      messageInput.value = '';
      cancelReply();
      messageInput.style.height = 'auto';
    } catch (error) {
      console.error('Error sending message:', error);
      showError('Failed to send message');
    }
  }
  
  function showReplyPreview() {
    if (!replyingToMessage) return;
    
    const replyPreview = document.getElementById('replyPreview');
    const replyName = document.getElementById('replyName');
    const replyText = document.getElementById('replyText');
    
    replyName.textContent = replyingToMessage.senderId === currentUser.uid ? 'You' : currentChatUserName;
    replyText.textContent = replyingToMessage.text;
    replyPreview.style.display = 'flex';
  }
  
  function cancelReply() {
    replyingToMessage = null;
    document.getElementById('replyPreview').style.display = 'none';
  }
  
  function toggleAssistBar() {
    const assistBar = document.getElementById('assistBar');
    assistBar.style.display = assistBar.style.display === 'none' ? 'flex' : 'none';
  }
  
  function applyWritingAssist(type) {
    const text = messageInput.value;
    if (!text) return;
    
    // This would integrate with an AI writing assistant API
    // For now, just show a placeholder
    showSuccess('Writing assistant feature would process your text here');
  }
  
  function toggleEmojiPicker() {
    const emojiPicker = document.getElementById('emojiPicker');
    emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'flex' : 'none';
    
    if (emojiPicker.style.display === 'flex') {
      loadEmojis();
    }
  }
  
  function loadEmojis() {
    const emojiContent = document.getElementById('emojiContent');
    const emojiNav = document.getElementById('emojiNav');
    
    if (emojiContent.innerHTML) return;
    
    // Common emoji categories
    const emojiCategories = {
      '': ['', '', '', '', '', '', '', '', '', ''],
      '': ['', '', '', '', '', '', '', '', '', ''],
      '': ['', '', '', '', '', '', '', '', '', ''],
      '': ['', '', '', '', '', '', '', '', '', ''],
      '': ['', '', '', '', '', '', '', '', '', '']
    };
    
    emojiNav.innerHTML = '';
    emojiContent.innerHTML = '';
    
    // Create tabs
    Object.keys(emojiCategories).forEach((category, index) => {
      const tab = document.createElement('button');
      tab.className = 'emoji-tab';
      tab.textContent = category;
      tab.onclick = () => {
        // Scroll to category
        const categoryStart = index * emojiCategories[category].length;
        // Implementation would scroll to specific category
      };
      emojiNav.appendChild(tab);
    });
    
    // Add all emojis
    Object.values(emojiCategories).flat().forEach(emoji => {
      const emojiItem = document.createElement('div');
      emojiItem.className = 'emoji-item';
      emojiItem.textContent = emoji;
      emojiItem.onclick = () => {
        messageInput.value += emoji;
        messageInput.focus();
      };
      emojiContent.appendChild(emojiItem);
    });
  }
  
  // === WEBRTC FUNCTIONS ===
  
  async function initWebRTC() {
    try {
      const constraints = {
        audio: true,
        video: callType === 'video' ? {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 }
        } : false
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      // Set up initial UI state based on stream
      if (callType === 'video') {
        localVideo.srcObject = localStream;
        videoToggleBtn.classList.remove('active'); // Assume video is ON initially
      } else {
        // Hide video elements for voice call
        localVideo.srcObject = localStream; // Still set stream to local for audio track management
        localVideo.style.display = 'none';
      }
      muteBtn.classList.remove('active'); // Assume audio is ON
      
      return true;
    } catch (error) {
      console.error('Error accessing media devices:', error);
      showError('Unable to access camera/microphone. Please check permissions.');
      return false;
    }
  }

  function createPeerConnection() {
    peerConnection = new RTCPeerConnection(configuration);
    isCallActive = true;

    // 1. Add local tracks
    localStream.getTracks().forEach(track => {
      peerConnection.addTrack(track, localStream);
    });

    // 2. Handle remote stream
    peerConnection.ontrack = (event) => {
      remoteStream = event.streams[0];
      remoteVideo.srcObject = remoteStream;
      updateCallStatus('Connected');
    };

    // 3. Handle ICE candidates (Signaling)
    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        sendSignalingMessage({
          type: 'ice-candidate',
          candidate: event.candidate.toJSON() // Use toJSON for serializing
        });
      }
    };

    // 4. Handle connection state
    peerConnection.onconnectionstatechange = () => {
      console.log('Connection state:', peerConnection.connectionState);
      if (peerConnection.connectionState === 'connected') {
        updateCallStatus('Connected');
      } else if (
        ['disconnected', 'failed', 'closed'].includes(peerConnection.connectionState)
      ) {
        if (isCallActive) {
          showError('Call disconnected.');
          endCall();
        }
      }
    };

    // 5. Create data channel for shy chat
    if (isInitiator) {
      // Initiator creates and names the channel
      dataChannel = peerConnection.createDataChannel('shy-chat', { reliable: true });
      setupDataChannel();
    } else {
      // Receiver listens for the channel creation
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel();
      };
    }
  }

  function setupDataChannel() {
    dataChannel.onopen = () => {
      console.log('Data channel opened for shy chat.');
      callChatInput.disabled = false;
      callChatSendBtn.disabled = false;
    };

    dataChannel.onmessage = (event) => {
      // The received data is the shy chat message
      const message = event.data;
      displayShyChatMessage(message);
    };

    dataChannel.onerror = (error) => {
      console.error('Data Channel Error:', error);
    };
  }

  async function startCall(type) {
    if (!currentChatId || !currentChatUser) {
      showError('Please select a conversation first');
      return;
    }

    callType = type;
    isInitiator = true;
    
    const mediaGranted = await initWebRTC();
    if (!mediaGranted) return;

    createPeerConnection();

    try {
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await sendSignalingMessage({
        type: 'offer',
        sdp: offer.sdp,
        callType: callType,
        callerId: currentUser.uid,
        callerName: await getUserDisplayName(currentUser.uid)
      });

      showCallInterface();
      updateCallStatus('Calling...');
    } catch (error) {
      console.error('Error starting call:', error);
      showError('Failed to start call');
      endCall(); // Clean up if offer fails
    }
  }

  function showCallInterface() {
    document.body.classList.add('call-active');
    callUserName.textContent = currentChatUserName;
    updateCallStatus('Connecting...');
    
    // Update UI based on call type
    const localVidEl = document.querySelector('.local-video-container');
    const remoteVidEl = document.querySelector('.remote-video-wrapper');

    if (callType === 'voice') {
      localVidEl.style.display = 'none';
      remoteVidEl.style.display = 'none';
      // Ensure video toggle is hidden/disabled
      videoToggleBtn.style.display = 'none';
    } else {
      localVidEl.style.display = 'block';
      remoteVidEl.style.display = 'block';
      videoToggleBtn.style.display = 'flex';
    }
  }

  function handleIncomingCall(signalingData) {
    if (isCallActive) {
      // Send busy signal if already on a call
      sendSignalingMessage({ type: 'busy', to: signalingData.callerId });
      return;
    }
    
    // Store the offer and setup signaling data for acceptance
    incomingCallSignalingData = signalingData;
    incomingCallId = signalingData.callerId;
    
    incomingCallerName.textContent = signalingData.callerName || 'Unknown';
    incomingCallType.textContent = signalingData.callType === 'video' ? 'Video Call' : 'Voice Call';
    
    incomingCallModal.classList.add('active');
    
    // Auto decline after 30 seconds
    setTimeout(() => {
      if (incomingCallModal.classList.contains('active')) {
        declineIncomingCall();
      }
    }, 30000);
  }

  async function acceptIncomingCall() {
    callType = incomingCallSignalingData.callType;
    isInitiator = false;
    
    const mediaGranted = await initWebRTC();
    if (!mediaGranted) {
      declineIncomingCall();
      return;
    }

    createPeerConnection();
    
    try {
      // 1. Set remote description (The Offer)
      await peerConnection.setRemoteDescription(new RTCSessionDescription({
        type: 'offer',
        sdp: incomingCallSignalingData.sdp
      }));

      // 2. Create and send answer
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      await sendSignalingMessage({
        type: 'answer',
        sdp: answer.sdp
      });

      incomingCallModal.classList.remove('active');
      showCallInterface();
      updateCallStatus('Connecting...');
      
    } catch(error) {
      console.error('Error accepting call:', error);
      showError('Failed to establish connection.');
      endCall();
    }
  }

  function declineIncomingCall() {
    if (incomingCallId) {
      sendSignalingMessage({
        type: 'reject'
      });
    }
    
    incomingCallModal.classList.remove('active');
    incomingCallId = null;
    incomingCallSignalingData = null;
  }

  function endCall() {
    if (!isCallActive) return;

    // 1. Close Peer Connection
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    
    // 2. Stop Media Tracks
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    
    // 3. Clean up UI/State
    if (dataChannel) dataChannel = null;
    isCallActive = false;
    isInitiator = false;
    
    document.body.classList.remove('call-active');
    
    // 4. Send call end signal (only if not ended by remote or connection failure)
    if (currentChatUser) {
      sendSignalingMessage({
        type: 'end-call'
      });
    }
  }

  function toggleMute() {
    if (localStream) {
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        muteBtn.classList.toggle('active', !audioTrack.enabled);
        muteBtn.innerHTML = audioTrack.enabled ? 
          '<i class="fas fa-microphone"></i>' : 
          '<i class="fas fa-microphone-slash"></i>';
      }
    }
  }

  function toggleVideo() {
    if (localStream) {
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        videoToggleBtn.classList.toggle('active', !videoTrack.enabled);
        videoToggleBtn.innerHTML = videoTrack.enabled ? 
          '<i class="fas fa-video"></i>' : 
          '<i class="fas fa-video-slash"></i>';
      }
    }
  }

  function displayShyChatMessage(message) {
    shyChatOverlay.textContent = message;
    shyChatOverlay.classList.add('visible');
    
    // Hide after 5 seconds
    setTimeout(() => {
      shyChatOverlay.classList.remove('visible');
    }, 5000);
  }

  function sendShyChatMessage() {
    const message = callChatInput.value.trim();
    if (message && dataChannel && dataChannel.readyState === 'open') {
      // Send to peer
      dataChannel.send(message);
      // Display locally with 'You' prefix
      displayShyChatMessage(`You: ${message}`); 
      callChatInput.value = '';
    }
  }

  function updateCallStatus(status) {
    callStatus.textContent = status;
  }

  // === VOICE MESSAGE FUNCTIONS ===

  async function startVoiceRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        audioChunks.push(event.data);
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await sendVoiceMessage(audioBlob);
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      voiceMessageContainer.classList.add('recording');
      
      // Start timer
      recordingStartTime = Date.now();
      recordingTimer = setInterval(updateRecordingTimer, 1000);
      updateRecordingTimer();
      
    } catch (error) {
      console.error('Error accessing microphone:', error);
      showError('Unable to access microphone for recording');
    }
  }

  function stopVoiceRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      clearInterval(recordingTimer);
      voiceMessageContainer.classList.remove('recording');
    }
  }

  function cancelVoiceRecording() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
      clearInterval(recordingTimer);
      voiceMessageContainer.classList.remove('recording');
      
      // Stop tracks
      mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }
  }

  function updateRecordingTimer() {
    if (recordingStartTime) {
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      recordingTimerEl.textContent = `${minutes}:${seconds}`;
      
      // Auto-stop after 2 minutes
      if (elapsed >= 120) {
        stopVoiceRecording();
      }
    }
  }

  async function sendVoiceMessage(audioBlob) {
    if (!currentChatId) return;
    
    // Convert blob to base64 for Firestore
    const reader = new FileReader();
    reader.readAsDataURL(audioBlob);
    
    reader.onloadend = async () => {
      const base64Audio = reader.result;
      
      try {
        await addDoc(collection(db, "conversations", currentChatId, "messages"), {
          type: 'audio',
          audioData: base64Audio,
          duration: Math.floor((Date.now() - recordingStartTime) / 1000),
          senderId: currentUser.uid,
          timestamp: serverTimestamp()
        });
        
        // Update conversation
        await updateDoc(doc(db, "conversations", currentChatId), {
          lastMessage: 'Voice message',
          updatedAt: serverTimestamp(),
          [`unread.${currentChatUser}`]: arrayUnion(1)
        });
        
      } catch (error) {
        console.error('Error sending voice message:', error);
        showError('Failed to send voice message');
      }
    };
  }

  function toggleVoiceMessage() {
    if (voiceMessageContainer.classList.contains('recording')) {
      stopVoiceRecording();
    } else {
      startVoiceRecording();
    }
  }

  function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // === SIGNALING FUNCTIONS ===

  async function sendSignalingMessage(message) {
    if (!currentChatId || !currentChatUser) return;
    
    try {
      const signalingRef = collection(db, "signaling", currentChatId, "messages");
      await addDoc(signalingRef, {
        ...message,
        from: currentUser.uid,
        to: currentChatUser,
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Error sending signaling message:', error);
    }
  }

  function setupSignalingListener() {
    if (unsubscribeSignaling) {
      unsubscribeSignaling(); // Clean up old listener
    }
    if (!currentChatId || !currentUser) return;
    
    const signalingQuery = query(
      collection(db, "signaling", currentChatId, "messages"),
      where("to", "==", currentUser.uid),
      orderBy("timestamp", "asc") // Order ascending to process in time sequence
    );
    
    unsubscribeSignaling = onSnapshot(signalingQuery, (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === "added") {
          const data = change.doc.data();
          await handleSignalingMessage(data);
          // Important: Delete the message after processing to avoid reprocessing
          await deleteDoc(change.doc.ref);
        }
      });
    });
  }

  async function handleSignalingMessage(message) {
    const { type, sdp, candidate } = message;

    switch (type) {
      case 'offer':
        if (!isCallActive) {
          // Only handle if not already in a call
          incomingCallSignalingData = message;
          handleIncomingCall(message);
        }
        break;
        
      case 'answer':
        if (peerConnection && peerConnection.remoteDescription === null) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp }));
          updateCallStatus('Connected');
        }
        break;
        
      case 'ice-candidate':
        if (peerConnection && candidate) {
          try {
            // Candidate must be created from the raw data
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          } catch (e) {
            console.error('Error adding ICE candidate:', e);
          }
        }
        break;
        
      case 'reject':
        if (isInitiator) {
          showError('Call was declined');
          endCall();
        }
        break;
        
      case 'end-call':
        endCall();
        break;
        
      case 'busy':
        if (isInitiator) {
          showError(`${currentChatUserName} is currently busy.`);
          endCall();
        }
        break;
    }
  }

  // === UI FUNCTIONS ===
  
  function toggleSidebar() {
    const sidebar = document.getElementById('mainSidebar');
    const overlay = document.getElementById('sidebarOverlay');
    
    if (sidebar.classList.contains('active')) {
      sidebar.classList.remove('active');
      overlay.style.display = 'none';
    } else {
      sidebar.classList.add('active');
      overlay.style.display = 'block';
    }
  }
  
  function openUserSearchOverlay() {
    document.getElementById('userSearchOverlay').style.display = 'flex';
  }
  
  function closeUserSearchOverlay() {
    document.getElementById('userSearchOverlay').style.display = 'none';
  }
  
  function openSettingsModal() {
    document.getElementById('settingsModal').style.display = 'flex';
  }
  
  function closeSettingsModal() {
    document.getElementById('settingsModal').style.display = 'none';
  }
  
  function openWallpaperModal() {
    document.getElementById('wallpaperModal').style.display = 'flex';
    loadWallpapers();
  }
  
  function closeWallpaperModal() {
    document.getElementById('wallpaperModal').style.display = 'none';
  }
  
  function loadWallpapers() {
    const wallpaperGrid = document.getElementById('wallpaperGrid');
    wallpaperGrid.innerHTML = '';
    
    const wallpapers = [
      'https://images.unsplash.com/photo-1557683316-973673baf926?w=400',
      'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400',
      'https://images.unsplash.com/photo-1506744038136-46273834b3fb?w-400',
      'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=400',
      'https://images.unsplash.com/photo-1465146344425-f00d5f5c8f07?w=400',
      'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=400'
    ];
    
    wallpapers.forEach((url, index) => {
      const wallpaperItem = document.createElement('div');
      wallpaperItem.style.cssText = `
        width: 100%;
        height: 150px;
        background-image: url(${url});
        background-size: cover;
        background-position: center;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.2s ease;
      `;
      
      wallpaperItem.addEventListener('click', () => {
        selectedWallpaper = url;
        openWallpaperPreview();
      });
      
      wallpaperItem.addEventListener('mouseenter', () => {
        wallpaperItem.style.transform = 'scale(1.05)';
      });
      
      wallpaperItem.addEventListener('mouseleave', () => {
        wallpaperItem.style.transform = 'scale(1)';
      });
      
      wallpaperGrid.appendChild(wallpaperItem);
    });
  }
  
  function openWallpaperPreview() {
    if (!selectedWallpaper) return;
    
    const preview = document.getElementById('wallpaperPreview');
    preview.style.backgroundImage = `url(${selectedWallpaper})`;
    document.getElementById('wpPreviewOverlay').style.display = 'flex';
  }
  
  function closeWallpaperPreview() {
    document.getElementById('wpPreviewOverlay').style.display = 'none';
  }
  
  function applyWallpaper() {
    if (selectedWallpaper) {
      messagesContainer.style.backgroundImage = `url(${selectedWallpaper})`;
      showSuccess('Wallpaper applied successfully');
    }
    closeWallpaperPreview();
    closeWallpaperModal();
  }
  
  function toggleDarkMode() {
    const body = document.body;
    const switchEl = document.getElementById('darkModeSwitch');
    
    if (body.classList.contains('dark-mode')) {
      body.classList.remove('dark-mode');
      switchEl.classList.remove('active');
      localStorage.setItem('darkMode', 'false');
    } else {
      body.classList.add('dark-mode');
      switchEl.classList.add('active');
      localStorage.setItem('darkMode', 'true');
    }
  }
  
  function getUserDisplayName(userId) {
    // This would fetch from Firebase
    return currentChatUserName;
  }
  
  // === INTEGRATION ===
  
  window.startVideoCall = () => { startCall('video'); };
  window.startVoiceCall = () => { startCall('voice'); };
  
  // Cleanup helper function
  function cleanupMedia() {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
  }

  // === EVENT LISTENERS ===
  
  onAuthStateChanged(auth, async user => {
    if (!user) {
      window.location.href = 'login.html';
    } else {
      currentUser = user;
      
      // Load user data
      const userDoc = await getDoc(doc(db, "users", user.uid));
      if (userDoc.exists()) {
        const userData = userDoc.data();
        document.getElementById('navUserName').textContent = userData.name || user.email;
        document.getElementById('navUserImg').src = userData.profilePicture || 'https://via.placeholder.com/40';
      }
      
      // Load conversations
      loadConversations();
      
      // Check for dark mode preference
      if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeSwitch').classList.add('active');
      }
    }
  });

  // Message input auto-resize
  messageInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
  });

  // Send message on Enter (Shift+Enter for new line)
  messageInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  sendButton.addEventListener('click', sendMessage);

  // WebRTC event listeners
  endCallBtn.addEventListener('click', endCall);
  muteBtn.addEventListener('click', toggleMute);
  videoToggleBtn.addEventListener('click', toggleVideo);

  // Shy Chat listeners
  callChatSendBtn.addEventListener('click', sendShyChatMessage);
  callChatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendShyChatMessage();
    }
  });

  // Voice message event listeners
  voiceMsgToggleBtn.addEventListener('click', toggleVoiceMessage);
  document.getElementById('voiceMessageBtn').addEventListener('click', toggleVoiceMessage);

  // Back button for mobile
  backButton.addEventListener('click', () => {
    document.getElementById('chatHeader').style.display = 'none';
    document.getElementById('messagesContainer').style.display = 'none';
    document.getElementById('messageInputContainer').style.display = 'none';
    document.getElementById('emptyChat').style.display = 'flex';
    
    if (window.innerWidth <= 768) {
      document.getElementById('conversationsSidebar').classList.add('active');
    }
  });

  // Chat search
  chatSearch.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    const items = document.querySelectorAll('.conversation-item');
    
    items.forEach(item => {
      const name = item.dataset.userName.toLowerCase();
      if (name.includes(searchTerm)) {
        item.style.display = 'flex';
      } else {
        item.style.display = 'none';
      }
    });
  });

  // Logout
  document.getElementById('logoutBtn').addEventListener('click', async () => {
    try {
      await signOut(auth);
      window.location.href = 'login.html';
    } catch (error) {
      console.error('Error signing out:', error);
    }
  });

  // Night mode toggle
  document.getElementById('nightToggleBtn').addEventListener('click', toggleDarkMode);

  // Close modals when clicking outside
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('settings-modal') || 
        e.target.classList.contains('user-search-overlay') ||
        e.target.classList.contains('wallpaper-modal') ||
        e.target.classList.contains('wallpaper-preview-overlay')) {
      closeSettingsModal();
      closeUserSearchOverlay();
      closeWallpaperModal();
      closeWallpaperPreview();
    }
  });

  // Close emoji picker when clicking outside
  document.addEventListener('click', (e) => {
    const emojiPicker = document.getElementById('emojiPicker');
    if (emojiPicker.style.display === 'flex' && 
        !emojiPicker.contains(e.target) && 
        e.target.id !== 'emojiBtn') {
      emojiPicker.style.display = 'none';
    }
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    endCall();
    cleanupMedia();
    
    if (unsubscribeMessages) unsubscribeMessages();
    if (unsubscribeConversations) unsubscribeConversations();
    if (unsubscribeSignaling) unsubscribeSignaling();
  });

  // Mobile sidebar toggle
  if (window.innerWidth <= 768) {
    document.getElementById('conversationsSidebar').classList.add('active');
  }

</script>
</body>
</html>
