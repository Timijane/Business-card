<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MEET | Feed</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --primary: #0080FF;
    --primary-dark: #0066CC;
    --error: #EF4444;
    --success: #10B981;
    --warning: #F59E0B;
    --bg-color: #f0f2f5;
    --card-bg: #fff;
    --text-color: #111;
    --secondary-text: #65676b;
    --border-color: #dddfe2;
    --online: #10B981; /* Green for online/associated */
    --offline: #EF4444; /* Red for offline/disassociated */
    --associated: #10B981; /* Green for associated */
    --disassociated: #EF4444; /* Red for disassociated */
  }

  body.dark-mode {
    --bg-color: #18191a;
    --card-bg: #242526;
    --text-color: #e4e6ea;
    --secondary-text: #b0b3b8;
    --border-color: #3e4042;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  html, body {
    height: 100%;
    overflow-x: hidden;
    font-size: 18px;
  }

  body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #e0f7ff 0%, #b3e0ff 100%);
    color: var(--text-color);
    transition: all 0.3s ease;
    min-height: 100vh;
    -webkit-overflow-scrolling: touch;
  }

  .app-container {
    display: flex;
    min-height: 100vh;
    position: relative;
  }

  .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    width: 280px;
    background: linear-gradient(180deg, #0080FF 0%, #00C6FF 100%);
    border-right: 1px solid var(--border-color);
    overflow-y: auto;
    z-index: 100;
    padding: 20px;
    transition: all 0.3s ease;
    color: white;
    -webkit-overflow-scrolling: touch;
  }

  .sidebar-header {
    padding: 10px 0 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 20px;
  }

  .sidebar-menu {
    list-style: none;
  }

  .sidebar-menu li {
    margin-bottom: 8px;
  }

  .sidebar-menu a {
    display: flex;
    align-items: center;
    padding: 12px;
    text-decoration: none;
    color: white;
    border-radius: 8px;
    transition: background 0.3s;
    min-height: 44px;
    font-size: 18px;
  }

  .sidebar-menu a:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .sidebar-menu i {
    margin-right: 12px;
    font-size: 18px;
  }

  .main-content {
    flex: 1;
    margin-left: 280px;
    padding: 20px;
    min-height: 100vh;
    font-size: 18px;
  }

  .navbar {
    background: linear-gradient(135deg, #0080FF 0%, #00C6FF 100%);
    padding: 8px 20px; /* Reduced height from 15px */
    border-radius: 12px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0,128,255,0.3); /* Enhanced shadow for beauty */
    color: white;
    flex-wrap: wrap;
    gap: 8px; /* Slightly reduced gap */
    position: relative;
    overflow: hidden;
  }

  .navbar::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  }

  .nav-controls {
    display: flex;
    gap: 8px; /* Reduced gap */
    align-items: center;
    flex-wrap: wrap;
  }

  .search-bar {
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    padding: 8px 15px;
    margin-right: 15px;
  }

  .search-bar input {
    background: transparent;
    border: none;
    color: white;
    outline: none;
    width: 200px;
    font-size: 18px;
  }

  .search-bar input::placeholder {
    color: rgba(255, 255, 255, 0.7);
  }

  .user-profile-nav {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px 10px;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.2);
    cursor: pointer;
    position: relative;
    min-height: 44px;
    transition: background 0.3s; /* Smooth hover */
  }

  .user-profile-nav:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  .user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: pointer;
    position: relative;
    min-width: 40px;
    font-size: 18px;
    overflow: hidden;
    border: 2px solid rgba(255,255,255,0.3); /* Added border for beauty */
  }

  .user-avatar.small {
    width: 30px;
    height: 30px;
    font-size: 16px;
    min-width: 30px;
  }

  .user-avatar img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .user-avatar.small img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .status-indicator {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid white;
  }

  .status-online {
    background-color: var(--online);
  }

  .status-offline {
    background-color: var(--offline);
  }

  .user-profile-nav span {
    font-size: 16px;
    font-weight: 600;
  }

  .btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    padding: 6px 12px; /* Slightly reduced padding */
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease; /* Smooth transition */
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px; /* Slightly smaller font */
    min-height: 40px; /* Reduced min-height */
    position: relative;
    backdrop-filter: blur(10px); /* Added for modern glass effect */
  }

  .btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px); /* Subtle lift on hover */
  }

  .btn-primary {
    background: var(--primary);
  }

  .btn-secondary {
    background: var(--secondary-text);
  }

  .btn-success {
    background: var(--success);
  }

  .btn-warning {
    background: var(--warning);
  }

  .follow-btn {
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 6px;
    min-height: 36px;
  }

  .unread-badge {
    background: var(--error);
    color: white;
    border-radius: 50%;
    padding: 2px 6px;
    font-size: 12px;
    display: none;
    min-width: 18px;
    justify-content: center;
    align-items: center;
  }

  /* Post Composer */
  .post-composer {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .composer-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
  }

  .composer-input {
    flex: 1;
    background: var(--bg-color);
    border: none;
    padding: 12px 16px;
    border-radius: 25px;
    color: var(--text-color);
    font-size: 18px;
    cursor: pointer;
    min-height: 44px;
  }

  .composer-divider {
    height: 1px;
    background: var(--border-color);
    margin: 16px 0;
  }

  .composer-actions {
    display: flex;
    justify-content: space-between;
  }

  .action-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
    color: var(--secondary-text);
    min-height: 44px;
    font-size: 16px;
  }

  .action-btn:hover {
    background: var(--bg-color);
  }

  /* AI Features */
  .meetai-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: linear-gradient(135deg, #00C6FF 0%, #80b3ff 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 99;
    transition: all 0.3s ease;
    min-width: 60px;
    min-height: 60px;
  }

  .meetai-button:hover {
    transform: scale(1.1);
    background: linear-gradient(135deg, #0080FF 0%, #00C6FF 100%);
  }

  .meetai-assistant {
    position: fixed;
    bottom: 90px;
    right: 20px;
    width: 300px;
    background: var(--card-bg);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    z-index: 98;
    display: none;
    flex-direction: column;
    max-height: 400px;
  }

  .meetai-header {
    padding: 12px 16px;
    background: linear-gradient(135deg, #0080FF 0%, #00C6FF 100%);
    color: white;
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .meetai-messages {
    flex: 1;
    padding: 12px;
    overflow-y: auto;
    max-height: 300px;
  }

  .meetai-message {
    margin-bottom: 8px;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
  }

  .meetai-user {
    background: var(--primary);
    color: white;
    margin-left: 20px;
  }

  .meetai-bot {
    background: var(--bg-color);
    margin-right: 20px;
  }

  .meetai-input {
    display: flex;
    padding: 12px;
    gap: 8px;
  }

  .meetai-input input {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: var(--bg-color);
    color: var(--text-color);
  }

  /* Modal Styles */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .modal-content {
    background: var(--card-bg);
    border-radius: 12px;
    width: 500px;
    max-width: 90%;
    max-height: 90vh;
    overflow-y: auto;
  }

  .modal-header {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .modal-body {
    padding: 16px;
  }

  .close-modal {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
  }

  /* Post Styles */
  .post {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .post-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .post-user {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .user-name {
    font-weight: 600;
    font-size: 18px;
  }

  .post-meta {
    font-size: 14px;
    color: var(--secondary-text);
  }

  .post-content {
    margin-bottom: 12px;
    font-size: 18px;
    line-height: 1.5;
    white-space: pre-wrap; /* Preserve formatting */
  }

  .post-text-truncated {
    display: block;
  }

  .post-text-full {
    display: none;
  }

  .read-more, .read-less {
    color: var(--primary);
    cursor: pointer;
    font-weight: 600;
  }

  .post-media {
    margin-bottom: 12px;
    border-radius: 8px;
    overflow: hidden;
    max-height: 400px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: var(--bg-color);
    cursor: pointer;
  }

  .post-media img, .post-media video {
    width: 100%;
    height: auto;
    object-fit: contain;
  }

  .post-stats {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    color: var(--secondary-text);
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
  }

  .post-interactions {
    display: flex;
    justify-content: space-around;
    padding: 8px 0;
    border-bottom: 1px solid var(--border-color);
  }

  .interaction-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
    color: var(--secondary-text);
    font-weight: 600;
  }

  .interaction-btn:hover {
    background: var(--bg-color);
  }

  .interaction-btn.starred {
    color: var(--warning);
  }

  .comments-section {
    padding-top: 12px;
  }

  .comment-input {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
  }

  .comment-input input {
    flex: 1;
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid var(--border-color);
    background: var(--bg-color);
    font-size: 16px;
    outline: none;
  }

  .send-comment-btn {
    background: var(--primary);
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.3s;
  }

  .send-comment-btn:hover {
    background: var(--primary-dark);
  }

  .comment {
    display: flex;
    gap: 10px;
    margin-bottom: 8px;
  }

  .comment-content {
    background: var(--bg-color);
    padding: 8px 12px;
    border-radius: 18px;
    max-width: 85%;
  }

  .comment-author {
    font-weight: 600;
    font-size: 14px;
    color: var(--text-color);
    margin-bottom: 2px;
  }

  .comment-text {
    font-size: 16px;
    line-height: 1.4;
  }

  .comment-meta {
    font-size: 12px;
    color: var(--secondary-text);
    margin-top: 4px;
  }

  .view-more-comments {
    color: var(--primary);
    cursor: pointer;
    font-weight: 600;
    margin-top: 8px;
    display: block;
    text-align: center;
  }

  /* Professional Comment Modal Styles */
  #commentsModal .modal-content {
    width: 600px;
    max-width: 95%;
  }

  #commentsModal .modal-body {
    padding: 0;
  }

  .all-comments-list {
    padding: 16px;
    max-height: 70vh;
    overflow-y: auto;
  }

  .all-comments-list .comment {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 12px;
    margin-bottom: 12px;
  }

  .all-comments-list .comment:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
  }

  .all-comments-list .comment-content {
    background: var(--bg-color);
    border-radius: 12px;
    padding: 10px 15px;
    max-width: 100%;
  }

  .all-comments-list .comment-author {
    font-size: 16px;
  }

  .all-comments-list .comment-text {
    font-size: 16px;
  }

  /* Notification Styles */
  .notification-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    width: 350px;
    background: var(--card-bg);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 100;
    display: none;
    margin-top: 10px;
  }

  .notification-header {
    padding: 12px 16px;
    font-weight: 700;
    font-size: 18px;
    border-bottom: 1px solid var(--border-color);
  }

  .notification-list {
    max-height: 400px;
    overflow-y: auto;
  }

  .notification-item {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.2s;
  }

  .notification-item:hover {
    background: var(--bg-color);
  }

  .notification-item.unread {
    background: rgba(0, 128, 255, 0.05);
  }

  .notification-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
  }

  .notification-content {
    flex: 1;
    font-size: 14px;
  }

  .notification-time {
    font-size: 12px;
    color: var(--secondary-text);
    margin-top: 4px;
  }

  .notification-footer {
    padding: 10px;
    text-align: center;
    border-top: 1px solid var(--border-color);
  }

  /* Responsive Design */
  @media (max-width: 1024px) {
    .sidebar {
      width: 240px;
    }

    .main-content {
      margin-left: 240px;
    }
  }

  @media (max-width: 768px) {
    .sidebar {
      width: 100%;
      height: auto;
      position: relative;
      border-right: none;
      padding: 10px;
    }

    .sidebar-menu {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
    }

    .sidebar-menu li {
      margin: 5px;
    }

    .sidebar-menu a {
      padding: 8px;
      font-size: 16px;
    }

    .main-content {
      margin-left: 0;
      padding: 10px;
    }

    .navbar {
      padding: 10px;
    }

    .search-bar {
      display: none;
    }

    .notification-dropdown {
      width: 90%;
      right: 5%;
    }
  }
</style>
</head>
<body>

<!-- Modals -->
<div class="modal" id="postModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Create Meetcast</h2>
      <button class="close-modal" onclick="postModal.style.display='none'; document.body.style.overflow='auto';">&times;</button>
    </div>
    <div class="modal-body">
      <textarea id="postText" placeholder="What's on your mind?" rows="5"></textarea>
      <input type="file" id="postMedia" accept="image/*,video/*">
      <select id="privacySelect">
        <option value="public">Public</option>
        <option value="friends">Friends</option>
        <option value="private">Only Me</option>
      </select>
      <button id="postBtn" class="btn btn-primary" style="margin-top: 10px;">Post</button>
    </div>
  </div>
</div>

<div class="modal" id="mediaModal">
  <div class="modal-content" style="width: 90%; max-width: 800px; padding: 0;">
    <div class="modal-header" style="border-bottom: none;">
      <button class="close-modal" onclick="mediaModal.style.display='none'; document.body.style.overflow='auto';">&times;</button>
    </div>
    <div class="modal-body" style="text-align: center;">
      <img id="mediaModalImage" style="max-width: 100%; max-height: 80vh; display: none;">
      <video id="mediaModalVideo" controls style="max-width: 100%; max-height: 80vh; display: none;"></video>
    </div>
  </div>
</div>

<!-- Professional Comments Modal -->
<div class="modal" id="commentsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Responses</h2>
      <button class="close-modal" onclick="commentsModal.style.display='none'; document.body.style.overflow='auto';">&times;</button>
    </div>
    <div class="modal-body">
      <div class="all-comments-list" id="allCommentsList">
        <!-- All comments will be rendered here -->
      </div>
      <div class="comment-input" style="padding: 16px; border-top: 1px solid var(--border-color);">
        <div class="user-avatar small" id="modalUserAvatar"></div>
        <input type="text" id="modalResponseInput" placeholder="Write a response..." onkeypress="handleModalResponseKeypress(event)">
        <button class="send-comment-btn" onclick="addResponseFromModalButton()">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>
  </div>
</div>

<div class="app-container">
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>MEET</h2>
    </div>
    <ul class="sidebar-menu">
      <li><a href="#" onclick="window.location.reload()"><i class="fas fa-home"></i> Feed</a></li>
      <li><a href="#" onclick="goToChat()"><i class="fas fa-comments"></i> Chat</a></li>
      <li><a href="#" onclick="goToMeetrader()"><i class="fas fa-chart-line"></i> Meetrader</a></li>
      <li><a href="#" onclick="goToMeetversity()"><i class="fas fa-graduation-cap"></i> Meetversity</a></li>
      <li><a href="#" onclick="goToOrganization()"><i class="fas fa-building"></i> Organization</a></li>
      <li><a href="#" onclick="goToMyProfile()"><i class="fas fa-user"></i> Profile</a></li>
      <li><a href="#" onclick="logout()"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
    </ul>
  </div>

  <div class="main-content">
    <div class="navbar">
      <div class="nav-controls">
        <div class="search-bar">
          <i class="fas fa-search" style="margin-right: 10px;"></i>
          <input type="text" placeholder="Search...">
        </div>
        <button class="btn" onclick="toggleTheme()">
          <i class="fas fa-moon" id="themeIcon"></i>
        </button>
        <div class="btn" id="notificationBtn" style="position: relative;">
          <i class="fas fa-bell"></i>
          <span class="unread-badge" id="notificationBadge"></span>
          <div class="notification-dropdown" id="notificationDropdown">
            <div class="notification-header">Notifications</div>
            <div class="notification-list" id="notificationList">
              <!-- Notifications load here -->
              <div style="text-align: center; padding: 20px; color: var(--secondary-text);" id="notificationLoading">Loading notifications...</div>
            </div>
            <div class="notification-footer">
              <a href="#" style="color: var(--primary); text-decoration: none; font-size: 14px;">View All</a>
            </div>
          </div>
        </div>
      </div>
      <div class="user-profile-nav" onclick="goToMyProfile()">
        <div class="user-avatar" id="navUserAvatar">
          <!-- Avatar and status indicator -->
        </div>
        <span id="navUserName">Loading...</span>
      </div>
    </div>

    <div class="post-composer">
      <div class="composer-header">
        <div class="user-avatar small" id="composerUserAvatar"></div>
        <div class="composer-input" onclick="postModal.style.display='flex'; document.body.style.overflow='hidden';">
          What's on your mind?
        </div>
      </div>
      <div class="composer-divider"></div>
      <div class="composer-actions">
        <div class="action-btn" onclick="document.getElementById('postMedia').click()">
          <i class="fas fa-image" style="color: #4CAF50;"></i> Photo/Video
        </div>
        <div class="action-btn">
          <i class="fas fa-video" style="color: #F44336;"></i> Live Video
        </div>
        <div class="action-btn">
          <i class="fas fa-calendar-alt" style="color: #FF9800;"></i> Event
        </div>
      </div>
    </div>

    <div id="postsContainer">
      <div class="loading" style="text-align: center; padding: 20px;">Loading meetcasts...</div>
    </div>

    <div class="meetai-button" onclick="toggleMeetAI()">
      <i class="fas fa-robot"></i>
    </div>

    <div class="meetai-assistant" id="meetaiAssistant">
      <div class="meetai-header">
        <span>MeetAI Assistant</span>
        <button class="close-modal" onclick="toggleMeetAI()">&times;</button>
      </div>
      <div class="meetai-messages" id="meetaiMessages">
        <!-- AI messages here -->
      </div>
      <div class="meetai-input">
        <input type="text" id="meetaiInput" placeholder="Ask MeetAI anything...">
        <button class="send-comment-btn"><i class="fas fa-paper-plane"></i></button>
      </div>
    </div>
  </div>
</div>

<script type="module">
  // Import Firebase modules
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
  import { getAuth, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
  import { getFirestore, collection, doc, addDoc, getDoc, getDocs, query, where, orderBy, limit, onSnapshot, updateDoc, deleteDoc, serverTimestamp, arrayUnion, arrayRemove, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
  import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-storage.js";

  // Firebase Configuration (Replace with your actual config)
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_AUTH_DOMAIN",
    projectId: "YOUR_PROJECT_ID",
    storageBucket: "YOUR_STORAGE_BUCKET",
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
    appId: "YOUR_APP_ID"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const storage = getStorage(app);

  // DOM Elements
  const postsContainer = document.getElementById('postsContainer');
  const postModal = document.getElementById('postModal');
  const postText = document.getElementById('postText');
  const postMedia = document.getElementById('postMedia');
  const privacySelect = document.getElementById('privacySelect');
  const postBtn = document.getElementById('postBtn');
  const mediaModal = document.getElementById('mediaModal');
  const mediaModalImage = document.getElementById('mediaModalImage');
  const mediaModalVideo = document.getElementById('mediaModalVideo');
  const commentsModal = document.getElementById('commentsModal');
  const allCommentsList = document.getElementById('allCommentsList');
  const modalResponseInput = document.getElementById('modalResponseInput');
  const modalUserAvatar = document.getElementById('modalUserAvatar');
  const navUserAvatar = document.getElementById('navUserAvatar');
  const navUserName = document.getElementById('navUserName');
  const composerUserAvatar = document.getElementById('composerUserAvatar');
  const notificationBtn = document.getElementById('notificationBtn');
  const notificationDropdown = document.getElementById('notificationDropdown');
  const notificationList = document.getElementById('notificationList');
  const notificationBadge = document.getElementById('notificationBadge');
  const notificationLoading = document.getElementById('notificationLoading');

  // Global State
  let currentUser = null;
  let postListeners = {};
  let postDataMap = {};
  let starsCountMap = {};
  let userCache = {};
  let currentModalPostId = null; // To track which post's comments are open

  // ===== UTILITY FUNCTIONS =====

  function showMessage(message, type = 'error') {
    // Simple message display (replace with a proper toast/snackbar implementation)
    console.log(`[${type.toUpperCase()}] ${message}`);
    alert(message);
  }

  function setLoading(elementId, isLoading) {
    const element = document.getElementById(elementId);
    if (element) {
      element.disabled = isLoading;
      element.innerHTML = isLoading ? '<i class="fas fa-spinner fa-spin"></i>' : element.dataset.originalText || element.innerText;
      if (!element.dataset.originalText) {
        element.dataset.originalText = element.innerText;
      }
    }
  }

  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTimestamp(timestamp) {
    if (!timestamp) return 'Just now';
    
    const date = timestamp.toDate();
    const now = new Date();
    const diff = now - date;
    
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);
    
    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    
    return date.toLocaleDateString();
  }

  // ===== USER DATA & AVATAR HANDLING =====

  async function getUserData(userId) {
    if (userCache[userId]) {
      return userCache[userId];
    }
    const userDoc = await getDoc(doc(db, 'users', userId));
    if (userDoc.exists()) {
      userCache[userId] = userDoc.data();
      return userCache[userId];
    }
    return null;
  }

  async function getUserDataWithCache(userId) {
    if (userCache[userId]) {
      return userCache[userId];
    }
    return getUserData(userId);
  }

  function updateAvatar(avatarEl, photoURL, userName, initial, isOnline) {
    const statusClass = isOnline ? 'status-online' : 'status-offline';
    let avatarHtml = `${initial}<div class="status-indicator ${statusClass}"></div>`;

    if (photoURL) {
      avatarHtml = `<img src="${photoURL}" alt="${userName}" onerror="this.onerror=null; this.src='';" style="width:100%; height:100%; border-radius:50%; object-fit:cover;">`;
    }
    
    // Add the status indicator wrapper
    avatarHtml += `<div class="status-indicator ${statusClass}"></div>`;
    avatarEl.innerHTML = avatarHtml;
  }

  function updateAllUserAvatars(userId, photoURL, userName, isOnline) {
    const initial = userName ? userName.charAt(0).toUpperCase() : 'U';
    const avatarElements = document.querySelectorAll(`[data-user-id="${userId}"]`);
    avatarElements.forEach(el => {
      updateAvatar(el, photoURL, userName, initial, isOnline);
    });
  }

  // Real-time listener for current user's profile (for avatar updates across the app)
  function setupCurrentUserProfileListener(userId) {
    const userDocRef = doc(db, 'users', userId);
    onSnapshot(userDocRef, (docSnap) => {
      if (docSnap.exists()) {
        const userData = docSnap.data();
        userCache[userId] = userData; // Update cache
        
        // Update navigation bar
        navUserName.textContent = userData.displayName || 'User';
        updateAvatar(navUserAvatar, userData.photoURL, userData.displayName, userData.displayName ? userData.displayName.charAt(0).toUpperCase() : 'U', userData.isOnline);
        updateAvatar(composerUserAvatar, userData.photoURL, userData.displayName, userData.displayName ? userData.displayName.charAt(0).toUpperCase() : 'U', userData.isOnline);
        
        // Update all other instances of the user's avatar/name
        updateAllUserAvatars(userId, userData.photoURL, userData.displayName, userData.isOnline);
      }
    }, error => {
      console.error("Error listening to current user profile:", error);
    });
  }

  // Real-time listener for other users' profiles (for avatar/status updates in posts)
  function setupUserProfileListener(userId) {
    const userDocRef = doc(db, 'users', userId);
    onSnapshot(userDocRef, (docSnap) => {
      if (docSnap.exists()) {
        const userData = docSnap.data();
        userCache[userId] = userData; // Update cache
        updateAllUserAvatars(userId, userData.photoURL, userData.displayName, userData.isOnline);
      }
    }, error => {
      console.error(`Error listening to user ${userId} profile:`, error);
    });
  }

  // ===== POST CRUD & INTERACTIONS =====

  async function uploadMedia(file) {
    const storageRef = ref(storage, `posts/${currentUser.uid}/${Date.now()}_${file.name}`);
    const snapshot = await uploadBytes(storageRef, file);
    return getDownloadURL(snapshot.ref);
  }

  async function createPost(text, mediaFiles, privacy) {
    let mediaUrl = null;
    let mediaType = null;

    if (mediaFiles && mediaFiles.length > 0) {
      const file = mediaFiles[0];
      if (file.size > 10 * 1024 * 1024) { // 10MB limit
        throw new Error('File size too large');
      }
      mediaUrl = await uploadMedia(file);
      mediaType = file.type.startsWith('video') ? 'video' : 'image';
    }

    const newPost = {
      userId: currentUser.uid,
      userName: currentUser.displayName || 'Anonymous',
      photoURL: currentUser.photoURL || null,
      text: text,
      media: mediaUrl,
      mediaType: mediaType,
      privacy: privacy,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    await addDoc(collection(db, 'posts'), newPost);
  }

  async function toggleStar(postId) {
    const starRef = doc(db, `posts/${postId}/stars`, currentUser.uid);
    const starDoc = await getDoc(starRef);

    if (starDoc.exists()) {
      await deleteDoc(starRef);
    } else {
      await setDoc(starRef, {
        userId: currentUser.uid,
        createdAt: serverTimestamp()
      });
      // Send notification to post owner
      const postData = postDataMap[postId];
      if (postData && postData.userId !== currentUser.uid) {
        await sendNotification(postData.userId, 'like', postId, postData.text);
      }
    }
  }

  async function addResponse(postId, text) {
    const responseRef = doc(collection(db, `posts/${postId}/responses`));
    await setDoc(responseRef, {
      responseId: responseRef.id,
      userId: currentUser.uid,
      userName: currentUser.displayName || 'Anonymous',
      photoURL: currentUser.photoURL || null,
      text: text,
      createdAt: serverTimestamp()
    });

    // Send notification to post owner
    const postData = postDataMap[postId];
    if (postData && postData.userId !== currentUser.uid) {
      await sendNotification(postData.userId, 'comment', postId, text);
    }
  }

  // ===== REAL-TIME UPDATES & RENDERING =====

  function setupRealTimeListener() {
    const postsQuery = query(collection(db, "posts"), orderBy("createdAt", "desc"));
    
    onSnapshot(postsQuery, async (snapshot) => {
      // Clean up previous listeners and maps
      Object.values(postListeners).forEach(obj => {
        Object.values(obj).forEach(unsub => unsub());
      });
      postListeners = {};
      postDataMap = {};
      starsCountMap = {};

      postsContainer.innerHTML = "";
      const postPromises = snapshot.docs.map(async (doc) => {
        const post = doc.data();
        if (canViewPost(post)) {
          // Ensure user data is in cache for initial render
          await getUserDataWithCache(post.userId);
          
          postDataMap[doc.id] = { ...post, responses: [], authorPhotoURL: userCache[post.userId]?.photoURL || post.photoURL };
          setupPostWithRealtimeData(doc.id, post);
        }
      });
      await Promise.all(postPromises);
      
      if (snapshot.empty) {
        postsContainer.innerHTML = '<div class="loading">No meetcasts yet. Be the first to post!</div>';
      }
    }, error => {
      console.error('Real-time listener error:', error);
      postsContainer.innerHTML = '<div class="error-message">Failed to load meetcasts. Please refresh the page.</div>';
    });
  }

  function setupPostWithRealtimeData(postId, initialPostData) {
    const postDocRef = doc(db, "posts", postId);
    
    // Post document listener (for text/media updates)
    const unsubscribePost = onSnapshot(postDocRef, async (docSnap) => {
      if (docSnap.exists()) {
        const updated = docSnap.data();
        // Update post data in map
        postDataMap[postId] = { ...postDataMap[postId], ...updated };
        // Re-render the post content
        renderPostContent(postId, postDataMap[postId]);
      }
    });

    // Responses listener
    const responsesQuery = query(collection(db, `posts/${postId}/responses`), orderBy('createdAt', 'desc'));
    const unsubscribeResponses = onSnapshot(responsesQuery, (snap) => {
      const responses = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      postDataMap[postId].responses = responses;
      updateStats(postId);
      updateCommentsSection(postId, responses);
    });

    // Stars count listener
    const starsQuery = query(collection(db, `posts/${postId}/stars`));
    const unsubscribeStars = onSnapshot(starsQuery, (snap) => {
      starsCountMap[postId] = snap.size;
      updateStats(postId);
    });

    // User star status listener
    const userStarRef = doc(db, `posts/${postId}/stars`, currentUser.uid);
    const unsubscribeUserStar = onSnapshot(userStarRef, (snap) => {
      updateStarStatus(postId, snap.exists());
    });

    postListeners[postId] = {
      post: unsubscribePost,
      responses: unsubscribeResponses,
      stars: unsubscribeStars,
      userStar: unsubscribeUserStar
    };

    // Initial render
    renderPost(postId, initialPostData);
    // Setup listener for the post owner's profile
    setupUserProfileListener(initialPostData.userId);
  }

  function renderPost(id, data) {
    let postEl = document.querySelector(`[data-post-id="${id}"]`);
    if (postEl) {
      // If post already exists, just update its content (handled by renderPostContent)
      return;
    }

    postEl = document.createElement('div');
    postEl.classList.add('post');
    postEl.setAttribute('data-post-id', id);
    postsContainer.prepend(postEl); // Prepend to show newest first

    // Initial structure render (content will be filled by renderPostContent)
    postEl.innerHTML = `
      <div class="post-header">
        <div class="post-user" onclick="viewProfile('${data.userId}')">
          <div class="user-avatar" data-user-id="${data.userId}"></div>
          <div>
            <div class="user-name" style="cursor: pointer; color: var(--primary);">${data.userName || 'Anonymous'}</div>
            <div class="post-meta">
              <span class="timestamp">${formatTimestamp(data.createdAt)}</span> ‚Ä¢ 
              <span class="privacy">${data.privacy === 'public' ? 'üåç Public' : data.privacy === 'friends' ? 'üë• Friends' : 'üîí Only Me'}</span>
            </div>
          </div>
        </div>
        <div class="post-actions">
          <i class="fas fa-ellipsis-h" style="cursor: pointer;" onclick="togglePostMenu('${id}')"></i>
          <div class="post-menu" id="menu-${id}" style="display: none; position: absolute; right: 0; top: 30px; background: var(--card-bg); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 10;">
            <div class="post-menu-item" onclick="editPost('${id}')" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
              <i class="fas fa-edit"></i> Edit
            </div>
            <div class="post-menu-item delete" onclick="deletePost('${id}')" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: var(--error);">
              <i class="fas fa-trash"></i> Delete
            </div>
          </div>
        </div>
      </div>
      <div class="post-content-wrapper">
        <!-- Content, media, stats, interactions, comments will be injected here -->
      </div>
    `;

    // Initial avatar update
    const userData = userCache[data.userId];
    if (userData) {
      updateAllUserAvatars(data.userId, userData.photoURL, userData.displayName, userData.isOnline);
    }

    renderPostContent(id, data);
  }

  function renderPostContent(id, data) {
    const postEl = document.querySelector(`[data-post-id="${id}"]`);
    if (!postEl) return;

    const contentWrapper = postEl.querySelector('.post-content-wrapper');
    const isOwner = data.userId === currentUser.uid;

    // Truncate long posts
    const maxLength = 200;
    let postContentHtml = '';
    if (data.text && data.text.length > maxLength) {
      postContentHtml = `
        <div class="post-content">
          <div class="post-text-truncated">
            ${escapeHtml(data.text.substring(0, maxLength))}...
            <span class="read-more" onclick="toggleReadMore(this)">Read more</span>
          </div>
          <div class="post-text-full" style="display: none;">
            ${escapeHtml(data.text)}
            <span class="read-less" onclick="toggleReadLess(this)"> Read less</span>
          </div>
        </div>
      `;
    } else {
      postContentHtml = `<div class="post-content">${escapeHtml(data.text || '')}</div>`;
    }

    // Media HTML
    let mediaHtml = '';
    if (data.media) {
      const isVideo = data.mediaType === 'video' || data.media.match(/\.(mp4|mov|avi|webm)$/i);
      mediaHtml = `
        <div class="post-media" onclick="openMediaModal('${data.media}', ${isVideo})">
          ${isVideo ? 
            `<video controls><source src="${data.media}"></video>` : 
            `<img src="${data.media}" loading="lazy">`
          }
        </div>
      `;
    }

    contentWrapper.innerHTML = `
      ${postContentHtml}
      ${mediaHtml}
      <div class="post-stats">
        <div class="stats-text">0 stars ‚Ä¢ 0 responses</div>
      </div>
      <div class="post-interactions">
        <div class="interaction-btn star-btn" onclick="window.toggleStar('${id}')">
          <i class="fas fa-star"></i> <span>Star</span>
        </div>
        <div class="interaction-btn" onclick="focusResponse('${id}')">
          <i class="fas fa-comment"></i> <span>Respond</span>
        </div>
        <div class="interaction-btn" onclick="sharePost('${id}', '${escapeHtml(data.text || '')}')">
          <i class="fas fa-share"></i> <span>Promote</span>
        </div>
      </div>
      <div class="comments-section" id="comments-${id}">
        <!-- Comments and input will be updated here -->
      </div>
    `;

    // Update visibility of post menu
    const menu = document.getElementById(`menu-${id}`);
    if (menu) {
      menu.style.display = isOwner ? menu.style.display : 'none';
    }

    updateStats(id);
    updateCommentsSection(id, postDataMap[id].responses || []);
  }

  function updateStats(postId) {
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (!postEl) return;

    const statsEl = postEl.querySelector('.stats-text');
    const starsCount = starsCountMap[postId] || 0;
    const responsesCount = postDataMap[postId]?.responses?.length || 0;

    if (statsEl) {
      statsEl.textContent = `${starsCount} star${starsCount === 1 ? '' : 's'} ‚Ä¢ ${responsesCount} response${responsesCount === 1 ? '' : 's'}`;
    }
  }

  function updateStarStatus(postId, isStarred) {
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (!postEl) return;

    const starBtn = postEl.querySelector('.star-btn');
    if (starBtn) {
      starBtn.classList.toggle('starred', isStarred);
      starBtn.querySelector('span').textContent = isStarred ? 'Starred' : 'Star';
    }
  }

  function renderComment(comment) {
    const userData = userCache[comment.userId] || {};
    const responseInitial = userData.displayName ? userData.displayName.charAt(0).toUpperCase() : 'U';
    const photoURL = userData.photoURL || comment.photoURL;
    const isOnline = userData.isOnline || false;
    const statusClass = isOnline ? 'status-online' : 'status-offline';
    
    let avatarHtml = `${responseInitial}<div class="status-indicator ${statusClass}"></div>`;
    if (photoURL) {
      avatarHtml = `<img src="${photoURL}" alt="${comment.userName}" style="width:100%; height:100%; border-radius:50%; object-fit:cover;">`;
    }
    avatarHtml += `<div class="status-indicator ${statusClass}"></div>`;

    return `
      <div class="comment" data-comment-id="${comment.id}">
        <div class="user-avatar small" data-user-id="${comment.userId}" onclick="viewProfile('${comment.userId}')" style="flex-shrink: 0;">
          ${avatarHtml}
        </div>
        <div class="comment-content">
          <div class="comment-author" onclick="viewProfile('${comment.userId}')" style="cursor: pointer;">${comment.userName || 'User'}</div>
          <div class="comment-text">${escapeHtml(comment.text)}</div>
          <div class="comment-meta">${formatTimestamp(comment.createdAt)}</div>
        </div>
      </div>
    `;
  }

  function updateCommentsSection(postId, responses) {
    const commentsSection = document.getElementById(`comments-${postId}`);
    if (!commentsSection) return;

    // 1. Render visible comments (max 3)
    const visibleResponses = responses.slice(0, 3);
    let commentsHtml = visibleResponses.map(renderComment).join('');

    // 2. Add "View More" button if more than 3 comments exist
    if (responses.length > 3) {
      commentsHtml += `<span class="view-more-comments" onclick="openResponsesModal('${postId}')">View all ${responses.length} responses</span>`;
    }

    // 3. Add the comment input box
    const user = auth.currentUser;
    const userInitial = user.displayName ? user.displayName.charAt(0).toUpperCase() : 'U';
    const userPhotoURL = user.photoURL;
    const isOnline = userCache[user.uid]?.isOnline || false;
    const statusClass = isOnline ? 'status-online' : 'status-offline';

    let userAvatarHtml = `${userInitial}<div class="status-indicator ${statusClass}"></div>`;
    if (userPhotoURL) {
      userAvatarHtml = `<img src="${userPhotoURL}" alt="${user.displayName}" style="width:100%; height:100%; border-radius:50%; object-fit:cover;"><div class="status-indicator ${statusClass}"></div>`;
    }

    const inputHtml = `
      <div class="comment-input">
        <div class="user-avatar small" data-user-id="${user.uid}">
          ${userAvatarHtml}
        </div>
        <input type="text" id="response-${postId}" placeholder="Write a response..." onkeypress="handleResponseKeypress(event, '${postId}')">
        <button class="send-comment-btn" onclick="addResponseViaButton('${postId}')">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    `;

    commentsSection.innerHTML = commentsHtml + inputHtml;

    // Pre-cache all comment authors' data
    responses.forEach(response => {
      if (!userCache[response.userId]) {
        setupUserProfileListener(response.userId);
      }
    });
  }

  // ===== RESPONSES MODAL (PROFESSIONAL INTERFACE) =====

  window.openResponsesModal = async (postId) => {
    currentModalPostId = postId;
    const responses = postDataMap[postId]?.responses || [];
    
    // Render all comments
    const responsesHtml = responses.map(renderComment).join('');
    allCommentsList.innerHTML = responsesHtml || '<div style="text-align: center; color: var(--secondary-text); padding: 20px;">No responses yet.</div>';
    
    // Update modal user avatar
    const user = auth.currentUser;
    const userInitial = user.displayName ? user.displayName.charAt(0).toUpperCase() : 'U';
    const userPhotoURL = user.photoURL;
    const isOnline = userCache[user.uid]?.isOnline || false;
    const statusClass = isOnline ? 'status-online' : 'status-offline';

    let userAvatarHtml = `${userInitial}<div class="status-indicator ${statusClass}"></div>`;
    if (userPhotoURL) {
      userAvatarHtml = `<img src="${userPhotoURL}" alt="${user.displayName}" style="width:100%; height:100%; border-radius:50%; object-fit:cover;"><div class="status-indicator ${statusClass}"></div>`;
    }
    modalUserAvatar.innerHTML = userAvatarHtml;
    
    commentsModal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    modalResponseInput.focus();
  };

  window.handleModalResponseKeypress = async (event) => {
    if (event.key === 'Enter' && currentModalPostId) {
      await addResponseFromModalInput(currentModalPostId);
    }
  };

  window.addResponseFromModalButton = async () => {
    if (currentModalPostId) {
      await addResponseFromModalInput(currentModalPostId);
    }
  };

  async function addResponseFromModalInput(postId) {
    const text = modalResponseInput.value.trim();
    
    if (!text) return;
    
    try {
      await addResponse(postId, text);
      modalResponseInput.value = '';
      // The real-time listener will automatically update the comments list in the modal
    } catch (error) {
      console.error('Error adding response from modal:', error);
      showMessage('Failed to add response. Please try again.');
    }
  }

  // ===== NOTIFICATIONS =====

  async function sendNotification(targetUserId, type, postId, content) {
    if (targetUserId === currentUser.uid) return; // Don't notify self

    let message = '';
    switch (type) {
      case 'like':
        message = `${currentUser.displayName} starred your post.`;
        break;
      case 'comment':
        message = `${currentUser.displayName} responded to your post: "${content.substring(0, 30)}..."`;
        break;
      case 'share':
        message = `${currentUser.displayName} promoted your post.`;
        break;
      case 'associate':
        message = `${currentUser.displayName} is now associated with you.`;
        break;
      default:
        message = `${currentUser.displayName} interacted with your content.`;
    }

    await addDoc(collection(db, 'notifications'), {
      targetUserId: targetUserId,
      sourceUserId: currentUser.uid,
      type: type,
      postId: postId,
      message: message,
      read: false,
      createdAt: serverTimestamp()
    });
  }

  function renderNotification(notification) {
    const isUnread = !notification.read;
    const user = userCache[notification.sourceUserId] || {};
    const initial = user.displayName ? user.displayName.charAt(0).toUpperCase() : 'U';
    const photoURL = user.photoURL;

    let avatarHtml = `<div class="user-avatar small notification-avatar" data-user-id="${notification.sourceUserId}">${initial}</div>`;
    if (photoURL) {
      avatarHtml = `<img src="${photoURL}" alt="${user.displayName}" class="notification-avatar">`;
    }

    return `
      <div class="notification-item ${isUnread ? 'unread' : ''}" data-notification-id="${notification.id}" onclick="handleNotificationClick('${notification.id}', '${notification.postId}')">
        ${avatarHtml}
        <div class="notification-content">
          <div>${notification.message}</div>
          <div class="notification-time">${formatTimestamp(notification.createdAt)}</div>
        </div>
      </div>
    `;
  }

  async function markNotificationAsRead(notificationId) {
    try {
      await updateDoc(doc(db, 'notifications', notificationId), {
        read: true
      });
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  }

  window.handleNotificationClick = (notificationId, postId) => {
    markNotificationAsRead(notificationId);
    // Navigate to the post or open the post in a modal/view
    // For now, we'll just scroll to the post if it's on the page
    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
    if (postEl) {
      postEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    notificationDropdown.style.display = 'none';
  };

  function setupNotificationListener(userId) {
    const notificationsQuery = query(
      collection(db, 'notifications'),
      where('targetUserId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(10)
    );

    onSnapshot(notificationsQuery, async (snapshot) => {
      notificationLoading.style.display = 'none';
      let unreadCount = 0;
      let notificationsHtml = '';

      // Pre-cache all source users
      const sourceUserIds = snapshot.docs.map(doc => doc.data().sourceUserId);
      await Promise.all(sourceUserIds.map(id => getUserDataWithCache(id)));

      snapshot.docs.forEach(doc => {
        const notification = { id: doc.id, ...doc.data() };
        if (!notification.read) {
          unreadCount++;
        }
        notificationsHtml += renderNotification(notification);
      });

      notificationList.innerHTML = notificationsHtml || '<div style="text-align: center; padding: 20px; color: var(--secondary-text);">No new notifications.</div>';
      notificationBadge.style.display = unreadCount > 0 ? 'flex' : 'none';
      notificationBadge.textContent = unreadCount > 9 ? '9+' : unreadCount;
    }, error => {
      console.error('Error loading notifications:', error);
      notificationList.innerHTML = '<div class="error-message" style="text-align: center; padding: 20px; color: var(--error);">Failed to load notifications. Please refresh the page.</div>';
    });
  }

  window.toggleNotificationDropdown = () => {
    const isVisible = notificationDropdown.style.display === 'block';
    notificationDropdown.style.display = isVisible ? 'none' : 'block';
  };

  notificationBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleNotificationDropdown();
  });

  document.addEventListener('click', (e) => {
    if (!notificationBtn.contains(e.target)) {
      notificationDropdown.style.display = 'none';
    }
  });

  // ===== ASSOCIATION LOGIC FIX =====

  async function isAssociated(targetUserId) {
    const associateRef = doc(db, `users/${currentUser.uid}/associates`, targetUserId);
    const docSnap = await getDoc(associateRef);
    return docSnap.exists();
  }

  window.associateWithUser = async (targetUserId) => {
    try {
      // 1. Add to my 'associates' list
      await setDoc(doc(db, `users/${currentUser.uid}/associates`, targetUserId), {
        userId: targetUserId,
        createdAt: serverTimestamp()
      });

      // 2. Add to target user's 'associatedWith' list
      await setDoc(doc(db, `users/${targetUserId}/associatedWith`, currentUser.uid), {
        associatedUserId: currentUser.uid,
        createdAt: serverTimestamp()
      });

      showMessage('User associated successfully!', 'success');
      // Send notification to target user
      await sendNotification(targetUserId, 'associate', null, null);
      
      // Reload the users list or update the button state
      if (window.loadUsersList) window.loadUsersList();
    } catch (error) {
      console.error('Error associating user:', error);
      showMessage('Failed to associate user. Please try again.');
    }
  };

  window.removeAssociation = async (targetUserId) => {
    try {
      // 1. Remove from my 'associates' list
      await deleteDoc(doc(db, `users/${currentUser.uid}/associates`, targetUserId));

      // 2. Remove from target user's 'associatedWith' list
      await deleteDoc(doc(db, `users/${targetUserId}/associatedWith`, currentUser.uid));

      showMessage('User disassociated successfully!', 'success');
      
      // Reload the users list or update the button state
      if (window.loadUsersList) window.loadUsersList();
    } catch (error) {
      console.error('Error removing association:', error);
      showMessage('Failed to disassociate user. Please try again.');
    }
  };

  // ===== PROMOTION/SHARE FEATURE =====

  window.sharePost = (postId, postText) => {
    const postUrl = window.location.href.split('?')[0] + `?post=${postId}`;
    const encodedText = encodeURIComponent(`Check out this post on MEET: "${postText}"\n\n${postUrl}`);

    const shareOptions = [
      { name: 'WhatsApp', url: `https://wa.me/?text=${encodedText}` },
      { name: 'Twitter', url: `https://twitter.com/intent/tweet?text=${encodedText}` },
      { name: 'Facebook', url: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(postUrl)}&quote=${encodeURIComponent(postText)}` },
      { name: 'Email', url: `mailto:?subject=Check out this post on MEET&body=${encodedText}` },
      { name: 'LinkedIn', url: `https://www.linkedin.com/shareArticle?mini=true&url=${encodeURIComponent(postUrl)}&title=MEET%20Post&summary=${encodedText}` }
    ];

    let shareHtml = '<h2>Promote Post</h2><p>Share this post on:</p><div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px;">';
    
    shareOptions.forEach(option => {
      shareHtml += `
        <a href="${option.url}" target="_blank" style="text-decoration: none; color: var(--text-color); background: var(--bg-color); padding: 10px 15px; border-radius: 8px; display: flex; align-items: center; gap: 8px; transition: background 0.2s;">
          <i class="fab fa-${option.name.toLowerCase() === 'email' ? 'envelope' : option.name.toLowerCase() === 'twitter' ? 'twitter' : option.name.toLowerCase() === 'linkedin' ? 'linkedin' : option.name.toLowerCase() === 'whatsapp' ? 'whatsapp' : 'share-alt'}"></i>
          ${option.name}
        </a>
      `;
    });
    shareHtml += '</div>';

    // Use a generic modal for sharing (assuming one exists or creating a temporary one)
    const shareModal = document.getElementById('shareModal') || document.createElement('div');
    shareModal.id = 'shareModal';
    shareModal.className = 'modal';
    shareModal.innerHTML = `
      <div class="modal-content" style="width: 400px;">
        <div class="modal-header">
          <h2>Promote Post</h2>
          <button class="close-modal" onclick="document.getElementById('shareModal').style.display='none'; document.body.style.overflow='auto';">&times;</button>
        </div>
        <div class="modal-body">
          ${shareHtml}
        </div>
      </div>
    `;
    if (!document.getElementById('shareModal')) {
      document.body.appendChild(shareModal);
    }
    
    shareModal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  };

  // ===== NAVIGATION FUNCTIONS (FIXED PROFILE LINKING) =====

  window.viewProfile = (userId) => {
    // Navigate to profile page with the correct user ID
    window.location.href = 'profile.html?uid=' + userId;
  };

  // Other navigation functions (kept for completeness)
  window.goToMyProfile = function() {
    const user = auth.currentUser;
    if (user) {
      window.location.href = 'profile.html?uid=' + user.uid;
    }
  }

  window.goToChat = function() {
    window.location.href = 'chat.html';
  }

  window.goToMeetrader = function() {
    window.location.href = 'meetrader.html';
  }

  window.goToMeetversity = function() {
    window.location.href = 'meetversity.html';
  }

  window.goToOrganization = function() {
    window.location.href = 'organization.html';
  }

  // ===== OTHER FUNCTIONS (KEPT FROM ORIGINAL) =====

  window.toggleReadMore = (element) => {
    const truncated = element.parentElement;
    const full = truncated.nextElementSibling;
    
    truncated.style.display = 'none';
    full.style.display = 'block';
  };

  window.toggleReadLess = (element) => {
    const full = element.parentElement;
    const truncated = full.previousElementSibling;
    
    full.style.display = 'none';
    truncated.style.display = 'block';
  };

  window.togglePostMenu = (postId) => {
    const menu = document.getElementById(`menu-${postId}`);
    const isVisible = menu.style.display === 'block';
    
    document.querySelectorAll('.post-menu').forEach(m => {
      m.style.display = 'none';
    });
    
    if (menu) {
      menu.style.display = isVisible ? 'none' : 'block';
    }
  };

  window.editPost = async (postId) => {
    showMessage('Edit feature coming soon!', 'success');
    document.getElementById(`menu-${postId}`).style.display = 'none';
  };

  window.deletePost = async (postId) => {
    try {
      await deleteDoc(doc(db, 'posts', postId));
      showMessage('Post deleted successfully!', 'success');
    } catch (error) {
      console.error('Error deleting meetcast:', error);
      showMessage('Failed to delete post. Please try again.');
    }
    document.getElementById(`menu-${postId}`).style.display = 'none';
  };

  window.focusResponse = (postId) => {
    const responseInput = document.getElementById(`response-${postId}`);
    if (responseInput) {
      responseInput.focus();
    }
  };

  window.handleResponseKeypress = async (event, postId) => {
    if (event.key === 'Enter') {
      await addResponseFromInput(postId);
    }
  };

  window.addResponseViaButton = async (postId) => {
    await addResponseFromInput(postId);
  };

  async function addResponseFromInput(postId) {
    const input = document.getElementById(`response-${postId}`);
    const text = input.value.trim();
    
    if (!text) return;
    
    try {
      await addResponse(postId, text);
      input.value = '';
    } catch (error) {
      console.error('Error adding response:', error);
      showMessage('Failed to add response. Please try again.');
    }
  }

  window.openMediaModal = (mediaUrl, isVideo = false) => {
    if (isVideo) {
      mediaModalImage.style.display = 'none';
      mediaModalVideo.style.display = 'block';
      mediaModalVideo.src = mediaUrl;
    } else {
      mediaModalImage.style.display = 'block';
      mediaModalVideo.style.display = 'none';
      mediaModalImage.src = mediaUrl;
    }
    
    mediaModal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  };

  const canViewPost = (post) => {
    const user = auth.currentUser;
    if (!user) return false;
    
    if (post.privacy === 'public') return true;
    if (post.privacy === 'friends') {
      // This logic needs to be implemented based on your association system
      // For now, we'll assume 'friends' means public for simplicity until the full logic is available
      return true; 
    }
    if (post.privacy === 'private' && post.userId === user.uid) return true;
    return false;
  };

  // Theme Toggle
  function initTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.classList.toggle('dark-mode', savedTheme === 'dark');
    document.getElementById('themeIcon').className = savedTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
  }

  window.toggleTheme = () => {
    const isDark = document.body.classList.toggle('dark-mode');
    const theme = isDark ? 'dark' : 'light';
    localStorage.setItem('theme', theme);
    document.getElementById('themeIcon').className = isDark ? 'fas fa-sun' : 'fas fa-moon';
  };

  // MeetAI Toggle
  window.toggleMeetAI = () => {
    const assistant = document.getElementById('meetaiAssistant');
    assistant.style.display = assistant.style.display === 'flex' ? 'none' : 'flex';
  };

  // Logout
  window.logout = async () => {
    try {
      await signOut(auth);
      window.location.href = 'login.html'; // Redirect to login page
    } catch (error) {
      console.error('Logout error:', error);
      showMessage('Logout failed. Please try again.');
    }
  };

  // ===== INITIALIZATION =====

  onAuthStateChanged(auth, (user) => {
    if (user) {
      currentUser = user;
      // 1. Setup real-time listeners
      setupCurrentUserProfileListener(user.uid);
      setupRealTimeListener();
      setupNotificationListener(user.uid);
      
      // 2. Initial UI update
      navUserName.textContent = user.displayName || 'User';
      // The avatar update is handled by the real-time listener, but a quick initial update is good
      updateAllUserAvatars(user.uid, user.photoURL, user.displayName, true); 
      
    } else {
      // User is signed out
      window.location.href = 'login.html';
    }
  });

  document.addEventListener('DOMContentLoaded', function() {
    initTheme();
    
    // Close menus when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.post-actions')) {
        document.querySelectorAll('.post-menu').forEach(menu => {
          menu.style.display = 'none';
        });
      }
    });
    
    // Prevent zoom on double-tap (iOS)
    document.addEventListener('touchstart', function(e) {
      if (e.touches.length > 1) {
        e.preventDefault();
      }
    }, { passive: false });
    
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, false);
  });
</script>
</body>
</html>
